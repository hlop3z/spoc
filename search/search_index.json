{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"SPOC - Single Point Of Connections","text":"<p>SPOC is a powerful Python framework for building Django-like modular monolith applications. It provides a structured approach to application organization with dynamic module loading, dependency management, and lifecycle orchestration.</p> <p>     (S)ingle \u2014      (P)oint \u2014      (O)f \u2014      (C)onnections </p> python -m pip install spocSuccessfully installed spoc!"},{"location":"#what-is-spoc","title":"What is SPOC?","text":"<p>SPOC (Single Point Of Connections) is a framework for building modular monolithic applications in Python, inspired by Django's app system. It provides:</p> <ul> <li>App-based Architecture: Organize your codebase into reusable, self-contained apps</li> <li>Dynamic Module Loading: Import modules at runtime with dependency resolution</li> <li>Component Registration: Declarative component system with metadata support</li> <li>Middleware &amp; Hooks: Plugin system for cross-cutting concerns</li> <li>Application Lifecycle: Structured startup and shutdown processes</li> <li>Dependency Management: Handle module dependencies with circular dependency detection</li> </ul> <p>SPOC helps you create organized, maintainable applications with clear separation of concerns while keeping the simplicity of a monolithic architecture.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Django-like App System: Structure your application into reusable, self-contained modules</li> <li>Framework: Application orchestration with lifecycle management</li> <li>Components Registry: Tag and discover components with rich metadata</li> <li>Importer: Efficient module loading with dependency tracking and caching</li> <li>Configuration Handling: Flexible settings and environment variable management</li> <li>Plugin System: Extensible architecture for middleware and cross-cutting concerns</li> <li>Worker System: Background task management for concurrent operations</li> </ul>"},{"location":"#spoc-architecture","title":"SPOC Architecture","text":"<pre><code>flowchart TB\n    %% Configuration inputs feeding into SPOC Core\n    subgraph Configurations\n      direction TB\n      Settings[Settings]\n      EnvVars[Environment Variables]\n    end\n\n    %% Framework layer initialized by SPOC Core\n    SPOCCore[SPOC]\n    Framework[Framework]\n\n    %% Project elements handled by Framework\n    subgraph \"Framework Entities\"\n      direction TB\n      Apps[Applications]\n      Comps[Components]\n      Plugs[Plugins]\n    end\n\n    %% Connections\n    Settings --&gt; SPOCCore\n    EnvVars --&gt; SPOCCore\n\n    SPOCCore --&gt; Framework\n    Framework --&gt; Comps\n    Framework --&gt; Apps\n    Framework --&gt; Plugs\n\n    %% Registration loop\n    Apps --&gt;|register via spoc| Framework\n    Plugs --&gt;|register via spoc| Framework\n</code></pre>"},{"location":"#spoc-workflow","title":"SPOC Workflow","text":"<pre><code>sequenceDiagram\nautonumber\n    Spoc --&gt;&gt; Framework: Create a Framework\n    Note over Spoc,Framework: Step 1: Establish the Framework\n\n    Framework --&gt;&gt; Framework: Define Components\n    Note over Framework,Framework: Step 2: Handle the Components\n\n    Framework --&gt;&gt; Application: Use Components\n    Note over Framework,Application: Step 3: Extend Application\n\n    Application --&gt;&gt; Spoc: Register the Application(s)\n    Note over Spoc,Application: Step 5 to 8: Initialize the Framework\n\n    Spoc -) Application: Load Settings\n    Spoc -) Application: Load Environment Variables\n    Spoc -) Application: Load Plugins\n    Spoc -) Application: Load Installed Apps &amp; Components\n\n    Note over Application: Final Step: Utilize the Application(s)</code></pre>"},{"location":"#app-structure","title":"App Structure","text":"<p>SPOC apps are organized in a modular structure similar to Django apps. A typical app might include:</p> <pre><code>myapp/\n\u251c\u2500\u2500 __init__.py  # App initialization\n\u251c\u2500\u2500 models.py    # Data models\n\u251c\u2500\u2500 views.py     # View handlers\n\u251c\u2500\u2500 services.py  # Business logic\n\u2514\u2500\u2500 components/  # Custom components\n</code></pre> <p>Apps are registered in your configuration and loaded automatically by the framework during startup.</p>"},{"location":"#getting-started","title":"Getting Started","text":"<p>SPOC is designed to be simple to use while providing powerful capabilities:</p> <pre><code>from pathlib import Path\nfrom spoc.framework import Framework, Schema\n\n# Define your application structure\nschema = Schema(\n    modules=[\"models\", \"views\", \"services\"],\n    dependencies={\n        \"views\": [\"models\"],\n        \"services\": [\"models\"]\n    },\n    hooks={\n        \"models\": {\n            \"startup\": lambda m: print(f\"Initializing models: {m}\"),\n            \"shutdown\": lambda m: print(f\"Shutting down models: {m}\")\n        }\n    }\n)\n\n# Create and initialize the framework\nframework = Framework(\n    base_dir=Path(\"./my_project\"),\n    schema=schema\n)\n\n# Start your application\nframework.startup()\n\n# When done\nframework.shutdown()\n</code></pre> <p>Check out the Quick Start guide to begin using SPOC in your projects.</p>"},{"location":"contributing/","title":"Contributing to SPOC","text":"<p>Thank you for considering contributing to SPOC! This document outlines the process for contributing to the project and how you can help make it better.</p>"},{"location":"contributing/#development-environment","title":"Development Environment","text":""},{"location":"contributing/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.13 or higher</li> <li>uv (preferred) or pip for package management</li> </ul>"},{"location":"contributing/#setting-up-for-development","title":"Setting Up for Development","text":"<ol> <li>Fork the repository on GitHub</li> <li>Clone your fork locally:</li> </ol> <pre><code>git clone https://github.com/yourusername/spoc.git\ncd spoc\n</code></pre> <ol> <li>Set up a virtual environment and install development dependencies:</li> </ol> <pre><code># Using uv\nuv venv .venv\nsource .venv/bin/activate  # On Windows: .venv\\Scripts\\activate\nuv install -e \".[dev]\"\n\n# Using pip\npython -m venv .venv\nsource .venv/bin/activate  # On Windows: .venv\\Scripts\\activate\npip install -e \".[dev]\"\n</code></pre> <ol> <li>Set up pre-commit hooks:</li> </ol> <pre><code>pre-commit install\n</code></pre>"},{"location":"contributing/#development-workflow","title":"Development Workflow","text":""},{"location":"contributing/#branching-strategy","title":"Branching Strategy","text":"<ul> <li><code>main</code>: Contains the latest stable version</li> <li><code>dev</code>: Development branch for next release</li> <li>Feature branches: Create from <code>dev</code> with the format <code>feature/your-feature-name</code></li> <li>Bugfix branches: Create from <code>dev</code> with the format <code>bugfix/issue-description</code></li> </ul>"},{"location":"contributing/#making-changes","title":"Making Changes","text":"<ol> <li>Create a new branch for your changes:</li> </ol> <pre><code>git checkout -b feature/your-feature-name\n</code></pre> <ol> <li> <p>Make your changes and ensure they adhere to the project's style guidelines</p> </li> <li> <p>Run tests to ensure your changes don't break existing functionality:</p> </li> </ol> <pre><code>pytest\n</code></pre> <ol> <li>Run linting and type checking:</li> </ol> <pre><code>ruff check .\nmypy src\n</code></pre>"},{"location":"contributing/#commit-guidelines","title":"Commit Guidelines","text":"<ul> <li>Use clear, descriptive commit messages</li> <li>Reference issue numbers in your commit messages where applicable</li> <li>Keep commits focused on a single logical change</li> <li>Format commit messages as:</li> </ul> <pre><code>type(scope): description\n\nAdditional details if necessary\n</code></pre> <p>Where <code>type</code> is one of: feat, fix, docs, style, refactor, test, chore</p>"},{"location":"contributing/#pull-request-process","title":"Pull Request Process","text":"<ol> <li>Update the documentation to reflect any changes you've made</li> <li>Ensure all tests pass and code quality checks succeed</li> <li>Push your changes to your fork:</li> </ol> <pre><code>git push origin feature/your-feature-name\n</code></pre> <ol> <li>Create a pull request against the <code>dev</code> branch</li> <li>In your PR, provide:</li> <li>A clear description of the changes</li> <li>Any relevant issue numbers</li> <li>Notes on any dependencies that were added or removed</li> </ol>"},{"location":"contributing/#testing","title":"Testing","text":""},{"location":"contributing/#running-tests","title":"Running Tests","text":"<p>Run the test suite with:</p> <pre><code>pytest\n</code></pre> <p>For coverage information:</p> <pre><code>pytest --cov=spoc\n</code></pre>"},{"location":"contributing/#writing-tests","title":"Writing Tests","text":"<ul> <li>Place tests in the <code>tests/</code> directory</li> <li>Name test files with the pattern <code>test_*.py</code></li> <li>Test classes should be named <code>Test*</code></li> <li>Test methods should be named <code>test_*</code></li> <li>Use pytest fixtures where appropriate</li> </ul>"},{"location":"contributing/#documentation","title":"Documentation","text":""},{"location":"contributing/#building-documentation","title":"Building Documentation","text":"<p>Build the documentation locally:</p> <pre><code>cd docs\nmkdocs serve\n</code></pre> <p>This will start a local server at http://127.0.0.1:8000/ where you can preview your changes.</p>"},{"location":"contributing/#writing-documentation","title":"Writing Documentation","text":"<ul> <li>Use clear, concise language</li> <li>Include examples where applicable</li> <li>Follow Google-style docstrings for Python code</li> <li>Update the documentation when you add or modify features</li> </ul>"},{"location":"contributing/#style-guidelines","title":"Style Guidelines","text":"<p>SPOC follows these style guidelines:</p> <ul> <li>Code Style: PEP 8 with a line length of 88 characters (enforced by ruff)</li> <li>Type Hints: All public functions and methods should have type hints</li> <li>Docstrings: Google-style docstrings</li> <li>Import Order:</li> <li>Standard library imports</li> <li>Third-party library imports</li> <li>Local application imports (with a blank line between each group)</li> </ul>"},{"location":"contributing/#license","title":"License","text":"<p>By contributing to SPOC, you agree that your contributions will be licensed under the project's license.</p>"},{"location":"contributing/#questions","title":"Questions?","text":"<p>If you have any questions about contributing, please open an issue or reach out to the maintainers. We're happy to help!</p>"},{"location":"advanced/lifecycle/","title":"Lifecycle Management","text":"<p>Master SPOC's lifecycle system to handle startup, shutdown, and resource management in your applications.</p>"},{"location":"advanced/lifecycle/#overview","title":"Overview","text":"<p>SPOC provides a powerful lifecycle system that manages the initialization and teardown of your application modules. This system ensures modules are loaded in the correct order based on dependencies and provides hooks for custom initialization and cleanup logic.</p> <p>What you'll learn:</p> <ul> <li>How the framework lifecycle works from instantiation to shutdown</li> <li>Three ways to implement lifecycle hooks</li> <li>Hook execution order and dependency resolution</li> <li>Error handling strategies</li> <li>Practical patterns for database connections, caching, and resource management</li> </ul>"},{"location":"advanced/lifecycle/#the-complete-lifecycle","title":"The Complete Lifecycle","text":"<p>Understanding SPOC's lifecycle helps you know when and where to execute initialization and cleanup code.</p>"},{"location":"advanced/lifecycle/#lifecycle-phases","title":"Lifecycle Phases","text":"<pre><code>sequenceDiagram\n    participant User\n    participant Framework\n    participant Importer\n    participant Apps\n    participant Modules\n    participant Hooks\n\n    User-&gt;&gt;Framework: Framework(base_dir, schema)\n    activate Framework\n    Framework-&gt;&gt;Framework: inject_apps(base_dir)\n    Framework-&gt;&gt;Framework: load configuration\n    Framework-&gt;&gt;Framework: collect plugins\n    Framework-&gt;&gt;Framework: _register_all_apps()\n    Framework-&gt;&gt;Importer: register modules\n\n    Note over Framework: Automatic startup\n    Framework-&gt;&gt;Importer: startup()\n    activate Importer\n    Importer-&gt;&gt;Importer: on_startup() hook\n    loop For each module in dependency order\n        Importer-&gt;&gt;Modules: import module\n        Importer-&gt;&gt;Hooks: execute schema-level startup hook\n        Importer-&gt;&gt;Modules: call module.initialize()\n    end\n    Importer--&gt;&gt;Framework: startup complete\n    deactivate Importer\n\n    Framework-&gt;&gt;Framework: _init_components()\n    deactivate Framework\n\n    Note over User,Framework: Application runs...\n\n    User-&gt;&gt;Framework: shutdown()\n    activate Framework\n    Framework-&gt;&gt;Importer: shutdown()\n    activate Importer\n    loop For each module in reverse order\n        Importer-&gt;&gt;Modules: call module.teardown()\n        Importer-&gt;&gt;Hooks: execute schema-level shutdown hook\n    end\n    Importer-&gt;&gt;Importer: on_shutdown() hook\n    deactivate Importer\n    deactivate Framework</code></pre>"},{"location":"advanced/lifecycle/#phase-breakdown","title":"Phase Breakdown","text":"<ol> <li>Instantiation Phase</li> <li>Framework object created</li> <li>Configuration loaded from <code>spoc.toml</code> and <code>settings.py</code></li> <li>Plugins discovered and loaded</li> <li> <p>Apps registered with the importer</p> </li> <li> <p>Startup Phase (automatic)</p> </li> <li>Global <code>on_startup()</code> hook executes</li> <li>Modules imported in dependency order</li> <li>Schema-level hooks execute for each module</li> <li>Module-level <code>initialize()</code> functions called</li> <li> <p>Components collected and registered</p> </li> <li> <p>Runtime Phase</p> </li> <li>Application logic executes</li> <li>Components are accessible</li> <li> <p>Modules are fully initialized</p> </li> <li> <p>Shutdown Phase (manual)</p> </li> <li>Modules torn down in reverse dependency order</li> <li>Module-level <code>teardown()</code> functions called</li> <li>Schema-level hooks execute for each module</li> <li>Global <code>on_shutdown()</code> hook executes</li> </ol>"},{"location":"advanced/lifecycle/#module-level-lifecycle-functions","title":"Module-Level Lifecycle Functions","text":"<p>The simplest way to add lifecycle behavior is through module-level functions.</p>"},{"location":"advanced/lifecycle/#basic-implementation","title":"Basic Implementation","text":"<p>Define <code>initialize()</code> and <code>teardown()</code> functions in any module:</p> <pre><code># apps/blog/models.py\nimport logging\nfrom typing import Dict, Any\n\nlogger = logging.getLogger(__name__)\n\n# Your module code\nclass Post:\n    pass\n\n# Lifecycle functions\ndef initialize() -&gt; None:\n    \"\"\"\n    Called when this module is loaded.\n    Executes after dependencies are initialized.\n    \"\"\"\n    logger.info(\"Initializing blog models...\")\n    # Setup code here\n\ndef teardown() -&gt; None:\n    \"\"\"\n    Called when the framework shuts down.\n    Executes before dependent modules are torn down.\n    \"\"\"\n    logger.info(\"Tearing down blog models...\")\n    # Cleanup code here\n</code></pre>"},{"location":"advanced/lifecycle/#execution-guarantees","title":"Execution Guarantees","text":"<ul> <li><code>initialize()</code> runs once per module after all dependencies are loaded</li> <li><code>teardown()</code> runs once per module in reverse dependency order</li> <li>Functions are optional - modules without them load normally</li> <li>Errors in lifecycle functions halt the startup/shutdown process</li> </ul>"},{"location":"advanced/lifecycle/#practical-example-database-connection","title":"Practical Example: Database Connection","text":"<pre><code># apps/blog/models.py\nimport sqlite3\nfrom typing import Optional\n\n# Module-level connection\n_db_connection: Optional[sqlite3.Connection] = None\n\ndef initialize() -&gt; None:\n    \"\"\"Establish database connection on startup.\"\"\"\n    global _db_connection\n    print(\"Connecting to database...\")\n    _db_connection = sqlite3.connect(\"blog.db\")\n    _db_connection.execute(\"\"\"\n        CREATE TABLE IF NOT EXISTS posts (\n            id INTEGER PRIMARY KEY,\n            title TEXT NOT NULL,\n            content TEXT\n        )\n    \"\"\")\n    _db_connection.commit()\n    print(\"Database ready!\")\n\ndef teardown() -&gt; None:\n    \"\"\"Close database connection on shutdown.\"\"\"\n    global _db_connection\n    if _db_connection:\n        print(\"Closing database connection...\")\n        _db_connection.close()\n        _db_connection = None\n\ndef get_db() -&gt; sqlite3.Connection:\n    \"\"\"Get the database connection.\"\"\"\n    if _db_connection is None:\n        raise RuntimeError(\"Database not initialized\")\n    return _db_connection\n\n# Your models use get_db()\nclass Post:\n    @staticmethod\n    def create(title: str, content: str) -&gt; int:\n        db = get_db()\n        cursor = db.execute(\n            \"INSERT INTO posts (title, content) VALUES (?, ?)\",\n            (title, content)\n        )\n        db.commit()\n        return cursor.lastrowid\n</code></pre>"},{"location":"advanced/lifecycle/#schema-level-hooks","title":"Schema-Level Hooks","text":"<p>Schema hooks provide centralized lifecycle management with access to the loaded module object.</p>"},{"location":"advanced/lifecycle/#hook-definition","title":"Hook Definition","text":"<p>Hooks are defined in the <code>Schema</code> when creating your framework:</p> <pre><code>from pathlib import Path\nfrom types import ModuleType\nfrom spoc import Framework, Schema\n\ndef on_models_startup(module: ModuleType) -&gt; None:\n    \"\"\"\n    Called after a models module is loaded.\n\n    Args:\n        module: The loaded module object\n    \"\"\"\n    print(f\"Models loaded: {module.__name__}\")\n    # Access module attributes\n    if hasattr(module, 'initialize_cache'):\n        module.initialize_cache()\n\ndef on_models_shutdown(module: ModuleType) -&gt; None:\n    \"\"\"\n    Called before a models module is torn down.\n\n    Args:\n        module: The module being shut down\n    \"\"\"\n    print(f\"Models shutting down: {module.__name__}\")\n    if hasattr(module, 'flush_cache'):\n        module.flush_cache()\n\nschema = Schema(\n    modules=[\"models\", \"views\"],\n    dependencies={\n        \"views\": [\"models\"],\n    },\n    hooks={\n        \"models\": {\n            \"startup\": on_models_startup,\n            \"shutdown\": on_models_shutdown,\n        },\n    },\n)\n\nframework = Framework(\n    base_dir=Path(__file__).parent,\n    schema=schema,\n)\n</code></pre>"},{"location":"advanced/lifecycle/#hook-signature","title":"Hook Signature","text":"<p>All schema hooks receive the module object:</p> <pre><code>def hook_function(module: ModuleType) -&gt; None:\n    \"\"\"\n    Args:\n        module: The loaded module object with all its attributes\n    \"\"\"\n    pass\n</code></pre>"},{"location":"advanced/lifecycle/#when-to-use-schema-hooks","title":"When to Use Schema Hooks","text":"<p>Use schema hooks when you need to:</p> <ul> <li>Inspect module attributes before initialization</li> <li>Perform cross-module setup (e.g., registering models with an ORM)</li> <li>Add behavior to all modules of a certain type</li> <li>Validate module structure or components</li> </ul>"},{"location":"advanced/lifecycle/#example-orm-registration","title":"Example: ORM Registration","text":"<pre><code># main.py\nfrom types import ModuleType\nfrom typing import List, Type\n\nclass ORM:\n    \"\"\"Simple ORM that tracks model classes.\"\"\"\n    models: List[Type] = []\n\n    @classmethod\n    def register(cls, model: Type) -&gt; None:\n        cls.models.append(model)\n        print(f\"Registered model: {model.__name__}\")\n\ndef register_models(module: ModuleType) -&gt; None:\n    \"\"\"\n    Automatically register all model classes with the ORM.\n\n    Looks for classes with __spoc__ metadata of type 'model'.\n    \"\"\"\n    for attr_name in dir(module):\n        if attr_name.startswith('_'):\n            continue\n\n        attr = getattr(module, attr_name)\n\n        # Check if it's a SPOC component of type 'model'\n        if hasattr(attr, '__spoc__'):\n            metadata = attr.__spoc__.metadata\n            if metadata.get('type') == 'model':\n                ORM.register(attr)\n\nschema = Schema(\n    modules=[\"models\", \"views\"],\n    dependencies={\"views\": [\"models\"]},\n    hooks={\n        \"models\": {\n            \"startup\": register_models,\n        },\n    },\n)\n</code></pre>"},{"location":"advanced/lifecycle/#pattern-based-hooks-with-register_hook","title":"Pattern-Based Hooks with register_hook()","text":"<p>For advanced scenarios, register hooks that match module patterns using wildcards.</p>"},{"location":"advanced/lifecycle/#registration-api","title":"Registration API","text":"<pre><code>from spoc.core.importer import Importer\n\nImporter.register_hook(\n    pattern=\"*.models\",  # Matches any app's models module\n    on_startup=lambda components: print(f\"Models loaded: {components}\"),\n    on_shutdown=lambda components: print(f\"Models unloading: {components}\"),\n)\n</code></pre>"},{"location":"advanced/lifecycle/#pattern-syntax","title":"Pattern Syntax","text":"Pattern Matches Example <code>*.models</code> All models modules <code>blog.models</code>, <code>users.models</code> <code>blog.*</code> All modules in blog app <code>blog.models</code>, <code>blog.views</code> <code>*.views</code> All views modules Any app's views <code>test.*.models</code> Nested app models <code>test.app1.models</code> <code>core.services</code> Exact module Only <code>core.services</code>"},{"location":"advanced/lifecycle/#wildcard-support","title":"Wildcard Support","text":"<ul> <li><code>*</code> - Matches any sequence of characters</li> <li><code>?</code> - Matches any single character</li> <li>Patterns are converted to regex internally</li> </ul>"},{"location":"advanced/lifecycle/#hook-signature-for-patterns","title":"Hook Signature for Patterns","text":"<p>Pattern hooks receive a set of components instead of the module:</p> <pre><code>def pattern_hook(components: set) -&gt; None:\n    \"\"\"\n    Args:\n        components: Set of components decorated with @Components.register()\n    \"\"\"\n    for component in components:\n        print(f\"Processing: {component}\")\n</code></pre>"},{"location":"advanced/lifecycle/#example-cache-warmup-for-all-services","title":"Example: Cache Warmup for All Services","text":"<pre><code># framework/lifecycle.py\nfrom typing import Set, Any\nfrom spoc.core.importer import Importer\n\ndef warmup_services(components: Set[Any]) -&gt; None:\n    \"\"\"\n    Warm up all service components on startup.\n\n    Args:\n        components: Set of registered service components\n    \"\"\"\n    print(f\"Warming up {len(components)} services...\")\n\n    for service in components:\n        # Check if service has a warmup method\n        if hasattr(service, 'warmup') and callable(service.warmup):\n            print(f\"  - Warming up {service.__name__}\")\n            service.warmup()\n\ndef cleanup_services(components: Set[Any]) -&gt; None:\n    \"\"\"\n    Clean up all service components on shutdown.\n\n    Args:\n        components: Set of registered service components\n    \"\"\"\n    print(f\"Cleaning up {len(components)} services...\")\n\n    for service in components:\n        if hasattr(service, 'cleanup') and callable(service.cleanup):\n            print(f\"  - Cleaning up {service.__name__}\")\n            service.cleanup()\n\n# Register pattern-based hooks\nImporter.register_hook(\n    pattern=\"*.services\",\n    on_startup=warmup_services,\n    on_shutdown=cleanup_services,\n)\n</code></pre> <p>Usage in your service module:</p> <pre><code># apps/blog/services.py\nfrom spoc import Components\n\ncomponents = Components()\ncomponents.add_type(\"service\")\n\n@components.register(\"service\")\nclass BlogService:\n    _cache = {}\n\n    @classmethod\n    def warmup(cls) -&gt; None:\n        \"\"\"Populate cache on startup.\"\"\"\n        print(\"Loading blog posts into cache...\")\n        cls._cache['posts'] = [\"Post 1\", \"Post 2\", \"Post 3\"]\n\n    @classmethod\n    def cleanup(cls) -&gt; None:\n        \"\"\"Clear cache on shutdown.\"\"\"\n        print(\"Flushing blog cache...\")\n        cls._cache.clear()\n</code></pre>"},{"location":"advanced/lifecycle/#hook-execution-order","title":"Hook Execution Order","text":"<p>Understanding the order in which hooks execute is critical for managing dependencies.</p>"},{"location":"advanced/lifecycle/#startup-sequence","title":"Startup Sequence","text":"<pre><code>graph TD\n    A[Framework.startup] --&gt; B[Importer.on_startup]\n    B --&gt; C[Topological Sort Modules]\n    C --&gt; D[For Each Module]\n    D --&gt; E[Import Module]\n    E --&gt; F[Pattern Hook Startup]\n    F --&gt; G[Schema Hook Startup]\n    G --&gt; H[Module initialize]\n    H --&gt; I{More Modules?}\n    I --&gt;|Yes| D\n    I --&gt;|No| J[Components Initialized]</code></pre> <p>Order:</p> <ol> <li>Global <code>Importer.on_startup()</code> hook</li> <li>For each module in dependency order:</li> <li>Module is imported</li> <li>Pattern-based hooks execute (if pattern matches)</li> <li>Schema-level hooks execute (if defined)</li> <li>Module's <code>initialize()</code> function called (if exists)</li> <li>Components collected and framework ready</li> </ol>"},{"location":"advanced/lifecycle/#shutdown-sequence","title":"Shutdown Sequence","text":"<pre><code>graph TD\n    A[Framework.shutdown] --&gt; B[Reverse Topological Sort]\n    B --&gt; C[For Each Module]\n    C --&gt; D[Module teardown]\n    D --&gt; E[Schema Hook Shutdown]\n    E --&gt; F[Pattern Hook Shutdown]\n    F --&gt; G{More Modules?}\n    G --&gt;|Yes| C\n    G --&gt;|No| H[Importer.on_shutdown]\n    H --&gt; I[Shutdown Complete]</code></pre> <p>Order:</p> <ol> <li>For each module in reverse dependency order:</li> <li>Module's <code>teardown()</code> function called (if exists)</li> <li>Schema-level hooks execute (if defined)</li> <li>Pattern-based hooks execute (if pattern matches)</li> <li>Global <code>Importer.on_shutdown()</code> hook</li> </ol>"},{"location":"advanced/lifecycle/#dependency-resolution-example","title":"Dependency Resolution Example","text":"<p>Given this schema:</p> <pre><code>schema = Schema(\n    modules=[\"models\", \"services\", \"views\"],\n    dependencies={\n        \"services\": [\"models\"],\n        \"views\": [\"services\", \"models\"],\n    },\n)\n</code></pre> <p>Startup order:</p> <ol> <li><code>models</code> - no dependencies</li> <li><code>services</code> - depends on models</li> <li><code>views</code> - depends on both</li> </ol> <p>Shutdown order:</p> <ol> <li><code>views</code> - unload first (most dependent)</li> <li><code>services</code> - unload second</li> <li><code>models</code> - unload last (no dependents)</li> </ol>"},{"location":"advanced/lifecycle/#multiple-hooks-on-same-module","title":"Multiple Hooks on Same Module","text":"<p>When multiple hook types are registered for a module:</p> <pre><code># Pattern hook\nImporter.register_hook(\n    pattern=\"*.models\",\n    on_startup=lambda c: print(\"Pattern: Models loading\"),\n)\n\n# Schema hook\nschema = Schema(\n    modules=[\"models\"],\n    hooks={\n        \"models\": {\n            \"startup\": lambda m: print(\"Schema: Models loading\"),\n        },\n    },\n)\n\n# Module-level hook\n# In models.py\ndef initialize():\n    print(\"Module: Models loading\")\n</code></pre> <p>Execution order:</p> <ol> <li>Pattern hook: \"Pattern: Models loading\"</li> <li>Schema hook: \"Schema: Models loading\"</li> <li>Module hook: \"Module: Models loading\"</li> </ol>"},{"location":"advanced/lifecycle/#custom-startupshutdown-names","title":"Custom Startup/Shutdown Names","text":"<p>Customize the lifecycle function names using the <code>Importer</code> constructor.</p>"},{"location":"advanced/lifecycle/#default-names","title":"Default Names","text":"<p>By default, SPOC looks for:</p> <ul> <li><code>initialize()</code> for startup</li> <li><code>teardown()</code> for shutdown</li> </ul>"},{"location":"advanced/lifecycle/#changing-function-names","title":"Changing Function Names","text":"<p>Create a custom Importer with different names:</p> <pre><code>from spoc.core.importer import Importer\n\n# Use 'setup' and 'cleanup' instead\nimporter = Importer(\n    on_startup_name=\"setup\",\n    on_shutdown_name=\"cleanup\",\n)\n</code></pre> <p>Note: You typically won't create Importer directly; the Framework creates it internally.</p>"},{"location":"advanced/lifecycle/#use-case-legacy-code-integration","title":"Use Case: Legacy Code Integration","text":"<p>When integrating with existing code that uses different naming conventions:</p> <pre><code># apps/legacy/database.py\n\ndef setup():  # Instead of initialize()\n    \"\"\"Legacy code uses 'setup' naming.\"\"\"\n    print(\"Setting up legacy database...\")\n\ndef cleanup():  # Instead of teardown()\n    \"\"\"Legacy code uses 'cleanup' naming.\"\"\"\n    print(\"Cleaning up legacy database...\")\n</code></pre> <p>Configure framework to use legacy names:</p> <pre><code># This feature requires custom framework configuration\n# Currently, you would need to modify the framework source\n# or ensure your code uses initialize/teardown names\n</code></pre> <p>Current limitation: The Framework creates its own Importer instance, so you cannot easily change lifecycle function names without modifying the framework code. This is a potential enhancement for future versions.</p>"},{"location":"advanced/lifecycle/#disabling-lifecycle-functions","title":"Disabling Lifecycle Functions","text":"<p>Set names to <code>None</code> to disable lifecycle function checking:</p> <pre><code>importer = Importer(\n    on_startup_name=None,  # Don't look for initialize()\n    on_shutdown_name=None,  # Don't look for teardown()\n)\n</code></pre>"},{"location":"advanced/lifecycle/#error-handling-in-lifecycle-hooks","title":"Error Handling in Lifecycle Hooks","text":"<p>Proper error handling prevents partial initialization and ensures clean shutdown.</p>"},{"location":"advanced/lifecycle/#error-propagation","title":"Error Propagation","text":"<p>Errors in lifecycle hooks halt the startup/shutdown process:</p> <pre><code># apps/blog/models.py\n\ndef initialize():\n    \"\"\"This error prevents the framework from starting.\"\"\"\n    raise RuntimeError(\"Database connection failed!\")\n\n# Framework initialization will raise SpocError\n</code></pre>"},{"location":"advanced/lifecycle/#best-practices","title":"Best Practices","text":""},{"location":"advanced/lifecycle/#1-graceful-degradation","title":"1. Graceful Degradation","text":"<pre><code>def initialize():\n    \"\"\"Try to initialize, but don't fail if optional resources unavailable.\"\"\"\n    try:\n        connect_to_cache()\n        print(\"Cache connected\")\n    except ConnectionError:\n        print(\"Warning: Cache unavailable, continuing without it\")\n        # Don't raise - the app can work without cache\n</code></pre>"},{"location":"advanced/lifecycle/#2-resource-cleanup-on-error","title":"2. Resource Cleanup on Error","text":"<pre><code>def initialize():\n    \"\"\"Ensure partial resources are cleaned up on error.\"\"\"\n    connection = None\n    try:\n        connection = connect_to_database()\n        initialize_tables(connection)\n    except Exception as e:\n        # Clean up partial state\n        if connection:\n            connection.close()\n        raise RuntimeError(f\"Database initialization failed: {e}\") from e\n</code></pre>"},{"location":"advanced/lifecycle/#3-idempotent-teardown","title":"3. Idempotent Teardown","text":"<pre><code>_database = None\n_cache = None\n\ndef initialize():\n    global _database, _cache\n    _database = connect_to_database()\n    _cache = connect_to_cache()\n\ndef teardown():\n    \"\"\"Safe to call even if initialize failed partway.\"\"\"\n    global _database, _cache\n\n    # Close database if it exists\n    if _database is not None:\n        try:\n            _database.close()\n        except Exception as e:\n            print(f\"Warning: Error closing database: {e}\")\n        finally:\n            _database = None\n\n    # Close cache if it exists\n    if _cache is not None:\n        try:\n            _cache.close()\n        except Exception as e:\n            print(f\"Warning: Error closing cache: {e}\")\n        finally:\n            _cache = None\n</code></pre>"},{"location":"advanced/lifecycle/#4-logging-errors","title":"4. Logging Errors","text":"<pre><code>import logging\nimport traceback\n\nlogger = logging.getLogger(__name__)\n\ndef initialize():\n    \"\"\"Log detailed error information.\"\"\"\n    try:\n        connect_to_external_service()\n    except Exception as e:\n        logger.error(\n            \"Failed to initialize external service\",\n            exc_info=True,  # Include stack trace\n            extra={\n                'service': 'external_api',\n                'error_type': type(e).__name__,\n            }\n        )\n        raise\n\ndef teardown():\n    \"\"\"Log teardown errors but don't propagate.\"\"\"\n    try:\n        disconnect_from_service()\n    except Exception as e:\n        logger.warning(\n            \"Error during teardown (non-fatal)\",\n            exc_info=True,\n        )\n        # Don't raise - best effort cleanup\n</code></pre>"},{"location":"advanced/lifecycle/#framework-error-handling","title":"Framework Error Handling","text":"<p>The framework wraps lifecycle errors in <code>SpocError</code>:</p> <pre><code>from spoc.core.exceptions import SpocError\n\ntry:\n    framework = Framework(\n        base_dir=Path(__file__).parent,\n        schema=schema,\n    )\nexcept SpocError as e:\n    print(f\"Framework failed to start: {e}\")\n    print(f\"Caused by: {e.__cause__}\")\n</code></pre>"},{"location":"advanced/lifecycle/#practical-use-cases","title":"Practical Use Cases","text":"<p>Real-world patterns for common lifecycle scenarios.</p>"},{"location":"advanced/lifecycle/#use-case-1-database-connection-pool","title":"Use Case 1: Database Connection Pool","text":"<pre><code># apps/blog/models.py\nfrom typing import Optional\nimport sqlite3\nfrom contextlib import contextmanager\n\nclass ConnectionPool:\n    \"\"\"Simple connection pool for SQLite.\"\"\"\n\n    def __init__(self, database: str, pool_size: int = 5):\n        self.database = database\n        self.pool_size = pool_size\n        self._connections = []\n        self._in_use = set()\n\n    def initialize(self):\n        \"\"\"Create connection pool.\"\"\"\n        print(f\"Creating connection pool ({self.pool_size} connections)...\")\n        for _ in range(self.pool_size):\n            conn = sqlite3.connect(self.database, check_same_thread=False)\n            self._connections.append(conn)\n\n    def get_connection(self) -&gt; sqlite3.Connection:\n        \"\"\"Get a connection from the pool.\"\"\"\n        if not self._connections:\n            raise RuntimeError(\"Connection pool exhausted\")\n\n        conn = self._connections.pop()\n        self._in_use.add(conn)\n        return conn\n\n    def return_connection(self, conn: sqlite3.Connection):\n        \"\"\"Return a connection to the pool.\"\"\"\n        if conn in self._in_use:\n            self._in_use.remove(conn)\n            self._connections.append(conn)\n\n    @contextmanager\n    def connection(self):\n        \"\"\"Context manager for safe connection handling.\"\"\"\n        conn = self.get_connection()\n        try:\n            yield conn\n        finally:\n            self.return_connection(conn)\n\n    def shutdown(self):\n        \"\"\"Close all connections.\"\"\"\n        print(\"Closing connection pool...\")\n\n        # Close active connections\n        for conn in self._in_use:\n            conn.close()\n        self._in_use.clear()\n\n        # Close pooled connections\n        for conn in self._connections:\n            conn.close()\n        self._connections.clear()\n\n# Module-level pool\n_pool: Optional[ConnectionPool] = None\n\ndef initialize():\n    \"\"\"Initialize the connection pool.\"\"\"\n    global _pool\n    _pool = ConnectionPool(\"blog.db\", pool_size=5)\n    _pool.initialize()\n\n    # Create tables\n    with _pool.connection() as conn:\n        conn.execute(\"\"\"\n            CREATE TABLE IF NOT EXISTS posts (\n                id INTEGER PRIMARY KEY AUTOINCREMENT,\n                title TEXT NOT NULL,\n                content TEXT,\n                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n            )\n        \"\"\")\n        conn.commit()\n\ndef teardown():\n    \"\"\"Shutdown the connection pool.\"\"\"\n    global _pool\n    if _pool:\n        _pool.shutdown()\n        _pool = None\n\ndef get_pool() -&gt; ConnectionPool:\n    \"\"\"Get the connection pool.\"\"\"\n    if _pool is None:\n        raise RuntimeError(\"Connection pool not initialized\")\n    return _pool\n\n# Usage in your models\nclass Post:\n    @staticmethod\n    def create(title: str, content: str) -&gt; int:\n        pool = get_pool()\n        with pool.connection() as conn:\n            cursor = conn.execute(\n                \"INSERT INTO posts (title, content) VALUES (?, ?)\",\n                (title, content)\n            )\n            conn.commit()\n            return cursor.lastrowid\n\n    @staticmethod\n    def get_all():\n        pool = get_pool()\n        with pool.connection() as conn:\n            cursor = conn.execute(\"SELECT * FROM posts\")\n            return cursor.fetchall()\n</code></pre>"},{"location":"advanced/lifecycle/#use-case-2-cache-warmup","title":"Use Case 2: Cache Warmup","text":"<pre><code># apps/blog/services.py\nfrom typing import Dict, List, Optional\nimport time\n\nclass ArticleCache:\n    \"\"\"In-memory cache for articles.\"\"\"\n\n    def __init__(self):\n        self._cache: Dict[int, dict] = {}\n        self._last_update: Optional[float] = None\n\n    def warmup(self):\n        \"\"\"Pre-populate cache with frequently accessed data.\"\"\"\n        print(\"Warming up article cache...\")\n        start = time.time()\n\n        # Simulate loading from database\n        articles = [\n            {\"id\": 1, \"title\": \"Getting Started\", \"views\": 1000},\n            {\"id\": 2, \"title\": \"Advanced Topics\", \"views\": 500},\n            {\"id\": 3, \"title\": \"Best Practices\", \"views\": 750},\n        ]\n\n        for article in articles:\n            self._cache[article[\"id\"]] = article\n\n        self._last_update = time.time()\n\n        elapsed = time.time() - start\n        print(f\"Cache warmed up with {len(articles)} articles in {elapsed:.2f}s\")\n\n    def get(self, article_id: int) -&gt; Optional[dict]:\n        \"\"\"Get article from cache.\"\"\"\n        return self._cache.get(article_id)\n\n    def flush(self):\n        \"\"\"Clear the cache.\"\"\"\n        print(f\"Flushing cache ({len(self._cache)} items)...\")\n        self._cache.clear()\n        self._last_update = None\n\n# Module-level cache\n_cache: Optional[ArticleCache] = None\n\ndef initialize():\n    \"\"\"Initialize and warm up cache.\"\"\"\n    global _cache\n    _cache = ArticleCache()\n    _cache.warmup()\n\ndef teardown():\n    \"\"\"Flush cache on shutdown.\"\"\"\n    global _cache\n    if _cache:\n        _cache.flush()\n        _cache = None\n\ndef get_cache() -&gt; ArticleCache:\n    \"\"\"Get the cache instance.\"\"\"\n    if _cache is None:\n        raise RuntimeError(\"Cache not initialized\")\n    return _cache\n</code></pre>"},{"location":"advanced/lifecycle/#use-case-3-external-api-client","title":"Use Case 3: External API Client","text":"<pre><code># apps/notifications/services.py\nfrom typing import Optional\nimport requests\nfrom requests.adapters import HTTPAdapter\nfrom urllib3.util.retry import Retry\n\nclass EmailAPIClient:\n    \"\"\"HTTP client for email service API.\"\"\"\n\n    def __init__(self, api_key: str, base_url: str):\n        self.api_key = api_key\n        self.base_url = base_url\n        self.session: Optional[requests.Session] = None\n\n    def initialize(self):\n        \"\"\"Create HTTP session with retry logic.\"\"\"\n        print(\"Initializing email API client...\")\n\n        self.session = requests.Session()\n\n        # Configure retries\n        retry_strategy = Retry(\n            total=3,\n            backoff_factor=1,\n            status_forcelist=[429, 500, 502, 503, 504],\n        )\n        adapter = HTTPAdapter(max_retries=retry_strategy)\n\n        self.session.mount(\"http://\", adapter)\n        self.session.mount(\"https://\", adapter)\n\n        # Set default headers\n        self.session.headers.update({\n            \"Authorization\": f\"Bearer {self.api_key}\",\n            \"Content-Type\": \"application/json\",\n        })\n\n        # Test connection\n        try:\n            response = self.session.get(f\"{self.base_url}/health\")\n            response.raise_for_status()\n            print(\"Email API client ready!\")\n        except requests.RequestException as e:\n            self.session.close()\n            raise RuntimeError(f\"Failed to connect to email API: {e}\") from e\n\n    def send_email(self, to: str, subject: str, body: str):\n        \"\"\"Send an email via the API.\"\"\"\n        if not self.session:\n            raise RuntimeError(\"Client not initialized\")\n\n        response = self.session.post(\n            f\"{self.base_url}/send\",\n            json={\n                \"to\": to,\n                \"subject\": subject,\n                \"body\": body,\n            }\n        )\n        response.raise_for_status()\n        return response.json()\n\n    def shutdown(self):\n        \"\"\"Close HTTP session.\"\"\"\n        if self.session:\n            print(\"Closing email API client session...\")\n            self.session.close()\n            self.session = None\n\n# Module-level client\n_client: Optional[EmailAPIClient] = None\n\ndef initialize():\n    \"\"\"Initialize the email client.\"\"\"\n    global _client\n\n    # In production, load from config\n    api_key = \"your-api-key\"\n    base_url = \"https://api.emailservice.com\"\n\n    _client = EmailAPIClient(api_key, base_url)\n    _client.initialize()\n\ndef teardown():\n    \"\"\"Shutdown the email client.\"\"\"\n    global _client\n    if _client:\n        _client.shutdown()\n        _client = None\n\ndef get_client() -&gt; EmailAPIClient:\n    \"\"\"Get the email client instance.\"\"\"\n    if _client is None:\n        raise RuntimeError(\"Email client not initialized\")\n    return _client\n</code></pre>"},{"location":"advanced/lifecycle/#use-case-4-background-worker-pool","title":"Use Case 4: Background Worker Pool","text":"<pre><code># apps/tasks/workers.py\nfrom concurrent.futures import ThreadPoolExecutor\nfrom typing import Optional, Callable, Any\nimport time\n\nclass WorkerPool:\n    \"\"\"Background worker pool for async tasks.\"\"\"\n\n    def __init__(self, max_workers: int = 4):\n        self.max_workers = max_workers\n        self.executor: Optional[ThreadPoolExecutor] = None\n        self._shutdown = False\n\n    def initialize(self):\n        \"\"\"Start the worker pool.\"\"\"\n        print(f\"Starting worker pool with {self.max_workers} workers...\")\n        self.executor = ThreadPoolExecutor(\n            max_workers=self.max_workers,\n            thread_name_prefix=\"spoc-worker\",\n        )\n        self._shutdown = False\n\n    def submit(self, fn: Callable, *args, **kwargs) -&gt; Any:\n        \"\"\"Submit a task to the worker pool.\"\"\"\n        if not self.executor or self._shutdown:\n            raise RuntimeError(\"Worker pool not available\")\n\n        return self.executor.submit(fn, *args, **kwargs)\n\n    def shutdown(self, wait: bool = True):\n        \"\"\"Shutdown the worker pool.\"\"\"\n        if self.executor and not self._shutdown:\n            print(\"Shutting down worker pool...\")\n            self._shutdown = True\n            self.executor.shutdown(wait=wait)\n            self.executor = None\n            print(\"Worker pool stopped\")\n\n# Module-level pool\n_pool: Optional[WorkerPool] = None\n\ndef initialize():\n    \"\"\"Initialize the worker pool.\"\"\"\n    global _pool\n    _pool = WorkerPool(max_workers=4)\n    _pool.initialize()\n\ndef teardown():\n    \"\"\"Shutdown the worker pool.\"\"\"\n    global _pool\n    if _pool:\n        _pool.shutdown(wait=True)  # Wait for pending tasks\n        _pool = None\n\ndef get_pool() -&gt; WorkerPool:\n    \"\"\"Get the worker pool instance.\"\"\"\n    if _pool is None:\n        raise RuntimeError(\"Worker pool not initialized\")\n    return _pool\n\n# Usage example\ndef long_running_task(task_id: int):\n    \"\"\"Simulated background task.\"\"\"\n    print(f\"Task {task_id} starting...\")\n    time.sleep(2)\n    print(f\"Task {task_id} complete!\")\n    return f\"Result {task_id}\"\n\n# Submit tasks from other modules\ndef process_in_background():\n    pool = get_pool()\n    future = pool.submit(long_running_task, 42)\n    # Can check future.result() later\n</code></pre>"},{"location":"advanced/lifecycle/#use-case-5-resource-monitoring","title":"Use Case 5: Resource Monitoring","text":"<pre><code># apps/monitoring/services.py\nfrom typing import Dict, List\nimport psutil\nimport threading\nimport time\n\nclass ResourceMonitor:\n    \"\"\"Monitor system resources during application runtime.\"\"\"\n\n    def __init__(self, interval: int = 60):\n        self.interval = interval\n        self._monitoring = False\n        self._thread: Optional[threading.Thread] = None\n        self._metrics: List[Dict] = []\n\n    def _monitor_loop(self):\n        \"\"\"Background monitoring loop.\"\"\"\n        while self._monitoring:\n            metrics = {\n                'timestamp': time.time(),\n                'cpu_percent': psutil.cpu_percent(interval=1),\n                'memory_percent': psutil.virtual_memory().percent,\n                'disk_percent': psutil.disk_usage('/').percent,\n            }\n            self._metrics.append(metrics)\n\n            # Keep only last 100 readings\n            if len(self._metrics) &gt; 100:\n                self._metrics.pop(0)\n\n            time.sleep(self.interval)\n\n    def start(self):\n        \"\"\"Start monitoring.\"\"\"\n        if self._monitoring:\n            return\n\n        print(f\"Starting resource monitor (interval: {self.interval}s)...\")\n        self._monitoring = True\n        self._thread = threading.Thread(\n            target=self._monitor_loop,\n            daemon=True,\n            name=\"resource-monitor\",\n        )\n        self._thread.start()\n\n    def stop(self):\n        \"\"\"Stop monitoring.\"\"\"\n        if not self._monitoring:\n            return\n\n        print(\"Stopping resource monitor...\")\n        self._monitoring = False\n        if self._thread:\n            self._thread.join(timeout=5)\n            self._thread = None\n\n        # Print summary\n        if self._metrics:\n            avg_cpu = sum(m['cpu_percent'] for m in self._metrics) / len(self._metrics)\n            avg_mem = sum(m['memory_percent'] for m in self._metrics) / len(self._metrics)\n            print(f\"Resource usage - CPU: {avg_cpu:.1f}%, Memory: {avg_mem:.1f}%\")\n\n    def get_metrics(self) -&gt; List[Dict]:\n        \"\"\"Get collected metrics.\"\"\"\n        return self._metrics.copy()\n\n# Module-level monitor\n_monitor: Optional[ResourceMonitor] = None\n\ndef initialize():\n    \"\"\"Start resource monitoring.\"\"\"\n    global _monitor\n    _monitor = ResourceMonitor(interval=30)  # Check every 30 seconds\n    _monitor.start()\n\ndef teardown():\n    \"\"\"Stop monitoring and print summary.\"\"\"\n    global _monitor\n    if _monitor:\n        _monitor.stop()\n        _monitor = None\n</code></pre>"},{"location":"advanced/lifecycle/#complete-example","title":"Complete Example","text":"<p>A comprehensive example showing all lifecycle concepts together:</p> <pre><code># main.py\nfrom pathlib import Path\nfrom types import ModuleType\nfrom typing import Set, Any\nfrom spoc import Framework, Schema\nfrom spoc.core.importer import Importer\n\n# Pattern-based hooks\ndef warmup_all_services(components: Set[Any]) -&gt; None:\n    \"\"\"Warmup hook for all service modules.\"\"\"\n    print(f\"\\n[Pattern Hook] Warming up {len(components)} services\")\n    for component in components:\n        if hasattr(component, 'warmup'):\n            component.warmup()\n\ndef cleanup_all_services(components: Set[Any]) -&gt; None:\n    \"\"\"Cleanup hook for all service modules.\"\"\"\n    print(f\"\\n[Pattern Hook] Cleaning up {len(components)} services\")\n    for component in components:\n        if hasattr(component, 'cleanup'):\n            component.cleanup()\n\n# Register pattern hooks before framework creation\nImporter.register_hook(\n    pattern=\"*.services\",\n    on_startup=warmup_all_services,\n    on_shutdown=cleanup_all_services,\n)\n\n# Schema hooks\ndef on_models_startup(module: ModuleType) -&gt; None:\n    \"\"\"Schema hook for models modules.\"\"\"\n    print(f\"[Schema Hook] Models module loaded: {module.__name__}\")\n\ndef on_models_shutdown(module: ModuleType) -&gt; None:\n    \"\"\"Schema hook for models modules.\"\"\"\n    print(f\"[Schema Hook] Models module unloading: {module.__name__}\")\n\n# Create schema with hooks\nschema = Schema(\n    modules=[\"models\", \"services\", \"views\"],\n    dependencies={\n        \"services\": [\"models\"],\n        \"views\": [\"models\", \"services\"],\n    },\n    hooks={\n        \"models\": {\n            \"startup\": on_models_startup,\n            \"shutdown\": on_models_shutdown,\n        },\n    },\n)\n\n# Create framework\nframework = Framework(\n    base_dir=Path(__file__).parent,\n    schema=schema,\n    echo=False,\n    mode=\"strict\",\n)\n\ndef main():\n    \"\"\"Application entry point.\"\"\"\n    print(\"\\n\" + \"=\"*60)\n    print(\"Application Running\")\n    print(\"=\"*60)\n\n    # Use framework components\n    print(f\"\\nInstalled apps: {framework.installed_apps}\")\n    print(f\"\\nComponent types: {list(framework.components.__dict__.keys())}\")\n\n    # Simulate application work\n    print(\"\\n(Application logic would run here...)\")\n\n    # Shutdown\n    print(\"\\n\" + \"=\"*60)\n    print(\"Shutting Down\")\n    print(\"=\"*60)\n    framework.shutdown()\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <pre><code># apps/blog/models.py\n\"\"\"\nBlog models with database connection lifecycle.\n\"\"\"\nimport sqlite3\nfrom typing import Optional\n\n# Module-level database connection\n_db: Optional[sqlite3.Connection] = None\n\ndef initialize():\n    \"\"\"\n    Module-level initialization hook.\n    Called automatically by SPOC during startup.\n    \"\"\"\n    global _db\n    print(f\"[Module Hook] Initializing blog.models\")\n    print(\"  - Connecting to database...\")\n    _db = sqlite3.connect(\"blog.db\")\n    _db.execute(\"\"\"\n        CREATE TABLE IF NOT EXISTS posts (\n            id INTEGER PRIMARY KEY,\n            title TEXT NOT NULL\n        )\n    \"\"\")\n    _db.commit()\n    print(\"  - Database ready!\")\n\ndef teardown():\n    \"\"\"\n    Module-level teardown hook.\n    Called automatically by SPOC during shutdown.\n    \"\"\"\n    global _db\n    print(f\"[Module Hook] Tearing down blog.models\")\n    if _db:\n        print(\"  - Closing database connection...\")\n        _db.close()\n        _db = None\n\ndef get_db() -&gt; sqlite3.Connection:\n    \"\"\"Get the database connection.\"\"\"\n    if _db is None:\n        raise RuntimeError(\"Database not initialized\")\n    return _db\n\nclass Post:\n    \"\"\"Blog post model.\"\"\"\n\n    @staticmethod\n    def create(title: str) -&gt; int:\n        db = get_db()\n        cursor = db.execute(\"INSERT INTO posts (title) VALUES (?)\", (title,))\n        db.commit()\n        return cursor.lastrowid\n</code></pre> <pre><code># apps/blog/services.py\n\"\"\"\nBlog services with cache warmup lifecycle.\n\"\"\"\nfrom typing import Dict, Optional\nfrom spoc import Components\n\ncomponents = Components()\ncomponents.add_type(\"service\")\n\n@components.register(\"service\")\nclass BlogService:\n    \"\"\"Blog service with caching.\"\"\"\n\n    _cache: Dict[str, any] = {}\n\n    @classmethod\n    def warmup(cls):\n        \"\"\"Called by pattern hook during startup.\"\"\"\n        print(\"[Component Hook] BlogService warming up\")\n        print(\"  - Loading popular posts into cache...\")\n        cls._cache['popular_posts'] = [\"Post 1\", \"Post 2\", \"Post 3\"]\n\n    @classmethod\n    def cleanup(cls):\n        \"\"\"Called by pattern hook during shutdown.\"\"\"\n        print(\"[Component Hook] BlogService cleaning up\")\n        print(\"  - Flushing cache...\")\n        cls._cache.clear()\n\n    @classmethod\n    def get_popular_posts(cls):\n        return cls._cache.get('popular_posts', [])\n</code></pre> <p>Expected Output:</p> <pre><code>apps_path C:\\path\\to\\project\\apps\n[Schema Hook] Models module loaded: blog.models\n[Module Hook] Initializing blog.models\n  - Connecting to database...\n  - Database ready!\n\n[Pattern Hook] Warming up 1 services\n[Component Hook] BlogService warming up\n  - Loading popular posts into cache...\n\n============================================================\nApplication Running\n============================================================\n\nInstalled apps: ['blog']\n\nComponent types: ['models', 'services', 'views']\n\n(Application logic would run here...)\n\n============================================================\nShutting Down\n============================================================\n\n[Component Hook] BlogService cleaning up\n  - Flushing cache...\n\n[Pattern Hook] Cleaning up 1 services\n\n[Module Hook] Tearing down blog.models\n  - Closing database connection...\n[Schema Hook] Models module unloading: blog.models\n</code></pre>"},{"location":"advanced/lifecycle/#summary","title":"Summary","text":"<p>You've learned how to:</p> <ul> <li>Understand the full framework lifecycle from instantiation to shutdown</li> <li>Implement module-level <code>initialize()</code> and <code>teardown()</code> functions</li> <li>Define schema-level hooks for centralized lifecycle management</li> <li>Register pattern-based hooks using <code>Importer.register_hook()</code></li> <li>Control hook execution order through dependency management</li> <li>Handle errors gracefully in lifecycle hooks</li> <li>Apply lifecycle patterns for databases, caches, APIs, and workers</li> </ul> <p>Key Takeaways:</p> <ol> <li>Three hook levels: Module functions, schema hooks, and pattern hooks</li> <li>Execution order: Hooks run in dependency order on startup, reverse on shutdown</li> <li>Error handling: Lifecycle errors halt the process - handle them carefully</li> <li>Practical patterns: Use lifecycle hooks for resource management and initialization</li> </ol> <p>Continue with Workers to learn how to manage background tasks with lifecycle-aware workers.</p>"},{"location":"advanced/plugins/","title":"Plugin System","text":"<p>SPOC's plugin system provides a powerful mechanism for extending application functionality at runtime. Plugins allow you to inject custom behavior, middleware, hooks, and other extensible components into your framework without modifying core application code.</p>"},{"location":"advanced/plugins/#what-are-plugins","title":"What are Plugins?","text":"<p>Plugins in SPOC are:</p> <ul> <li>Runtime-loaded modules - Loaded dynamically when the framework starts</li> <li>Organized by groups - Categorized by function (middleware, hooks, database, etc.)</li> <li>Configurable - Defined in both TOML and Python settings</li> <li>URI-based - Referenced using dot-notation paths like <code>myapp.middleware.auth</code></li> <li>Ordered - Loaded and executed in the sequence they're defined</li> </ul> <p>Unlike components which are discovered through decorator scanning, plugins are explicitly configured and loaded via URIs pointing to specific functions, classes, or modules.</p>"},{"location":"advanced/plugins/#plugin-configuration","title":"Plugin Configuration","text":"<p>SPOC supports two ways to configure plugins: TOML-based configuration in <code>spoc.toml</code> and Python-based configuration in <code>settings.py</code>. Both methods can be used together, with plugins from both sources being merged.</p>"},{"location":"advanced/plugins/#toml-configuration","title":"TOML Configuration","text":"<p>Define plugins in <code>config/spoc.toml</code> or <code>spoc.toml</code>:</p> <pre><code>[spoc]\nmode = \"development\"\ndebug = true\n\n# Plugin groups organized by function\n[spoc.plugins]\n# Middleware plugins (request/response processing)\nmiddleware = [\n    \"myapp.middleware.auth\",\n    \"myapp.middleware.logging\",\n    \"myapp.middleware.cors\"\n]\n\n# Lifecycle hooks\nhooks = [\n    \"myapp.hooks.startup\",\n    \"myapp.hooks.shutdown\"\n]\n\n# Database backends\ndatabase = [\n    \"db.backends.postgresql\",\n    \"db.backends.redis\"\n]\n\n# Cache backends\ncache = [\n    \"cache.backends.memory\",\n    \"cache.backends.redis\"\n]\n\n# Custom plugin groups\nvalidators = [\n    \"myapp.validators.email\",\n    \"myapp.validators.phone\"\n]\n</code></pre> <p>Key points:</p> <ul> <li>Plugins are organized under <code>[spoc.plugins]</code></li> <li>Each group name is arbitrary (you define the groups)</li> <li>Plugin URIs must point to importable Python objects</li> <li>Plugins are loaded in the order listed</li> </ul>"},{"location":"advanced/plugins/#python-configuration","title":"Python Configuration","text":"<p>Define plugins in <code>config/settings.py</code>:</p> <pre><code>\"\"\"Application Settings\"\"\"\n\nfrom pathlib import Path\n\nBASE_DIR: Path = Path(__file__).resolve().parent.parent\n\n# Apps\nINSTALLED_APPS: list = [\n    \"core\",\n    \"auth\",\n    \"api\",\n]\n\n# Plugins organized by group\nPLUGINS: dict = {\n    \"middleware\": [\n        \"core.middleware.request_id\",\n        \"core.middleware.timing\",\n        \"auth.middleware.authentication\",\n    ],\n\n    \"hooks\": [\n        \"core.hooks.database_connect\",\n        \"core.hooks.cache_warmup\",\n    ],\n\n    \"database\": [\n        \"db.backends.sqlite3\",\n    ],\n\n    \"validators\": [\n        \"core.validators.required\",\n        \"core.validators.email\",\n    ],\n}\n\n# Other settings...\nDEBUG = True\n</code></pre> <p>Key points:</p> <ul> <li><code>PLUGINS</code> must be a dictionary</li> <li>Keys are group names (strings)</li> <li>Values are lists of URI strings</li> <li>Plugins from settings.py merge with plugins from spoc.toml</li> </ul>"},{"location":"advanced/plugins/#configuration-merging","title":"Configuration Merging","text":"<p>When both TOML and Python configurations define plugins, they are merged:</p> <p>config/spoc.toml: <pre><code>[spoc.plugins]\nmiddleware = [\"myapp.middleware.cors\"]\nhooks = [\"myapp.hooks.startup\"]\n</code></pre></p> <p>config/settings.py: <pre><code>PLUGINS: dict = {\n    \"middleware\": [\"myapp.middleware.auth\"],\n    \"database\": [\"db.backends.postgres\"],\n}\n</code></pre></p> <p>Resulting merged plugins: <pre><code>{\n    \"middleware\": [\n        \"myapp.middleware.cors\",      # From TOML\n        \"myapp.middleware.auth\",      # From settings.py\n    ],\n    \"hooks\": [\n        \"myapp.hooks.startup\",        # From TOML\n    ],\n    \"database\": [\n        \"db.backends.postgres\",       # From settings.py\n    ],\n}\n</code></pre></p>"},{"location":"advanced/plugins/#how-framework-loads-plugins","title":"How Framework Loads Plugins","text":"<p>The Framework loads plugins automatically during initialization:</p>"},{"location":"advanced/plugins/#loading-process","title":"Loading Process","text":"<ol> <li>Configuration Loading - Framework reads spoc.toml and settings.py</li> <li>Plugin Collection - <code>_collect_plugins()</code> merges plugins from both sources</li> <li>URI Resolution - Each URI is resolved using <code>importer.load_from_uri()</code></li> <li>Group Organization - Plugins are organized in an OrderedDict by group</li> <li>Storage - Plugins are stored in <code>framework.plugins</code></li> </ol>"},{"location":"advanced/plugins/#internal-implementation","title":"Internal Implementation","text":"<pre><code># From framework.py\ndef _collect_plugins(self) -&gt; Dict[str, OrderedDict[str, Any]]:\n    \"\"\"Collect and load all configured plugins.\"\"\"\n    plugins = self.config.project.get(\"plugins\", {})\n    plug_dict: Dict[str, OrderedDict[str, Any]] = {}\n\n    # Merge plugins from settings.PLUGINS\n    for group, mods in self.config.settings.PLUGINS.items():\n        if group not in plugins:\n            plugins[group] = []\n        plugins[group].extend(mods)\n\n    # Load each plugin via URI\n    if plugins:\n        for group, modules in plugins.items():\n            if group not in plug_dict:\n                plug_dict[group] = OrderedDict()\n            for mod_uri in modules:\n                if mod_uri not in plug_dict[group]:\n                    plug_dict[group][mod_uri] = self.importer.load_from_uri(mod_uri)\n\n    return plug_dict\n</code></pre>"},{"location":"advanced/plugins/#what-gets-loaded","title":"What Gets Loaded","text":"<p>When you specify a plugin URI like <code>myapp.middleware.auth</code>, the framework:</p> <ol> <li>Splits the URI into module path and attribute: <code>myapp.middleware</code> + <code>auth</code></li> <li>Imports the module: <code>importlib.import_module(\"myapp.middleware\")</code></li> <li>Gets the attribute: <code>getattr(module, \"auth\")</code></li> <li>Returns the object (function, class, or module)</li> </ol> <p>This means the plugin can be:</p> <ul> <li>A function</li> <li>A class</li> <li>A class instance</li> <li>A module</li> <li>Any Python object</li> </ul>"},{"location":"advanced/plugins/#accessing-plugins","title":"Accessing Plugins","text":"<p>Once the framework is initialized, access plugins through <code>framework.plugins</code>:</p>"},{"location":"advanced/plugins/#basic-access","title":"Basic Access","text":"<pre><code>from pathlib import Path\nfrom spoc.framework import Framework, Schema\n\n# Initialize framework\nschema = Schema(modules=[\"models\", \"views\"])\nframework = Framework(base_dir=Path(\".\"), schema=schema)\n\n# Access plugin groups\nmiddleware_plugins = framework.plugins.get(\"middleware\", {})\nhook_plugins = framework.plugins.get(\"hooks\", {})\ndatabase_plugins = framework.plugins.get(\"database\", {})\n\n# Plugins are stored as OrderedDict[uri, loaded_object]\nfor uri, plugin_obj in middleware_plugins.items():\n    print(f\"Plugin: {uri} -&gt; {plugin_obj}\")\n</code></pre>"},{"location":"advanced/plugins/#iterating-plugins-by-group","title":"Iterating Plugins by Group","text":"<pre><code># Get all middleware plugins\nif \"middleware\" in framework.plugins:\n    for uri, middleware_func in framework.plugins[\"middleware\"].items():\n        print(f\"Loaded middleware: {uri}\")\n        # Use the middleware function\n        middleware_func()\n\n# Get all database backends\nif \"database\" in framework.plugins:\n    for uri, backend_class in framework.plugins[\"database\"].items():\n        print(f\"Database backend: {uri}\")\n        # Instantiate the backend\n        backend = backend_class()\n</code></pre>"},{"location":"advanced/plugins/#using-plugin-data","title":"Using Plugin Data","text":"<pre><code># Example: Execute all startup hooks\ndef execute_startup_hooks(framework):\n    \"\"\"Run all registered startup hooks.\"\"\"\n    if \"hooks\" not in framework.plugins:\n        return\n\n    for uri, hook_func in framework.plugins[\"hooks\"].items():\n        try:\n            print(f\"Executing startup hook: {uri}\")\n            hook_func()\n        except Exception as e:\n            print(f\"Hook {uri} failed: {e}\")\n\n# Example: Initialize database connections\ndef initialize_databases(framework):\n    \"\"\"Initialize all database backends.\"\"\"\n    if \"database\" not in framework.plugins:\n        return\n\n    connections = {}\n    for uri, backend_class in framework.plugins[\"database\"].items():\n        backend = backend_class()\n        connections[uri] = backend.connect()\n\n    return connections\n</code></pre>"},{"location":"advanced/plugins/#creating-plugin-packages","title":"Creating Plugin Packages","text":""},{"location":"advanced/plugins/#simple-function-plugin","title":"Simple Function Plugin","text":"<p>The simplest plugin is a function:</p> <p>myapp/middleware/logging.py: <pre><code>\"\"\"Logging middleware plugin.\"\"\"\n\nimport logging\nfrom datetime import datetime\n\nlogger = logging.getLogger(__name__)\n\ndef log_request(request):\n    \"\"\"Log incoming requests.\"\"\"\n    timestamp = datetime.now().isoformat()\n    logger.info(f\"[{timestamp}] {request.method} {request.path}\")\n    return request\n</code></pre></p> <p>Configuration: <pre><code>[spoc.plugins]\nmiddleware = [\"myapp.middleware.logging.log_request\"]\n</code></pre></p>"},{"location":"advanced/plugins/#class-based-plugin","title":"Class-Based Plugin","text":"<p>For stateful plugins, use classes:</p> <p>myapp/database/postgres.py: <pre><code>\"\"\"PostgreSQL database plugin.\"\"\"\n\nimport psycopg2\nfrom typing import Any, Dict\n\nclass PostgreSQLBackend:\n    \"\"\"PostgreSQL database backend.\"\"\"\n\n    def __init__(self):\n        self.connection = None\n        self.config = {}\n\n    def configure(self, **kwargs):\n        \"\"\"Configure the backend.\"\"\"\n        self.config = kwargs\n        return self\n\n    def connect(self):\n        \"\"\"Establish database connection.\"\"\"\n        self.connection = psycopg2.connect(**self.config)\n        return self.connection\n\n    def disconnect(self):\n        \"\"\"Close database connection.\"\"\"\n        if self.connection:\n            self.connection.close()\n            self.connection = None\n\n    def execute(self, query: str) -&gt; Any:\n        \"\"\"Execute a query.\"\"\"\n        cursor = self.connection.cursor()\n        cursor.execute(query)\n        return cursor.fetchall()\n</code></pre></p> <p>Configuration: <pre><code>[spoc.plugins]\ndatabase = [\"myapp.database.postgres.PostgreSQLBackend\"]\n</code></pre></p> <p>Usage: <pre><code># Access the backend class\nbackend_class = framework.plugins[\"database\"][\"myapp.database.postgres.PostgreSQLBackend\"]\n\n# Instantiate and configure\nbackend = backend_class()\nbackend.configure(\n    host=\"localhost\",\n    database=\"myapp\",\n    user=\"postgres\",\n    password=\"secret\"\n)\n\n# Connect and use\nconnection = backend.connect()\nresults = backend.execute(\"SELECT * FROM users\")\n</code></pre></p>"},{"location":"advanced/plugins/#plugin-with-configuration","title":"Plugin with Configuration","text":"<p>Create plugins that read configuration from settings:</p> <p>myapp/cache/redis_backend.py: <pre><code>\"\"\"Redis cache backend plugin.\"\"\"\n\nimport redis\nfrom typing import Any, Optional\n\nclass RedisCacheBackend:\n    \"\"\"Redis-based cache backend.\"\"\"\n\n    def __init__(self, framework=None):\n        \"\"\"\n        Initialize Redis backend.\n\n        Args:\n            framework: Optional framework instance for config access\n        \"\"\"\n        self.framework = framework\n        self.client = None\n\n        # Load config from framework if available\n        if framework:\n            redis_config = framework.config.settings.REDIS_CONFIG\n            self.configure(**redis_config)\n\n    def configure(self, host=\"localhost\", port=6379, db=0, **kwargs):\n        \"\"\"Configure Redis connection.\"\"\"\n        self.client = redis.Redis(\n            host=host,\n            port=port,\n            db=db,\n            decode_responses=True,\n            **kwargs\n        )\n\n    def get(self, key: str) -&gt; Optional[str]:\n        \"\"\"Get value from cache.\"\"\"\n        return self.client.get(key)\n\n    def set(self, key: str, value: str, ttl: int = 3600):\n        \"\"\"Set value in cache.\"\"\"\n        self.client.setex(key, ttl, value)\n\n    def delete(self, key: str):\n        \"\"\"Delete key from cache.\"\"\"\n        self.client.delete(key)\n</code></pre></p> <p>config/settings.py: <pre><code># Redis configuration\nREDIS_CONFIG = {\n    \"host\": \"localhost\",\n    \"port\": 6379,\n    \"db\": 0,\n    \"max_connections\": 10,\n}\n\nPLUGINS = {\n    \"cache\": [\"myapp.cache.redis_backend.RedisCacheBackend\"],\n}\n</code></pre></p>"},{"location":"advanced/plugins/#plugin-factory-pattern","title":"Plugin Factory Pattern","text":"<p>For complex initialization, use factory functions:</p> <p>myapp/plugins/validators.py: <pre><code>\"\"\"Validator plugins using factory pattern.\"\"\"\n\nfrom typing import Callable, Any\nimport re\n\ndef create_email_validator(domain_whitelist=None) -&gt; Callable:\n    \"\"\"\n    Create an email validator with optional domain whitelist.\n\n    Args:\n        domain_whitelist: List of allowed domains (e.g., ['example.com'])\n\n    Returns:\n        Validator function\n    \"\"\"\n    email_pattern = re.compile(r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$')\n\n    def validate_email(email: str) -&gt; bool:\n        \"\"\"Validate email address.\"\"\"\n        if not email_pattern.match(email):\n            return False\n\n        if domain_whitelist:\n            domain = email.split('@')[1]\n            return domain in domain_whitelist\n\n        return True\n\n    return validate_email\n\ndef create_phone_validator(country_code=\"+1\") -&gt; Callable:\n    \"\"\"\n    Create a phone number validator for a specific country.\n\n    Args:\n        country_code: Country code prefix\n\n    Returns:\n        Validator function\n    \"\"\"\n    def validate_phone(phone: str) -&gt; bool:\n        \"\"\"Validate phone number.\"\"\"\n        if not phone.startswith(country_code):\n            return False\n\n        # Remove country code and check length\n        number = phone[len(country_code):].replace(\"-\", \"\").replace(\" \", \"\")\n        return number.isdigit() and len(number) == 10\n\n    return validate_phone\n</code></pre></p> <p>Usage: <pre><code># In your application code\nfrom myapp.plugins.validators import create_email_validator, create_phone_validator\n\n# Create configured validators\nemail_validator = create_email_validator(domain_whitelist=['company.com'])\nphone_validator = create_phone_validator(country_code=\"+1\")\n\n# Use them\nis_valid_email = email_validator(\"user@company.com\")  # True\nis_valid_email = email_validator(\"user@other.com\")    # False\n\nis_valid_phone = phone_validator(\"+1-555-123-4567\")  # True\n</code></pre></p>"},{"location":"advanced/plugins/#plugin-discovery-patterns","title":"Plugin Discovery Patterns","text":""},{"location":"advanced/plugins/#module-level-plugins","title":"Module-Level Plugins","text":"<p>Export plugins from module <code>__init__.py</code>:</p> <p>myapp/middleware/init.py: <pre><code>\"\"\"Middleware plugins.\"\"\"\n\nfrom .auth import authenticate\nfrom .logging import log_request\nfrom .cors import handle_cors\n\n# Export all middleware\n__all__ = [\"authenticate\", \"log_request\", \"handle_cors\"]\n</code></pre></p> <p>Configuration: <pre><code>[spoc.plugins]\nmiddleware = [\n    \"myapp.middleware.authenticate\",\n    \"myapp.middleware.log_request\",\n    \"myapp.middleware.handle_cors\",\n]\n</code></pre></p>"},{"location":"advanced/plugins/#plugin-registry-pattern","title":"Plugin Registry Pattern","text":"<p>Create a registry for automatic plugin discovery:</p> <p>myapp/plugins/registry.py: <pre><code>\"\"\"Plugin registry system.\"\"\"\n\nfrom typing import Dict, List, Any, Callable\n\nclass PluginRegistry:\n    \"\"\"Central registry for plugins.\"\"\"\n\n    def __init__(self):\n        self._plugins: Dict[str, List[Any]] = {}\n\n    def register(self, group: str):\n        \"\"\"Decorator to register a plugin.\"\"\"\n        def decorator(plugin_obj):\n            if group not in self._plugins:\n                self._plugins[group] = []\n            self._plugins[group].append(plugin_obj)\n            return plugin_obj\n        return decorator\n\n    def get_plugins(self, group: str) -&gt; List[Any]:\n        \"\"\"Get all plugins in a group.\"\"\"\n        return self._plugins.get(group, [])\n\n    def execute_all(self, group: str, *args, **kwargs):\n        \"\"\"Execute all plugins in a group.\"\"\"\n        results = []\n        for plugin in self.get_plugins(group):\n            if callable(plugin):\n                results.append(plugin(*args, **kwargs))\n        return results\n\n# Global registry instance\nregistry = PluginRegistry()\n</code></pre></p> <p>myapp/middleware/auth.py: <pre><code>\"\"\"Authentication middleware.\"\"\"\n\nfrom myapp.plugins.registry import registry\n\n@registry.register(\"middleware\")\ndef authenticate(request):\n    \"\"\"Authenticate incoming requests.\"\"\"\n    # Authentication logic\n    token = request.headers.get(\"Authorization\")\n    if not token:\n        raise ValueError(\"Missing authentication token\")\n    return request\n\n@registry.register(\"middleware\")\ndef authorize(request):\n    \"\"\"Check user permissions.\"\"\"\n    # Authorization logic\n    user = request.user\n    if not user.has_permission(\"access_api\"):\n        raise PermissionError(\"User lacks required permissions\")\n    return request\n</code></pre></p> <p>Usage in application: <pre><code>from myapp.plugins.registry import registry\n\n# Get all middleware plugins\nmiddleware_plugins = registry.get_plugins(\"middleware\")\n\n# Execute all middleware on a request\nfor middleware in middleware_plugins:\n    request = middleware(request)\n</code></pre></p>"},{"location":"advanced/plugins/#dynamic-plugin-loading","title":"Dynamic Plugin Loading","text":"<p>Load plugins dynamically based on configuration:</p> <p>myapp/plugins/loader.py: <pre><code>\"\"\"Dynamic plugin loader.\"\"\"\n\nfrom pathlib import Path\nimport importlib\nfrom typing import Any, Dict, List\n\nclass PluginLoader:\n    \"\"\"Load plugins dynamically from configuration.\"\"\"\n\n    def __init__(self, framework):\n        self.framework = framework\n        self.loaded_plugins: Dict[str, Any] = {}\n\n    def load_plugin(self, uri: str) -&gt; Any:\n        \"\"\"Load a single plugin from URI.\"\"\"\n        if uri in self.loaded_plugins:\n            return self.loaded_plugins[uri]\n\n        # Use framework's importer\n        plugin = self.framework.importer.load_from_uri(uri)\n        self.loaded_plugins[uri] = plugin\n        return plugin\n\n    def load_group(self, group: str) -&gt; List[Any]:\n        \"\"\"Load all plugins in a group.\"\"\"\n        plugins = []\n\n        if group in self.framework.plugins:\n            for uri, plugin_obj in self.framework.plugins[group].items():\n                plugins.append(plugin_obj)\n\n        return plugins\n\n    def initialize_plugin(self, plugin: Any, config: Dict[str, Any]):\n        \"\"\"Initialize a plugin with configuration.\"\"\"\n        if hasattr(plugin, \"configure\"):\n            plugin.configure(**config)\n        elif hasattr(plugin, \"__init__\"):\n            # If it's a class, instantiate with config\n            if isinstance(plugin, type):\n                return plugin(**config)\n        return plugin\n</code></pre></p>"},{"location":"advanced/plugins/#best-practices","title":"Best Practices","text":""},{"location":"advanced/plugins/#1-use-descriptive-group-names","title":"1. Use Descriptive Group Names","text":"<p>Organize plugins by function with clear group names:</p> <pre><code>[spoc.plugins]\n# Good: Clear, descriptive names\nmiddleware = [...]\nrequest_validators = [...]\nresponse_formatters = [...]\nbackground_tasks = [...]\n\n# Avoid: Vague names\nstuff = [...]\nthings = [...]\nmisc = [...]\n</code></pre>"},{"location":"advanced/plugins/#2-document-plugin-interfaces","title":"2. Document Plugin Interfaces","text":"<p>Clearly document what each plugin expects:</p> <pre><code>\"\"\"Email notification plugin.\n\nExpected Interface:\n    - Must be callable with signature: notify(recipient: str, message: str)\n    - Should return True on success, False on failure\n    - May raise NotificationError on fatal errors\n\nConfiguration:\n    Set EMAIL_CONFIG in settings.py:\n    EMAIL_CONFIG = {\n        \"smtp_host\": \"smtp.example.com\",\n        \"smtp_port\": 587,\n        \"username\": \"user@example.com\",\n        \"password\": \"secret\",\n    }\n\"\"\"\n\nfrom typing import Protocol\n\nclass NotificationPlugin(Protocol):\n    \"\"\"Protocol for notification plugins.\"\"\"\n\n    def notify(self, recipient: str, message: str) -&gt; bool:\n        \"\"\"Send a notification.\"\"\"\n        ...\n</code></pre>"},{"location":"advanced/plugins/#3-handle-plugin-failures-gracefully","title":"3. Handle Plugin Failures Gracefully","text":"<p>Plugins should not crash the application:</p> <pre><code>def load_plugins_safely(framework, group: str):\n    \"\"\"Load plugins with error handling.\"\"\"\n    loaded = []\n\n    if group not in framework.plugins:\n        return loaded\n\n    for uri, plugin_obj in framework.plugins[group].items():\n        try:\n            # Initialize plugin\n            if isinstance(plugin_obj, type):\n                plugin_instance = plugin_obj()\n            else:\n                plugin_instance = plugin_obj\n\n            loaded.append(plugin_instance)\n            print(f\"Loaded plugin: {uri}\")\n\n        except Exception as e:\n            print(f\"Failed to load plugin {uri}: {e}\")\n            # Continue loading other plugins\n            continue\n\n    return loaded\n</code></pre>"},{"location":"advanced/plugins/#4-version-your-plugin-interfaces","title":"4. Version Your Plugin Interfaces","text":"<p>Use version markers for plugin compatibility:</p> <pre><code>\"\"\"Database plugin interface v2.\"\"\"\n\nfrom typing import Protocol, Any\n\nclass DatabasePluginV2(Protocol):\n    \"\"\"Database plugin interface version 2.\"\"\"\n\n    VERSION = \"2.0\"\n\n    def connect(self) -&gt; Any:\n        \"\"\"Establish connection.\"\"\"\n        ...\n\n    def disconnect(self) -&gt; None:\n        \"\"\"Close connection.\"\"\"\n        ...\n\n    def execute(self, query: str) -&gt; Any:\n        \"\"\"Execute query.\"\"\"\n        ...\n\n    def transaction(self):\n        \"\"\"Context manager for transactions.\"\"\"\n        ...\n</code></pre>"},{"location":"advanced/plugins/#5-separate-configuration-from-code","title":"5. Separate Configuration from Code","text":"<p>Keep plugin configuration in settings files:</p> <pre><code># config/settings.py\n\n# Plugin configurations\nCACHE_CONFIG = {\n    \"redis\": {\n        \"host\": \"localhost\",\n        \"port\": 6379,\n        \"db\": 0,\n    },\n    \"memory\": {\n        \"max_size\": 1000,\n    },\n}\n\nDATABASE_CONFIG = {\n    \"postgres\": {\n        \"host\": \"localhost\",\n        \"database\": \"myapp\",\n        \"user\": \"postgres\",\n    },\n}\n\n# Plugin URIs\nPLUGINS = {\n    \"cache\": [\"myapp.cache.redis.RedisBackend\"],\n    \"database\": [\"myapp.database.postgres.PostgresBackend\"],\n}\n</code></pre>"},{"location":"advanced/plugins/#6-test-plugins-independently","title":"6. Test Plugins Independently","text":"<p>Write unit tests for each plugin:</p> <pre><code>\"\"\"Tests for email notification plugin.\"\"\"\n\nimport pytest\nfrom myapp.plugins.notifications import EmailNotifier\n\ndef test_email_notifier_success():\n    \"\"\"Test successful email notification.\"\"\"\n    notifier = EmailNotifier()\n    notifier.configure(smtp_host=\"test.example.com\")\n\n    result = notifier.notify(\"user@example.com\", \"Test message\")\n    assert result is True\n\ndef test_email_notifier_invalid_recipient():\n    \"\"\"Test notification with invalid recipient.\"\"\"\n    notifier = EmailNotifier()\n\n    with pytest.raises(ValueError):\n        notifier.notify(\"invalid-email\", \"Test message\")\n</code></pre>"},{"location":"advanced/plugins/#7-provide-plugin-examples","title":"7. Provide Plugin Examples","text":"<p>Include example plugins in documentation:</p> <pre><code>\"\"\"Example middleware plugin.\n\nThis is a template for creating middleware plugins.\n\nUsage:\n    1. Copy this file to your app's middleware directory\n    2. Modify the process() function with your logic\n    3. Add to config/settings.py PLUGINS[\"middleware\"]\n\"\"\"\n\nclass ExampleMiddleware:\n    \"\"\"Example middleware plugin template.\"\"\"\n\n    def __init__(self):\n        self.enabled = True\n\n    def configure(self, **kwargs):\n        \"\"\"Configure the middleware.\"\"\"\n        self.enabled = kwargs.get(\"enabled\", True)\n        return self\n\n    def process(self, request):\n        \"\"\"\n        Process the request.\n\n        Args:\n            request: The incoming request object\n\n        Returns:\n            Modified request object\n        \"\"\"\n        if not self.enabled:\n            return request\n\n        # Your middleware logic here\n        print(f\"Processing request: {request}\")\n\n        return request\n</code></pre>"},{"location":"advanced/plugins/#8-document-plugin-dependencies","title":"8. Document Plugin Dependencies","text":"<p>List required packages for plugins:</p> <pre><code>\"\"\"Redis cache plugin.\n\nDependencies:\n    - redis&gt;=4.0.0\n\nInstallation:\n    pip install redis\n\nConfiguration:\n    REDIS_CONFIG = {\n        \"host\": \"localhost\",\n        \"port\": 6379,\n        \"db\": 0,\n    }\n\"\"\"\n\ntry:\n    import redis\nexcept ImportError:\n    raise ImportError(\n        \"Redis plugin requires 'redis' package. \"\n        \"Install it with: pip install redis\"\n    )\n</code></pre>"},{"location":"advanced/plugins/#complete-plugin-example","title":"Complete Plugin Example","text":"<p>Here's a complete example showing a plugin system for API rate limiting:</p>"},{"location":"advanced/plugins/#plugin-implementation","title":"Plugin Implementation","text":"<p>myapp/plugins/rate_limiter.py: <pre><code>\"\"\"Rate limiting plugin for API requests.\"\"\"\n\nfrom datetime import datetime, timedelta\nfrom typing import Dict, Optional\nimport hashlib\n\nclass RateLimiter:\n    \"\"\"Rate limiting plugin.\"\"\"\n\n    def __init__(self):\n        self.limits: Dict[str, dict] = {}\n        self.max_requests = 100\n        self.window_seconds = 3600\n\n    def configure(self, max_requests=100, window_seconds=3600):\n        \"\"\"Configure rate limits.\"\"\"\n        self.max_requests = max_requests\n        self.window_seconds = window_seconds\n        return self\n\n    def get_client_key(self, request) -&gt; str:\n        \"\"\"Generate unique key for client.\"\"\"\n        # Use IP address or API key\n        client_id = request.headers.get(\"X-API-Key\") or request.remote_addr\n        return hashlib.sha256(client_id.encode()).hexdigest()\n\n    def is_allowed(self, request) -&gt; bool:\n        \"\"\"Check if request is allowed.\"\"\"\n        key = self.get_client_key(request)\n        now = datetime.now()\n\n        # Initialize tracking for new clients\n        if key not in self.limits:\n            self.limits[key] = {\n                \"count\": 0,\n                \"window_start\": now,\n            }\n\n        # Reset window if expired\n        window_start = self.limits[key][\"window_start\"]\n        if now - window_start &gt; timedelta(seconds=self.window_seconds):\n            self.limits[key] = {\n                \"count\": 0,\n                \"window_start\": now,\n            }\n\n        # Check limit\n        if self.limits[key][\"count\"] &gt;= self.max_requests:\n            return False\n\n        # Increment counter\n        self.limits[key][\"count\"] += 1\n        return True\n\n    def get_limit_info(self, request) -&gt; dict:\n        \"\"\"Get current limit information for client.\"\"\"\n        key = self.get_client_key(request)\n\n        if key not in self.limits:\n            return {\n                \"remaining\": self.max_requests,\n                \"limit\": self.max_requests,\n                \"reset\": int((datetime.now() + timedelta(seconds=self.window_seconds)).timestamp()),\n            }\n\n        return {\n            \"remaining\": max(0, self.max_requests - self.limits[key][\"count\"]),\n            \"limit\": self.max_requests,\n            \"reset\": int((self.limits[key][\"window_start\"] + timedelta(seconds=self.window_seconds)).timestamp()),\n        }\n</code></pre></p>"},{"location":"advanced/plugins/#configuration","title":"Configuration","text":"<p>config/settings.py: <pre><code># Rate limiting configuration\nRATE_LIMIT_CONFIG = {\n    \"max_requests\": 1000,\n    \"window_seconds\": 3600,\n}\n\nPLUGINS = {\n    \"middleware\": [\"myapp.plugins.rate_limiter.RateLimiter\"],\n}\n</code></pre></p>"},{"location":"advanced/plugins/#usage-in-application","title":"Usage in Application","text":"<p>main.py: <pre><code>\"\"\"Main application with rate limiting.\"\"\"\n\nfrom pathlib import Path\nfrom spoc.framework import Framework, Schema\n\n# Initialize framework\nschema = Schema(modules=[\"models\", \"views\"])\nframework = Framework(base_dir=Path(\".\"), schema=schema)\n\n# Get rate limiter plugin\nrate_limiter_class = framework.plugins[\"middleware\"][\"myapp.plugins.rate_limiter.RateLimiter\"]\nrate_limiter = rate_limiter_class()\n\n# Configure from settings\nconfig = framework.config.settings.RATE_LIMIT_CONFIG\nrate_limiter.configure(**config)\n\n# Use in request handling\ndef handle_request(request):\n    \"\"\"Handle an API request with rate limiting.\"\"\"\n\n    # Check rate limit\n    if not rate_limiter.is_allowed(request):\n        limit_info = rate_limiter.get_limit_info(request)\n        return {\n            \"error\": \"Rate limit exceeded\",\n            \"limit\": limit_info[\"limit\"],\n            \"reset\": limit_info[\"reset\"],\n        }, 429\n\n    # Add rate limit headers to response\n    limit_info = rate_limiter.get_limit_info(request)\n    response_headers = {\n        \"X-RateLimit-Limit\": str(limit_info[\"limit\"]),\n        \"X-RateLimit-Remaining\": str(limit_info[\"remaining\"]),\n        \"X-RateLimit-Reset\": str(limit_info[\"reset\"]),\n    }\n\n    # Process request normally\n    result = process_api_request(request)\n\n    return result, 200, response_headers\n\ndef process_api_request(request):\n    \"\"\"Process the actual API request.\"\"\"\n    return {\"status\": \"success\", \"data\": {}}\n</code></pre></p>"},{"location":"advanced/plugins/#summary","title":"Summary","text":"<p>SPOC's plugin system provides:</p> <ul> <li>Flexible configuration via TOML and Python</li> <li>Runtime loading through URI-based references</li> <li>Group organization for logical categorization</li> <li>Easy access through <code>framework.plugins</code></li> <li>Extensibility without modifying core code</li> </ul> <p>Plugins are ideal for:</p> <ul> <li>Middleware and request processing</li> <li>Lifecycle hooks (startup/shutdown)</li> <li>Backend implementations (database, cache)</li> <li>Validators and formatters</li> <li>Cross-cutting concerns</li> </ul> <p>Follow best practices to create maintainable, testable, and well-documented plugins that extend your SPOC application's capabilities.</p>"},{"location":"advanced/plugins/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about Components for decorator-based registration</li> <li>Explore Framework API for plugin access patterns</li> <li>Check App System for application organization</li> <li>Review Configuration for settings management</li> </ul>"},{"location":"advanced/workers/","title":"Workers","text":"<p>Build robust background task systems with SPOC's worker framework. This guide covers everything from basic worker implementation to advanced concurrency patterns.</p>"},{"location":"advanced/workers/#what-are-workers","title":"What Are Workers?","text":"<p>Workers are background task executors that run concurrently with your main application. They provide a consistent interface for running tasks in threads or processes with unified lifecycle management, error handling, and signal management.</p> <p>Key Features:</p> <ul> <li>Unified API for thread and process-based concurrency</li> <li>Lifecycle management (setup, main, teardown)</li> <li>Built-in error handling and recovery</li> <li>Signal handling for graceful shutdowns</li> <li>Async/await support</li> <li>Multi-worker orchestration via Server</li> </ul>"},{"location":"advanced/workers/#when-to-use-workers","title":"When to Use Workers","text":"<p>Workers are ideal for several scenarios:</p>"},{"location":"advanced/workers/#background-tasks","title":"Background Tasks","text":"<p>Long-running operations that shouldn't block your main application:</p> <ul> <li>Message queue processing: Process jobs from Redis, RabbitMQ, or other queues</li> <li>Scheduled tasks: Run periodic cleanup, maintenance, or data synchronization</li> <li>Event monitoring: Watch file systems, databases, or external APIs for changes</li> </ul>"},{"location":"advanced/workers/#concurrent-operations","title":"Concurrent Operations","text":"<p>Tasks that benefit from parallel execution:</p> <ul> <li>Data processing: Transform large datasets using multiple cores</li> <li>API request handling: Service multiple HTTP requests simultaneously</li> <li>Real-time data ingestion: Handle streams from multiple sources</li> </ul>"},{"location":"advanced/workers/#resource-isolation","title":"Resource Isolation","text":"<p>Operations that need separate execution contexts:</p> <ul> <li>Memory-intensive tasks: Prevent memory leaks from affecting the main process</li> <li>Untrusted code execution: Isolate potentially problematic code in separate processes</li> <li>State management: Maintain independent state for different subsystems</li> </ul>"},{"location":"advanced/workers/#threadworker-vs-processworker","title":"ThreadWorker vs ProcessWorker","text":"<p>SPOC provides two worker types optimized for different workloads.</p>"},{"location":"advanced/workers/#threadworker","title":"ThreadWorker","text":"<p>Runs tasks in a separate thread within the same process.</p> <p>Best for:</p> <ul> <li>I/O-bound tasks (network requests, file operations, database queries)</li> <li>Tasks requiring shared memory with the main process</li> <li>Lightweight concurrency with low overhead</li> </ul> <p>Limitations:</p> <ul> <li>Subject to Python's Global Interpreter Lock (GIL)</li> <li>CPU-bound tasks won't achieve true parallelism</li> <li>Shared memory can lead to race conditions without proper synchronization</li> </ul> <p>Example - I/O Bound Task:</p> <pre><code>from spoc.workers import ThreadWorker\nimport time\n\nclass LogWatcher(ThreadWorker):\n    \"\"\"Watch a log file for new entries.\"\"\"\n\n    def setup(self):\n        \"\"\"Initialize the log file handle.\"\"\"\n        self.log_file = open(\"/var/log/app.log\", \"r\")\n        self.log_file.seek(0, 2)  # Move to end of file\n\n    def main(self):\n        \"\"\"Watch for new log lines.\"\"\"\n        while self.is_running:\n            line = self.log_file.readline()\n            if line:\n                self.process_log_line(line)\n            else:\n                time.sleep(0.1)  # Wait for new content\n\n    def teardown(self):\n        \"\"\"Close the log file.\"\"\"\n        self.log_file.close()\n\n    def process_log_line(self, line):\n        \"\"\"Process a single log line.\"\"\"\n        if \"ERROR\" in line:\n            print(f\"Error detected: {line.strip()}\")\n</code></pre>"},{"location":"advanced/workers/#processworker","title":"ProcessWorker","text":"<p>Runs tasks in a separate process with independent memory.</p> <p>Best for:</p> <ul> <li>CPU-bound tasks (data processing, calculations, compression)</li> <li>Tasks that need to bypass the GIL for true parallelism</li> <li>Operations requiring complete memory isolation</li> </ul> <p>Trade-offs:</p> <ul> <li>Higher overhead (separate Python interpreter)</li> <li>No shared memory (requires inter-process communication)</li> <li>More resource intensive</li> </ul> <p>Example - CPU Bound Task:</p> <pre><code>from spoc.workers import ProcessWorker\nimport hashlib\n\nclass HashCalculator(ProcessWorker):\n    \"\"\"Calculate hashes for files in a queue.\"\"\"\n\n    def setup(self):\n        \"\"\"Initialize worker state.\"\"\"\n        self.processed_count = 0\n\n    def main(self):\n        \"\"\"Process files from queue.\"\"\"\n        while self.is_running:\n            # Simulate getting file from queue\n            file_path = self.get_next_file()\n\n            if file_path:\n                self.calculate_hash(file_path)\n                self.processed_count += 1\n\n    def calculate_hash(self, file_path):\n        \"\"\"Calculate SHA-256 hash of a file.\"\"\"\n        sha256 = hashlib.sha256()\n        with open(file_path, \"rb\") as f:\n            for chunk in iter(lambda: f.read(4096), b\"\"):\n                sha256.update(chunk)\n        return sha256.hexdigest()\n\n    def get_next_file(self):\n        \"\"\"Get next file from queue (placeholder).\"\"\"\n        # In real implementation, get from shared queue\n        return None\n</code></pre>"},{"location":"advanced/workers/#quick-reference","title":"Quick Reference","text":"Feature ThreadWorker ProcessWorker Concurrency Threading Multiprocessing Memory Shared Isolated GIL Impact Yes No Overhead Low High Best For I/O-bound CPU-bound Startup Time Fast Slower Communication Direct IPC required"},{"location":"advanced/workers/#creating-custom-workers","title":"Creating Custom Workers","text":"<p>All workers inherit from <code>AbstractWorker</code> and implement three lifecycle methods.</p>"},{"location":"advanced/workers/#basic-worker-structure","title":"Basic Worker Structure","text":"<pre><code>from spoc.workers import ThreadWorker\n\nclass MyWorker(ThreadWorker):\n    \"\"\"Custom worker implementation.\"\"\"\n\n    def setup(self):\n        \"\"\"\n        Called once before main() starts.\n\n        Use for:\n        - Opening file handles or database connections\n        - Initializing state variables\n        - Setting up resources\n        \"\"\"\n        self.context.connection = self.create_connection()\n        self.counter = 0\n\n    def main(self):\n        \"\"\"\n        Main worker loop.\n\n        Runs until self.is_running becomes False.\n        Should check is_running regularly to allow graceful shutdown.\n        \"\"\"\n        while self.is_running:\n            # Do work here\n            self.counter += 1\n            time.sleep(1)\n\n    def teardown(self):\n        \"\"\"\n        Called once after main() completes.\n\n        Use for:\n        - Closing file handles or database connections\n        - Saving state\n        - Cleanup operations\n        \"\"\"\n        self.context.connection.close()\n        print(f\"Processed {self.counter} items\")\n</code></pre>"},{"location":"advanced/workers/#the-worker-lifecycle","title":"The Worker Lifecycle","text":"<pre><code>sequenceDiagram\n    participant User\n    participant Worker\n    participant Lifecycle\n\n    User-&gt;&gt;Worker: start()\n    Worker-&gt;&gt;Lifecycle: emit \"startup\" event\n    Worker-&gt;&gt;Worker: setup()\n    Worker-&gt;&gt;Worker: main()\n\n    Note over Worker: Worker runs...\n\n    User-&gt;&gt;Worker: stop()\n    Worker-&gt;&gt;Worker: Exit main()\n    Worker-&gt;&gt;Worker: teardown()\n    Worker-&gt;&gt;Lifecycle: emit \"shutdown\" event</code></pre>"},{"location":"advanced/workers/#lifecycle-events","title":"Lifecycle Events","text":"<p>Workers emit lifecycle events that you can handle:</p> <pre><code>from spoc.workers import ThreadWorker\n\nclass MonitoredWorker(ThreadWorker):\n    \"\"\"Worker with lifecycle event handling.\"\"\"\n\n    def lifecycle(self, event_type, **data):\n        \"\"\"\n        Handle lifecycle events.\n\n        Args:\n            event_type: Type of event (\"startup\", \"shutdown\", \"error\")\n            **data: Additional event data (e.g., exception for errors)\n        \"\"\"\n        match event_type:\n            case \"startup\":\n                print(f\"{self.name} is starting up\")\n                self.context.start_time = time.time()\n\n            case \"shutdown\":\n                elapsed = time.time() - self.context.start_time\n                print(f\"{self.name} ran for {elapsed:.2f} seconds\")\n\n            case \"error\":\n                exception = data.get(\"exception\")\n                print(f\"{self.name} error: {exception}\")\n                # Log to monitoring system, send alerts, etc.\n\n    def main(self):\n        \"\"\"Worker main loop.\"\"\"\n        while self.is_running:\n            # Do work\n            time.sleep(1)\n</code></pre> <p>Available Events:</p> <ul> <li><code>\"startup\"</code> - Worker has started, setup() completed</li> <li><code>\"shutdown\"</code> - Worker is shutting down, teardown() completed</li> <li><code>\"error\"</code> - An exception occurred during execution (includes <code>exception</code> in data)</li> </ul>"},{"location":"advanced/workers/#the-server-class","title":"The Server Class","text":"<p>The <code>Server</code> manages multiple workers as a cohesive unit, handling startup, shutdown, and signal management.</p>"},{"location":"advanced/workers/#basic-server-usage","title":"Basic Server Usage","text":"<pre><code>from spoc.workers import Server, ThreadWorker, ProcessWorker\n\nclass Worker1(ThreadWorker):\n    def main(self):\n        while self.is_running:\n            print(f\"{self.name} working...\")\n            time.sleep(1)\n\nclass Worker2(ProcessWorker):\n    def main(self):\n        while self.is_running:\n            print(f\"{self.name} processing...\")\n            time.sleep(1)\n\n# Create server\nserver = Server(name=\"MyAppServer\")\n\n# Add workers\nserver.add_worker(Worker1(name=\"ThreadWorker-1\"))\nserver.add_worker(Worker2(name=\"ProcessWorker-1\"))\n\n# Start all workers and run until interrupted\nserver.run_forever()\n</code></pre>"},{"location":"advanced/workers/#server-methods","title":"Server Methods","text":"<pre><code># Create a server\nserver = Server(name=\"MyServer\")\n\n# Add workers\nserver.add_worker(worker1)\nserver.add_worker(worker2)\n\n# Start all workers\nserver.start()\n\n# Stop all workers\nserver.stop()\n\n# Wait for all workers to finish\nserver.join_all(timeout=5.0)\n\n# Run until interrupted (combines start, wait, stop, join)\nserver.run_forever()\n</code></pre>"},{"location":"advanced/workers/#run_forever-and-signal-handling","title":"run_forever() and Signal Handling","text":"<p>The <code>run_forever()</code> method provides automatic signal handling for graceful shutdowns.</p> <pre><code>from spoc.workers import Server, ThreadWorker\nimport signal\n\nclass GracefulWorker(ThreadWorker):\n    def setup(self):\n        \"\"\"Initialize state.\"\"\"\n        self.items_processed = 0\n\n    def main(self):\n        \"\"\"Process items until stopped.\"\"\"\n        while self.is_running:\n            # Simulate processing\n            self.items_processed += 1\n            time.sleep(0.5)\n\n    def teardown(self):\n        \"\"\"Save state before shutdown.\"\"\"\n        print(f\"Processed {self.items_processed} items before shutdown\")\n\n# Create and configure server\nserver = Server(name=\"GracefulServer\")\nserver.add_worker(GracefulWorker(name=\"Worker-1\"))\n\n# Run until SIGINT (Ctrl+C) or SIGTERM\nserver.run_forever()\n</code></pre> <p>How Signal Handling Works:</p> <ol> <li>Server registers handlers for <code>SIGINT</code> and <code>SIGTERM</code></li> <li>When signal received, server calls <code>stop()</code> on all workers</li> <li>Workers exit their main loops gracefully</li> <li>Teardown methods execute for cleanup</li> <li>Server waits for all workers to finish (with timeout)</li> </ol> <p>Handled Signals:</p> <ul> <li><code>SIGINT</code> - Interrupt from keyboard (Ctrl+C)</li> <li><code>SIGTERM</code> - Termination request from system/container orchestrator</li> </ul>"},{"location":"advanced/workers/#async-support","title":"Async Support","text":"<p>Workers fully support async/await for modern asynchronous programming.</p>"},{"location":"advanced/workers/#async-worker-example","title":"Async Worker Example","text":"<pre><code>from spoc.workers import ThreadWorker\nimport asyncio\n\nclass AsyncAPIWorker(ThreadWorker):\n    \"\"\"Worker that makes async HTTP requests.\"\"\"\n\n    async def setup(self):\n        \"\"\"Async setup method.\"\"\"\n        # Create async HTTP client\n        self.session = await self.create_session()\n\n    async def main(self):\n        \"\"\"Async main loop.\"\"\"\n        while self.is_running:\n            # Fetch data from API\n            data = await self.fetch_data()\n            await self.process_data(data)\n            await asyncio.sleep(5)\n\n    async def teardown(self):\n        \"\"\"Async cleanup.\"\"\"\n        await self.session.close()\n\n    async def fetch_data(self):\n        \"\"\"Fetch data from API.\"\"\"\n        # Simulated async HTTP request\n        await asyncio.sleep(0.1)\n        return {\"status\": \"ok\"}\n\n    async def process_data(self, data):\n        \"\"\"Process fetched data.\"\"\"\n        print(f\"Processed: {data}\")\n\n    async def create_session(self):\n        \"\"\"Create HTTP session.\"\"\"\n        # In real code, use aiohttp or similar\n        return object()\n\n    async def lifecycle(self, event_type, **data):\n        \"\"\"Async lifecycle handler.\"\"\"\n        print(f\"Async event: {event_type}\")\n</code></pre>"},{"location":"advanced/workers/#run_async_safely","title":"run_async_safely()","text":"<p>The <code>run_async_safely()</code> function runs coroutines correctly whether an event loop exists or not.</p> <pre><code>from spoc.workers import run_async_safely\nimport asyncio\n\nasync def my_coroutine():\n    \"\"\"Example async function.\"\"\"\n    await asyncio.sleep(1)\n    return \"Done\"\n\n# Safely run coroutine (creates event loop if needed)\nrun_async_safely(my_coroutine())\n</code></pre> <p>Behavior:</p> <ul> <li>If event loop is running: Creates task in existing loop</li> <li>If no event loop: Creates new loop and runs coroutine with <code>asyncio.run()</code></li> <li>Automatically uses uvloop if available for better performance</li> </ul>"},{"location":"advanced/workers/#uvloop-integration","title":"uvloop Integration","text":"<p>SPOC automatically uses uvloop for improved async performance when available.</p>"},{"location":"advanced/workers/#enable-uvloop","title":"Enable uvloop","text":"<pre><code>from spoc.workers import set_uvloop_if_available\n\n# Enable uvloop for all async operations\nset_uvloop_if_available()\n\n# Now create async workers - they'll use uvloop automatically\nworker = AsyncAPIWorker(name=\"FastWorker\")\nworker.start()\n</code></pre> <p>Benefits:</p> <ul> <li>2-4x faster than default asyncio event loop</li> <li>Better performance for I/O-bound async workloads</li> <li>Drop-in replacement (no code changes needed)</li> </ul> <p>Installation:</p> <pre><code>pip install uvloop\n</code></pre>"},{"location":"advanced/workers/#worker-patterns-and-best-practices","title":"Worker Patterns and Best Practices","text":""},{"location":"advanced/workers/#pattern-1-background-job-processor","title":"Pattern 1: Background Job Processor","text":"<p>Process jobs from a queue in the background.</p> <pre><code>from spoc.workers import ThreadWorker\nfrom queue import Queue\nimport time\n\nclass JobProcessor(ThreadWorker):\n    \"\"\"Process jobs from a shared queue.\"\"\"\n\n    def __init__(self, name, job_queue):\n        super().__init__(name)\n        self.job_queue = job_queue\n\n    def main(self):\n        \"\"\"Process jobs until stopped.\"\"\"\n        while self.is_running:\n            try:\n                # Get job with timeout to allow checking is_running\n                job = self.job_queue.get(timeout=1.0)\n                self.process_job(job)\n                self.job_queue.task_done()\n            except Exception:\n                # Queue empty, continue\n                continue\n\n    def process_job(self, job):\n        \"\"\"Process a single job.\"\"\"\n        print(f\"{self.name} processing: {job}\")\n        time.sleep(0.5)  # Simulate work\n\n# Create shared queue\njob_queue = Queue()\n\n# Create server with multiple workers\nserver = Server(name=\"JobServer\")\nserver.add_worker(JobProcessor(\"Worker-1\", job_queue))\nserver.add_worker(JobProcessor(\"Worker-2\", job_queue))\n\n# Add jobs\nfor i in range(10):\n    job_queue.put(f\"Job-{i}\")\n\n# Process jobs\nserver.start()\njob_queue.join()  # Wait for all jobs to complete\nserver.stop()\nserver.join_all()\n</code></pre>"},{"location":"advanced/workers/#pattern-2-periodic-tasks","title":"Pattern 2: Periodic Tasks","text":"<p>Run tasks on a schedule.</p> <pre><code>from spoc.workers import ThreadWorker\nimport time\nfrom datetime import datetime\n\nclass PeriodicWorker(ThreadWorker):\n    \"\"\"Execute tasks on a schedule.\"\"\"\n\n    def __init__(self, name, interval_seconds):\n        super().__init__(name)\n        self.interval = interval_seconds\n\n    def main(self):\n        \"\"\"Run task periodically.\"\"\"\n        while self.is_running:\n            start_time = time.time()\n\n            # Execute the task\n            self.execute_task()\n\n            # Sleep for remaining interval\n            elapsed = time.time() - start_time\n            sleep_time = max(0, self.interval - elapsed)\n\n            # Sleep in small chunks to check is_running\n            while sleep_time &gt; 0 and self.is_running:\n                time.sleep(min(1.0, sleep_time))\n                sleep_time -= 1.0\n\n    def execute_task(self):\n        \"\"\"Override this method with your task logic.\"\"\"\n        print(f\"[{datetime.now()}] Task executed\")\n\nclass DataSyncWorker(PeriodicWorker):\n    \"\"\"Sync data every 5 minutes.\"\"\"\n\n    def __init__(self, name):\n        super().__init__(name, interval_seconds=300)\n\n    def execute_task(self):\n        \"\"\"Sync data from remote source.\"\"\"\n        print(f\"Syncing data at {datetime.now()}\")\n        # Perform sync logic here\n\n# Run periodic worker\nworker = DataSyncWorker(name=\"DataSync\")\nserver = Server()\nserver.add_worker(worker)\nserver.run_forever()\n</code></pre>"},{"location":"advanced/workers/#pattern-3-multi-stage-pipeline","title":"Pattern 3: Multi-Stage Pipeline","text":"<p>Process data through multiple stages with different workers.</p> <pre><code>from spoc.workers import ThreadWorker, ProcessWorker\nfrom queue import Queue\n\nclass StageWorker(ThreadWorker):\n    \"\"\"Base class for pipeline stage workers.\"\"\"\n\n    def __init__(self, name, input_queue, output_queue):\n        super().__init__(name)\n        self.input_queue = input_queue\n        self.output_queue = output_queue\n\n    def main(self):\n        \"\"\"Process items from input to output.\"\"\"\n        while self.is_running:\n            try:\n                item = self.input_queue.get(timeout=1.0)\n                result = self.process_item(item)\n                if result is not None:\n                    self.output_queue.put(result)\n                self.input_queue.task_done()\n            except Exception:\n                continue\n\n    def process_item(self, item):\n        \"\"\"Override this method for stage-specific processing.\"\"\"\n        raise NotImplementedError\n\nclass FetchStage(StageWorker):\n    \"\"\"Stage 1: Fetch raw data.\"\"\"\n\n    def process_item(self, item):\n        \"\"\"Fetch data.\"\"\"\n        return {\"id\": item, \"raw_data\": f\"data-{item}\"}\n\nclass TransformStage(ProcessWorker):\n    \"\"\"Stage 2: Transform data (CPU-intensive).\"\"\"\n\n    def __init__(self, name, input_queue, output_queue):\n        super().__init__(name)\n        self.input_queue = input_queue\n        self.output_queue = output_queue\n\n    def main(self):\n        \"\"\"Transform items.\"\"\"\n        while self.is_running:\n            try:\n                item = self.input_queue.get(timeout=1.0)\n                result = self.transform(item)\n                self.output_queue.put(result)\n                self.input_queue.task_done()\n            except Exception:\n                continue\n\n    def transform(self, item):\n        \"\"\"CPU-intensive transformation.\"\"\"\n        # Simulate heavy processing\n        return {**item, \"transformed\": True}\n\nclass SaveStage(StageWorker):\n    \"\"\"Stage 3: Save results.\"\"\"\n\n    def process_item(self, item):\n        \"\"\"Save to database.\"\"\"\n        print(f\"Saved: {item}\")\n        return None  # End of pipeline\n\n# Create pipeline\nfetch_to_transform = Queue()\ntransform_to_save = Queue()\ninput_queue = Queue()\n\nserver = Server(name=\"Pipeline\")\nserver.add_worker(FetchStage(\"Fetch\", input_queue, fetch_to_transform))\nserver.add_worker(TransformStage(\"Transform\", fetch_to_transform, transform_to_save))\nserver.add_worker(SaveStage(\"Save\", transform_to_save, Queue()))\n\n# Feed pipeline\nfor i in range(10):\n    input_queue.put(i)\n\n# Run pipeline\nserver.run_forever()\n</code></pre>"},{"location":"advanced/workers/#pattern-4-health-monitoring","title":"Pattern 4: Health Monitoring","text":"<p>Monitor worker health and restart on failure.</p> <pre><code>from spoc.workers import ThreadWorker\nimport time\n\nclass HealthMonitor(ThreadWorker):\n    \"\"\"Monitor and restart failed workers.\"\"\"\n\n    def __init__(self, name, workers_to_monitor):\n        super().__init__(name)\n        self.workers = workers_to_monitor\n\n    def main(self):\n        \"\"\"Check worker health periodically.\"\"\"\n        while self.is_running:\n            for worker in self.workers:\n                if not worker._thread_or_process.is_alive():\n                    print(f\"Worker {worker.name} died, restarting...\")\n                    self.restart_worker(worker)\n\n            time.sleep(5)  # Check every 5 seconds\n\n    def restart_worker(self, worker):\n        \"\"\"Restart a failed worker.\"\"\"\n        # Create new instance of same worker type\n        new_worker = type(worker)(worker.name)\n        new_worker.start()\n\n        # Replace in monitoring list\n        idx = self.workers.index(worker)\n        self.workers[idx] = new_worker\n\n    def lifecycle(self, event_type, **data):\n        \"\"\"Handle lifecycle events.\"\"\"\n        if event_type == \"error\":\n            print(f\"Health monitor detected error: {data.get('exception')}\")\n</code></pre>"},{"location":"advanced/workers/#best-practices","title":"Best Practices","text":""},{"location":"advanced/workers/#1-always-check-is_running","title":"1. Always Check is_running","text":"<p>Check <code>self.is_running</code> regularly in your main loop to allow graceful shutdown:</p> <pre><code>def main(self):\n    \"\"\"Good: Checks is_running regularly.\"\"\"\n    while self.is_running:\n        self.do_work()\n        time.sleep(1)\n</code></pre> <pre><code>def main(self):\n    \"\"\"Bad: No shutdown check.\"\"\"\n    while True:  # Will never stop gracefully\n        self.do_work()\n        time.sleep(1)\n</code></pre>"},{"location":"advanced/workers/#2-use-appropriate-worker-type","title":"2. Use Appropriate Worker Type","text":"<p>Choose based on your workload:</p> <pre><code># I/O-bound: Use ThreadWorker\nclass APIClient(ThreadWorker):\n    def main(self):\n        while self.is_running:\n            response = requests.get(\"https://api.example.com\")\n            self.process(response)\n\n# CPU-bound: Use ProcessWorker\nclass DataCruncher(ProcessWorker):\n    def main(self):\n        while self.is_running:\n            data = self.get_data()\n            result = self.heavy_computation(data)\n</code></pre>"},{"location":"advanced/workers/#3-clean-up-resources","title":"3. Clean Up Resources","text":"<p>Always clean up in teardown():</p> <pre><code>def setup(self):\n    \"\"\"Acquire resources.\"\"\"\n    self.db_conn = connect_to_database()\n    self.file_handle = open(\"data.txt\", \"w\")\n\ndef teardown(self):\n    \"\"\"Release resources.\"\"\"\n    if hasattr(self, 'db_conn'):\n        self.db_conn.close()\n    if hasattr(self, 'file_handle'):\n        self.file_handle.close()\n</code></pre>"},{"location":"advanced/workers/#4-handle-errors-gracefully","title":"4. Handle Errors Gracefully","text":"<p>Catch and handle exceptions in your worker code:</p> <pre><code>def main(self):\n    \"\"\"Handle errors without crashing.\"\"\"\n    while self.is_running:\n        try:\n            self.do_risky_operation()\n        except ConnectionError as e:\n            print(f\"Connection failed: {e}, retrying...\")\n            time.sleep(5)\n        except Exception as e:\n            # Let unexpected errors propagate to lifecycle handler\n            raise\n</code></pre>"},{"location":"advanced/workers/#5-use-lifecycle-events-for-monitoring","title":"5. Use Lifecycle Events for Monitoring","text":"<p>Implement lifecycle events for observability:</p> <pre><code>def lifecycle(self, event_type, **data):\n    \"\"\"Send lifecycle events to monitoring system.\"\"\"\n    match event_type:\n        case \"startup\":\n            metrics.increment(\"worker.started\")\n        case \"shutdown\":\n            metrics.increment(\"worker.stopped\")\n        case \"error\":\n            metrics.increment(\"worker.errors\")\n            logger.error(f\"Worker error: {data['exception']}\")\n</code></pre>"},{"location":"advanced/workers/#6-use-context-for-shared-state","title":"6. Use Context for Shared State","text":"<p>Use <code>self.context</code> for sharing state between methods:</p> <pre><code>def setup(self):\n    \"\"\"Initialize shared context.\"\"\"\n    self.context.processed_count = 0\n    self.context.start_time = time.time()\n\ndef main(self):\n    \"\"\"Access shared context.\"\"\"\n    while self.is_running:\n        self.do_work()\n        self.context.processed_count += 1\n\ndef teardown(self):\n    \"\"\"Report using shared context.\"\"\"\n    elapsed = time.time() - self.context.start_time\n    rate = self.context.processed_count / elapsed\n    print(f\"Processed {self.context.processed_count} items at {rate:.2f}/sec\")\n</code></pre>"},{"location":"advanced/workers/#7-test-worker-logic-separately","title":"7. Test Worker Logic Separately","text":"<p>Extract business logic for easier testing:</p> <pre><code>class DataWorker(ThreadWorker):\n    \"\"\"Worker with testable logic.\"\"\"\n\n    def main(self):\n        \"\"\"Worker loop.\"\"\"\n        while self.is_running:\n            data = self.fetch_data()\n            result = self.process_data(data)  # Testable\n            self.save_result(result)\n\n    @staticmethod\n    def process_data(data):\n        \"\"\"Pure function - easy to test.\"\"\"\n        return data.upper()\n\n# Test the logic\ndef test_process_data():\n    assert DataWorker.process_data(\"hello\") == \"HELLO\"\n</code></pre>"},{"location":"advanced/workers/#common-pitfalls","title":"Common Pitfalls","text":""},{"location":"advanced/workers/#pitfall-1-blocking-operations-without-timeout","title":"Pitfall 1: Blocking Operations Without Timeout","text":"<pre><code># Bad: Will block forever, can't shut down gracefully\ndef main(self):\n    while self.is_running:\n        item = self.queue.get()  # Blocks forever if queue empty\n        self.process(item)\n\n# Good: Use timeout to check is_running\ndef main(self):\n    while self.is_running:\n        try:\n            item = self.queue.get(timeout=1.0)\n            self.process(item)\n        except Empty:\n            continue\n</code></pre>"},{"location":"advanced/workers/#pitfall-2-shared-mutable-state-threadworker","title":"Pitfall 2: Shared Mutable State (ThreadWorker)","text":"<pre><code># Bad: Race condition with shared state\nclass CounterWorker(ThreadWorker):\n    shared_counter = 0  # Class variable - shared!\n\n    def main(self):\n        while self.is_running:\n            self.shared_counter += 1  # Race condition!\n\n# Good: Use instance variables or locks\nclass SafeCounterWorker(ThreadWorker):\n    def setup(self):\n        self.counter = 0  # Instance variable\n\n    def main(self):\n        while self.is_running:\n            self.counter += 1  # Safe\n</code></pre>"},{"location":"advanced/workers/#pitfall-3-memory-leaks-in-long-running-workers","title":"Pitfall 3: Memory Leaks in Long-Running Workers","text":"<pre><code># Bad: Unbounded memory growth\ndef main(self):\n    results = []\n    while self.is_running:\n        result = self.compute()\n        results.append(result)  # List grows forever!\n\n# Good: Process and discard\ndef main(self):\n    while self.is_running:\n        result = self.compute()\n        self.save_result(result)  # Process immediately\n</code></pre>"},{"location":"advanced/workers/#summary","title":"Summary","text":"<p>You now understand:</p> <ul> <li>When to use workers for background tasks and concurrency</li> <li>ThreadWorker vs ProcessWorker trade-offs and use cases</li> <li>Worker lifecycle (setup, main, teardown)</li> <li>The Server class for managing multiple workers</li> <li>Signal handling with run_forever()</li> <li>Async/await support with run_async_safely()</li> <li>uvloop integration for performance</li> <li>Common patterns for job processing, periodic tasks, and pipelines</li> <li>Best practices for robust worker implementation</li> </ul> <p>Workers provide a solid foundation for building concurrent, fault-tolerant systems. Use them to offload background work, process data in parallel, and build responsive applications.</p>"},{"location":"advanced/workers/#next-steps","title":"Next Steps","text":"<ul> <li>Study Examples: Review <code>examples/workers.py</code> for working code</li> <li>Framework Integration: Combine workers with SPOC Framework for complete applications</li> <li>Advanced Patterns: Explore worker pools, retry logic, and circuit breakers</li> <li>API Reference: See Framework API for complete documentation</li> </ul>"},{"location":"api/components/","title":"Components API Reference","text":"<p>This page provides detailed API documentation for the Components module in SPOC.</p>"},{"location":"api/components/#components-class","title":"Components Class","text":""},{"location":"api/components/#spoc.components.Components","title":"<code>spoc.components.Components(*types)</code>","text":"<p>Registry for named component\u2010types and their validation logic.</p> <p>This class provides a registry for different types of components and manages their registration, validation, and metadata handling.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; components = Components(\"command\", \"model\")\n&gt;&gt;&gt; @components.register(\"command\", config={\"foo\": \"bar\"})\n&gt;&gt;&gt; class Cmd:\n&gt;&gt;&gt;     pass\n</code></pre> <p>Parameters:</p> <ul> <li> <code>*types</code>               (<code>str</code>, default:                   <code>()</code> )           \u2013            <p>Variable number of component type names to register initially</p> </li> </ul>"},{"location":"api/components/#spoc.components.Components.add_type","title":"<code>add_type(name, default_meta=None)</code>","text":"<p>Declare a new component type, optionally with default metadata.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>Name of the component type to add.</p> </li> <li> <code>default_meta</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional default metadata for this component type.</p> </li> </ul>"},{"location":"api/components/#spoc.components.Components.register","title":"<code>register(type_name, obj=None, *, config=None)</code>","text":"<p>Decorator to mark something as a component of <code>type_name</code>.</p> <p>Parameters:</p> <ul> <li> <code>type_name</code>               (<code>str</code>)           \u2013            <p>The component type to register as</p> </li> <li> <code>obj</code>               (<code>Any</code>, default:                   <code>None</code> )           \u2013            <p>Optional object to directly decorate</p> </li> <li> <code>config</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional configuration dictionary for the component</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Any</code>           \u2013            <p>A decorator function that registers an object as this component type</p> </li> <li> <code>Any</code>           \u2013            <p>or the decorated object if obj is directly provided</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>KeyError</code>             \u2013            <p>If the component type was not previously declared</p> </li> </ul>"},{"location":"api/components/#spoc.components.Components.is_spoc","title":"<code>is_spoc(obj)</code>","text":"<p>Check whether <code>obj</code> has been marked as a spoc object.</p> <p>Parameters:</p> <ul> <li> <code>obj</code>               (<code>Any</code>)           \u2013            <p>The object to check</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if the object has been decorated with the @component decorator</p> </li> </ul>"},{"location":"api/components/#spoc.components.Components.is_component","title":"<code>is_component(type_name, obj)</code>","text":"<p>Validate that <code>obj</code> is a component of the declared <code>type_name</code>.</p> <p>Parameters:</p> <ul> <li> <code>type_name</code>               (<code>str</code>)           \u2013            <p>The component type to check against</p> </li> <li> <code>obj</code>               (<code>Any</code>)           \u2013            <p>The object to validate</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if the object is a component of the specified type</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>KeyError</code>             \u2013            <p>If the component type was not previously declared</p> </li> </ul>"},{"location":"api/components/#spoc.components.Components.get_info","title":"<code>get_info(obj)</code>","text":"<p>Get the Component(Info) for a given object.</p> <p>Parameters:</p> <ul> <li> <code>obj</code>               (<code>Any</code>)           \u2013            <p>The object to get component info for</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Internal | None</code>           \u2013            <p>Internal metadata object if available, otherwise None</p> </li> </ul>"},{"location":"api/components/#spoc.components.Components.builder","title":"<code>builder(the_object)</code>","text":"<p>Build a Component object from a decorated object.</p> <p>Parameters:</p> <ul> <li> <code>the_object</code>               (<code>Any</code>)           \u2013            <p>A component-decorated object</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Component</code>           \u2013            <p>A Component instance with metadata extracted from the object</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>AttributeError</code>             \u2013            <p>If the object doesn't have required attributes</p> </li> </ul>"},{"location":"api/components/#spoc.components.Components.case_style","title":"<code>case_style(text, mode='snake')</code>  <code>staticmethod</code>","text":"<p>Convert a string to the given case style.</p> <p>Parameters:</p> <ul> <li> <code>text</code>               (<code>str</code>)           \u2013            <p>The text to convert</p> </li> <li> <code>mode</code>               (<code>Literal['snake', 'camel', 'pascal', 'kebab']</code>, default:                   <code>'snake'</code> )           \u2013            <p>The case style to convert to</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The converted string in the requested case style</p> </li> </ul>"},{"location":"api/components/#component-decorator","title":"Component Decorator","text":""},{"location":"api/components/#spoc.components.component","title":"<code>spoc.components.component(obj=None, *, config=None, metadata=None)</code>","text":"<p>Mark a class or function as a \"component\" by attaching ComponentInfo.</p> <p>This decorator attaches metadata to an object to identify it as a component in the SPOC framework. Can be used as either a simple decorator or a decorator factory with parameters.</p> <p>Parameters:</p> <ul> <li> <code>obj</code>               (<code>Any</code>, default:                   <code>None</code> )           \u2013            <p>The object to decorate (when used as @component)</p> </li> <li> <code>config</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional configuration dictionary for the component</p> </li> <li> <code>metadata</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional metadata dictionary for the component</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Any</code>           \u2013            <p>The decorated object or a decorator function</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; @component(config={\"key\": \"value\"}, metadata={\"type\": \"command\"})\n&gt;&gt;&gt; class MyComponent:\n&gt;&gt;&gt;     pass\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Or as direct call\n&gt;&gt;&gt; my_func = component(my_func, config={\"timeout\": 30})\n</code></pre>"},{"location":"api/components/#component-data-classes","title":"Component Data Classes","text":""},{"location":"api/components/#spoc.components.Component","title":"<code>spoc.components.Component(type, uri, app, name, object, internal)</code>  <code>dataclass</code>","text":"<p>Holds metadata and configuration for a registered component and the component that uses it.</p> <p>Attributes:</p> <ul> <li> <code>type</code>               (<code>str</code>)           \u2013            <p>Component type identifier</p> </li> <li> <code>uri</code>               (<code>str</code>)           \u2013            <p>Unique resource identifier for the component</p> </li> <li> <code>app</code>               (<code>str</code>)           \u2013            <p>Application name the component belongs to</p> </li> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>Component name</p> </li> <li> <code>object</code>               (<code>Any</code>)           \u2013            <p>The actual component object</p> </li> <li> <code>internal</code>               (<code>Internal</code>)           \u2013            <p>Internal metadata container</p> </li> </ul>"},{"location":"api/components/#spoc.components.Internal","title":"<code>spoc.components.Internal(config, metadata)</code>  <code>dataclass</code>","text":"<p>Holds metadata and configuration for a registered component.</p> <p>Attributes:</p> <ul> <li> <code>config</code>               (<code>dict[str, Any]</code>)           \u2013            <p>Component configuration dictionary</p> </li> <li> <code>metadata</code>               (<code>dict[str, Any]</code>)           \u2013            <p>Component metadata dictionary</p> </li> </ul>"},{"location":"api/components/#helper-functions","title":"Helper Functions","text":""},{"location":"api/components/#spoc.components.is_spoc","title":"<code>spoc.components.is_spoc(obj)</code>","text":"<p>Check whether <code>obj</code> has been marked as a spoc object.</p> <p>Parameters:</p> <ul> <li> <code>obj</code>               (<code>Any</code>)           \u2013            <p>The object to check</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if the object has been decorated with the @component decorator</p> </li> </ul>"},{"location":"api/components/#spoc.components.is_component","title":"<code>spoc.components.is_component(obj, metadata)</code>","text":"<p>Check whether <code>obj</code> has been marked as a component with the given metadata.</p> <p>Parameters:</p> <ul> <li> <code>obj</code>               (<code>Any</code>)           \u2013            <p>The object to check</p> </li> <li> <code>metadata</code>               (<code>dict[str, Any]</code>)           \u2013            <p>The metadata to match against</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if the object has been decorated with matching metadata</p> </li> </ul>"},{"location":"api/core-utils/","title":"Core Utilities API Reference","text":"<p>This page provides detailed API documentation for SPOC's core utility modules, including exceptions, singleton patterns, dependency management, case conversion, and path injection utilities.</p>"},{"location":"api/core-utils/#exceptions","title":"Exceptions","text":"<p>SPOC provides a hierarchy of custom exceptions for clear error handling and debugging.</p>"},{"location":"api/core-utils/#spocerror","title":"SpocError","text":""},{"location":"api/core-utils/#spoc.core.exceptions.SpocError","title":"<code>spoc.core.exceptions.SpocError(message, module_name=None)</code>","text":"<p>Base exception for all dynamic import errors.</p> <p>Parameters:</p> <ul> <li> <code>message</code>               (<code>str</code>)           \u2013            <p>The error message.</p> </li> <li> <code>module_name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Name of the module that caused the error, if applicable.</p> </li> </ul>"},{"location":"api/core-utils/#appnotfounderror","title":"AppNotFoundError","text":""},{"location":"api/core-utils/#spoc.core.exceptions.AppNotFoundError","title":"<code>spoc.core.exceptions.AppNotFoundError(module_name)</code>","text":"<p>Raised when a module cannot be found during dynamic import.</p> <p>Parameters:</p> <ul> <li> <code>module_name</code>               (<code>str</code>)           \u2013            <p>Name of the module that could not be found.</p> </li> </ul>"},{"location":"api/core-utils/#modulenotcachederror","title":"ModuleNotCachedError","text":""},{"location":"api/core-utils/#spoc.core.exceptions.ModuleNotCachedError","title":"<code>spoc.core.exceptions.ModuleNotCachedError(module_name)</code>","text":"<p>Raised when attempting to access a module that is not in the cache.</p> <p>Parameters:</p> <ul> <li> <code>module_name</code>               (<code>str</code>)           \u2013            <p>Name of the module that is not cached.</p> </li> </ul>"},{"location":"api/core-utils/#circulardependencyerror","title":"CircularDependencyError","text":""},{"location":"api/core-utils/#spoc.core.exceptions.CircularDependencyError","title":"<code>spoc.core.exceptions.CircularDependencyError(modules)</code>","text":"<p>Raised when a circular dependency is detected during startup/shutdown.</p> <p>Parameters:</p> <ul> <li> <code>modules</code>               (<code>list[str]</code>)           \u2013            <p>List of modules involved in the circular dependency.</p> </li> </ul>"},{"location":"api/core-utils/#lifecycleerror","title":"LifecycleError","text":""},{"location":"api/core-utils/#spoc.core.exceptions.LifecycleError","title":"<code>spoc.core.exceptions.LifecycleError(message, module_name=None)</code>","text":"<p>Raised when an error occurs during module lifecycle operations.</p> <p>Parameters:</p> <ul> <li> <code>message</code>               (<code>str</code>)           \u2013            <p>The error message.</p> </li> <li> <code>module_name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Name of the module where the lifecycle error occurred.</p> </li> </ul>"},{"location":"api/core-utils/#configurationerror","title":"ConfigurationError","text":""},{"location":"api/core-utils/#spoc.core.exceptions.ConfigurationError","title":"<code>spoc.core.exceptions.ConfigurationError(message, config_file=None, original_error=None)</code>","text":"<p>Error in configuration loading or validation.</p> <p>Parameters:</p> <ul> <li> <code>message</code>               (<code>str</code>)           \u2013            <p>Error message</p> </li> <li> <code>config_file</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The configuration file that caused the error</p> </li> <li> <code>original_error</code>               (<code>Exception | None</code>, default:                   <code>None</code> )           \u2013            <p>The original exception that caused this error</p> </li> </ul>"},{"location":"api/core-utils/#singleton-pattern","title":"Singleton Pattern","text":"<p>SPOC provides two approaches to implementing the Singleton pattern: a metaclass and a decorator.</p>"},{"location":"api/core-utils/#singletonmeta","title":"SingletonMeta","text":""},{"location":"api/core-utils/#spoc.core.singleton.SingletonMeta","title":"<code>spoc.core.singleton.SingletonMeta</code>","text":"<p>Metaclass that creates a Singleton class.</p> <p>Any class using this metaclass will have only one instance, with subsequent instantiations returning the same instance.</p> <p>Example:</p> <pre><code>class SingletonClass(metaclass=SingletonMeta):\n    def __init__(self, value=None):\n        self.value = value or \"default\"\n</code></pre>"},{"location":"api/core-utils/#spoc.core.singleton.SingletonMeta.reset","title":"<code>reset(mcs, target_cls=None)</code>  <code>classmethod</code>","text":"<p>Reset the singleton instance(s).</p> <p>Parameters:</p> <ul> <li> <code>target_cls</code>               (<code>type | None</code>, default:                   <code>None</code> )           \u2013            <p>A specific class to reset. If None, resets all instances.</p> </li> </ul> <p>This method is particularly useful for testing scenarios.</p>"},{"location":"api/core-utils/#singleton-decorator","title":"singleton Decorator","text":""},{"location":"api/core-utils/#spoc.core.singleton.singleton","title":"<code>spoc.core.singleton.singleton(cls)</code>","text":"<p>Decorator to convert a class into a Singleton.</p> <p>Parameters:</p> <ul> <li> <code>cls</code>               (<code>Type[T]</code>)           \u2013            <p>The class to convert to a Singleton.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Callable[..., T]</code>           \u2013            <p>A wrapped function that returns the singleton instance.</p> </li> </ul> <p>Example:</p> <pre><code>@singleton\nclass SingletonClass:\n    def __init__(self, value=None):\n        self.value = value or \"default\"\n</code></pre>"},{"location":"api/core-utils/#dependency-management","title":"Dependency Management","text":""},{"location":"api/core-utils/#dependencygraph","title":"DependencyGraph","text":""},{"location":"api/core-utils/#spoc.core.utils.DependencyGraph","title":"<code>spoc.core.utils.DependencyGraph()</code>","text":"<p>Graph data structure for managing dependencies and their resolution order.</p> <p>This class provides topological sorting algorithms to handle module dependencies for initialization and teardown procedures.</p> Time Complexity <ul> <li>Addition of nodes and edges: O(1)</li> <li>Topological sort: O(V + E) where V is number of nodes and E is number of edges</li> </ul>"},{"location":"api/core-utils/#spoc.core.utils.DependencyGraph.add_node","title":"<code>add_node(node)</code>","text":"<p>Add a node to the graph.</p> <p>Parameters:</p> <ul> <li> <code>node</code>               (<code>T</code>)           \u2013            <p>The node to add.</p> </li> </ul>"},{"location":"api/core-utils/#spoc.core.utils.DependencyGraph.add_edge","title":"<code>add_edge(from_node, to_node)</code>","text":"<p>Add a directed edge from one node to another.</p> <p>Parameters:</p> <ul> <li> <code>from_node</code>               (<code>T</code>)           \u2013            <p>The source node.</p> </li> <li> <code>to_node</code>               (<code>T</code>)           \u2013            <p>The target node that depends on the source.</p> </li> </ul>"},{"location":"api/core-utils/#spoc.core.utils.DependencyGraph.topological_sort","title":"<code>topological_sort()</code>","text":"<p>Perform topological sort on the graph.</p> <p>Returns:</p> <ul> <li> <code>List[T]</code>           \u2013            <p>A list of nodes in topological order.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>CircularDependencyError</code>             \u2013            <p>If a cycle is detected in the graph.</p> </li> </ul>"},{"location":"api/core-utils/#spoc.core.utils.DependencyGraph.reversed","title":"<code>reversed()</code>","text":"<p>Create a new graph with all edges reversed.</p> <p>Useful for shutdown sequence where dependencies need to be torn down in reverse order of initialization.</p> <p>Returns:</p> <ul> <li> <code>'DependencyGraph[T]'</code>           \u2013            <p>A new DependencyGraph with reversed edges.</p> </li> </ul>"},{"location":"api/core-utils/#utility-functions","title":"Utility Functions","text":""},{"location":"api/core-utils/#spoc.core.utils.get_attribute","title":"<code>spoc.core.utils.get_attribute(obj, attr_path)</code>","text":"<p>Get an attribute from an object using a dot-separated path.</p> <p>Parameters:</p> <ul> <li> <code>obj</code>               (<code>object</code>)           \u2013            <p>The object to get the attribute from.</p> </li> <li> <code>attr_path</code>               (<code>str</code>)           \u2013            <p>Dot-separated path to the attribute (e.g., \"config.debug\").</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>object</code>           \u2013            <p>The attribute value.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>AttributeError</code>             \u2013            <p>If any part of the path doesn't exist.</p> </li> </ul>"},{"location":"api/core-utils/#case-style-conversion","title":"Case Style Conversion","text":"<p>SPOC provides utilities to convert strings between different naming conventions.</p>"},{"location":"api/core-utils/#case_style-function","title":"case_style Function","text":""},{"location":"api/core-utils/#spoc.case_style.case_style","title":"<code>spoc.case_style.case_style(s, mode='snake', clip_edges=True)</code>","text":"<p>Convert string <code>s</code> between case styles by normalizing to words first.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; case_style(\"HelloWorld\", \"snake\")\n\"hello_world\"\n&gt;&gt;&gt; case_style(\"hello_world\", \"pascal\")\n\"HelloWorld\"\n&gt;&gt;&gt; case_style(\"Hello-World\", \"kebab\")\n\"hello-world\"\n</code></pre>"},{"location":"api/core-utils/#conversion-functions","title":"Conversion Functions","text":""},{"location":"api/core-utils/#spoc.case_style.to_snake_case","title":"<code>spoc.case_style.to_snake_case(s, clip_edges=True)</code>  <code>cached</code>","text":"<p>AnyCase \u2192 snake_case.</p>"},{"location":"api/core-utils/#spoc.case_style.to_camel_case","title":"<code>spoc.case_style.to_camel_case(s)</code>  <code>cached</code>","text":"<p>snake_case (or any) \u2192 camelCase.</p>"},{"location":"api/core-utils/#spoc.case_style.to_pascal_case","title":"<code>spoc.case_style.to_pascal_case(s)</code>  <code>cached</code>","text":"<p>snake_case (or any) \u2192 PascalCase.</p>"},{"location":"api/core-utils/#spoc.case_style.to_kebab_case","title":"<code>spoc.case_style.to_kebab_case(s)</code>  <code>cached</code>","text":"<p>snake_case (or any) \u2192 kebab-case.</p>"},{"location":"api/core-utils/#type-guards","title":"Type Guards","text":""},{"location":"api/core-utils/#spoc.case_style.is_valid_case_style","title":"<code>spoc.case_style.is_valid_case_style(mode)</code>","text":"<p>True if <code>mode</code> is one of the supported case styles.</p>"},{"location":"api/core-utils/#path-injection","title":"Path Injection","text":""},{"location":"api/core-utils/#inject_apps-function","title":"inject_apps Function","text":""},{"location":"api/core-utils/#spoc.inject_apps.inject_apps","title":"<code>spoc.inject_apps.inject_apps(base_dir, apps_dir_name='apps', *, position=0)</code>","text":"<p>Ensure an 'apps' directory exists under <code>base_dir</code> and inject it into Python's import path.</p>"},{"location":"api/core-utils/#helper-functions","title":"Helper Functions","text":""},{"location":"api/core-utils/#spoc.inject_apps.ensure_directory","title":"<code>spoc.inject_apps.ensure_directory(path, *, exist_ok=True)</code>","text":"<p>Ensure that the given directory exists.</p>"},{"location":"api/core-utils/#spoc.inject_apps.add_to_python_path","title":"<code>spoc.inject_apps.add_to_python_path(path, position=0)</code>","text":"<p>Insert the given path into sys.path if not already present.</p>"},{"location":"api/framework/","title":"Framework API Reference","text":"<p>This page provides detailed API documentation for the Framework module in SPOC.</p>"},{"location":"api/framework/#framework-class","title":"Framework Class","text":""},{"location":"api/framework/#spoc.framework.Framework","title":"<code>spoc.framework.Framework(base_dir, schema, echo=False, mode='strict')</code>","text":"<p>Core framework class for SPOC applications.</p> <p>Manages the lifecycle of an application including module loading, dependency resolution, and plugin registration. Provides a structured way to bootstrap and tear down applications.</p> <p>Parameters:</p> <ul> <li> <code>base_dir</code>               (<code>Path</code>)           \u2013            <p>Base directory for the application.</p> </li> <li> <code>schema</code>               (<code>Schema</code>)           \u2013            <p>Schema describing modules and dependencies.</p> </li> <li> <code>echo</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to echo debug information during operations.</p> </li> <li> <code>mode</code>               (<code>FrameworkMode</code>, default:                   <code>'strict'</code> )           \u2013            <p>Whether to enforce modules (files.py) in all apps at startup.</p> </li> </ul>"},{"location":"api/framework/#spoc.framework.Framework.get_component","title":"<code>get_component(kind, name)</code>","text":"<p>Get a framework component by ."},{"location":"api/framework/#spoc.framework.Framework.startup","title":"<code>startup()</code>","text":"<p>Bootstrap the application.</p> <p>Registers all configured applications, initializes modules in dependency order, and loads all plugins.</p> <p>Returns:</p> <ul> <li> <code>Framework</code>           \u2013            <p>Self instance for method chaining</p> </li> </ul>"},{"location":"api/framework/#spoc.framework.Framework.shutdown","title":"<code>shutdown()</code>","text":"<p>Tear down the application.</p> <p>Shuts down all modules in the reverse order of initialization, calling shutdown hooks as needed.</p> <p>Returns:</p> <ul> <li> <code>Framework</code>           \u2013            <p>Self instance for method chaining</p> </li> </ul>"},{"location":"api/framework/#schema-class","title":"Schema Class","text":""},{"location":"api/framework/#spoc.framework.Schema","title":"<code>spoc.framework.Schema(modules, dependencies=dict(), hooks=dict())</code>  <code>dataclass</code>","text":"<p>Schema definition for application modules and their dependencies.</p> <p>Defines a structure for modules to be loaded, their dependencies, and associated lifecycle hooks.</p>"},{"location":"api/framework/#hook-type","title":"Hook Type","text":""},{"location":"api/framework/#spoc.framework.Hook","title":"<code>spoc.framework.Hook</code>","text":"<p>Type definition for lifecycle hooks.</p> <p>A dictionary containing optional startup and shutdown callables that are executed during framework initialization and termination.</p>"},{"location":"api/framework/#config-class","title":"Config Class","text":""},{"location":"api/framework/#spoc.framework.Config","title":"<code>spoc.framework.Config(project, settings, environment)</code>  <code>dataclass</code>","text":"<p>Configuration container for the framework.</p> <p>Holds project configuration, settings, and environment variables loaded from configuration files.</p> <p>Attributes:</p> <ul> <li> <code>`project`</code>           \u2013            <p>Project configuration</p> </li> <li> <code>`settings`</code>           \u2013            <p>Settings configuration</p> </li> <li> <code>`environment`</code>           \u2013            <p>Environment variables</p> </li> </ul>"},{"location":"api/framework/#helper-functions","title":"Helper Functions","text":""},{"location":"api/framework/#spoc.framework.build_config","title":"<code>spoc.framework.build_config(base_dir)</code>","text":"<p>Build a configuration object from files in the specified directory.</p> <p>Parameters:</p> <ul> <li> <code>base_dir</code>               (<code>Path</code>)           \u2013            <p>Base directory containing configuration files</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Config</code>           \u2013            <p>Config object populated with project, settings and environment data</p> </li> </ul>"},{"location":"api/importer/","title":"Importer API Reference","text":"<p>This page provides detailed API documentation for the Importer module in SPOC.</p> <p>The Importer is central to SPOC, enabling dynamic, dependency-aware module management. It handles:</p> <ul> <li>Dynamic module loading at runtime</li> <li>Caching for efficient module reuse</li> <li>Lifecycle management with dependency-ordered initialization and teardown</li> <li>Hook registration for custom startup/shutdown behavior</li> </ul>"},{"location":"api/importer/#importer-class","title":"Importer Class","text":""},{"location":"api/importer/#spoc.core.importer.Importer","title":"<code>spoc.core.importer.Importer(on_startup_name='initialize', on_shutdown_name='teardown', mode='strict')</code>","text":"<p>Dynamic module importer with caching and lifecycle management.</p> <p>This class provides a clean API for: 1. Dynamically importing modules at runtime 2. Caching modules for efficient reuse 3. Managing module lifecycle (initialization/teardown) based on dependencies</p> <p>Time Complexity: - Module lookup in cache: O(1) - Module loading: O(1) amortized (with caching) - Startup/shutdown: O(N + E) where N = number of modules, E = number of dependencies</p> <p>Attributes:</p> <ul> <li> <code>_module_cache</code>               (<code>dict[str, ModuleInfo]</code>)           \u2013            <p>Internal cache of loaded modules</p> </li> <li> <code>_dependency_graph</code>           \u2013            <p>Graph of module dependencies for ordered initialization/teardown</p> </li> <li> <code>module_hooks</code>               (<code>ModuleHooks</code>)           \u2013            <p>Dictionary of hooks to apply to modules during lifecycle events</p> </li> <li> <code>on_startup_name</code>           \u2013            <p>Name of the function to call for module initialization</p> </li> <li> <code>on_shutdown_name</code>           \u2013            <p>Name of the function to call for module teardown</p> </li> </ul> <p>Parameters:</p> <ul> <li> <code>on_startup_name</code>               (<code>str | None</code>, default:                   <code>'initialize'</code> )           \u2013            <p>Name of the initialization function in modules, or None</p> </li> <li> <code>on_shutdown_name</code>               (<code>str | None</code>, default:                   <code>'teardown'</code> )           \u2013            <p>Name of the teardown function in modules, or None</p> </li> </ul>"},{"location":"api/importer/#spoc.core.importer.Importer.components","title":"<code>components</code>  <code>property</code>","text":"<p>Get a dictionary of all components and their instances.</p>"},{"location":"api/importer/#spoc.core.importer.Importer.load","title":"<code>load(name)</code>","text":"<p>Dynamically load a module by name.</p> <p>If the module is already in the cache, returns the cached module. Otherwise, imports the module and adds it to the cache.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The fully-qualified name of the module to load.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ModuleType | None</code>           \u2013            <p>The loaded module.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ModuleNotFoundError</code>             \u2013            <p>If the module cannot be found.</p> </li> </ul>"},{"location":"api/importer/#spoc.core.importer.Importer.register","title":"<code>register(name, dependencies=None)</code>","text":"<p>Register a module with dependencies and lifecycle hooks.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The fully-qualified name of the module to register.</p> </li> <li> <code>dependencies</code>               (<code>list[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>List of module names this module depends on.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ModuleType | None</code>           \u2013            <p>The loaded module.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ModuleNotFoundError</code>             \u2013            <p>If the module cannot be found.</p> </li> </ul>"},{"location":"api/importer/#spoc.core.importer.Importer.register_hook","title":"<code>register_hook(pattern, on_startup=None, on_shutdown=None)</code>  <code>classmethod</code>","text":"<p>Pre-register custom initialization and teardown functions for modules.</p> <p>These hooks will be attached to the module when it's loaded, overriding any default hooks.</p> <p>Parameters:</p> <ul> <li> <code>pattern</code>               (<code>str</code>)           \u2013            <p>The fully-qualified name of the module or a pattern with wildcards.</p> </li> <li> <code>on_startup</code>               (<code>Callable | None</code>, default:                   <code>None</code> )           \u2013            <p>Custom initialization function for this module.</p> </li> <li> <code>on_shutdown</code>               (<code>Callable | None</code>, default:                   <code>None</code> )           \u2013            <p>Custom teardown function for this module.</p> </li> </ul>"},{"location":"api/importer/#spoc.core.importer.Importer.load_from_uri","title":"<code>load_from_uri(uri)</code>","text":"<p>Load a function from a full URI like 'package.module.func'.</p>"},{"location":"api/importer/#spoc.core.importer.Importer.has","title":"<code>has(name)</code>","text":"<p>Check if a module is in the cache.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the module to check.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if the module is in the cache, False otherwise.</p> </li> </ul>"},{"location":"api/importer/#spoc.core.importer.Importer.get","title":"<code>get(name)</code>","text":"<p>Get a module from the cache.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the module to get.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ModuleType</code>           \u2013            <p>The cached module.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ModuleNotCachedError</code>             \u2013            <p>If the module is not in the cache.</p> </li> </ul>"},{"location":"api/importer/#spoc.core.importer.Importer.clear","title":"<code>clear(name)</code>","text":"<p>Remove a module from the cache.</p> <p>This does not unload the module from sys.modules.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the module to clear.</p> </li> </ul>"},{"location":"api/importer/#spoc.core.importer.Importer.clear_all","title":"<code>clear_all()</code>","text":"<p>Clear all modules from the cache.</p> <p>This does not unload modules from sys.modules.</p>"},{"location":"api/importer/#spoc.core.importer.Importer.unload_all","title":"<code>unload_all()</code>","text":"<p>Completely unload all cached modules from memory.</p> <p>This: 1. Calls teardown() on all initialized modules 2. Removes modules from the cache 3. Removes modules from sys.modules</p> <p>Note: This is generally not recommended in production as it can cause unexpected behavior if other parts of the code still reference the modules.</p>"},{"location":"api/importer/#spoc.core.importer.Importer.startup","title":"<code>startup()</code>","text":"<p>Initialize all registered modules in dependency order.</p> <p>This ensures that modules are initialized only after their dependencies have been initialized.</p> <p>Raises:</p> <ul> <li> <code>CircularDependencyError</code>             \u2013            <p>If there are circular dependencies.</p> </li> <li> <code>LifecycleError</code>             \u2013            <p>If initialization of any module fails.</p> </li> </ul>"},{"location":"api/importer/#spoc.core.importer.Importer.shutdown","title":"<code>shutdown()</code>","text":"<p>Tear down all initialized modules in reverse dependency order.</p> <p>This ensures that modules are torn down only after all modules that depend on them have been torn down.</p> <p>Raises:</p> <ul> <li> <code>LifecycleError</code>             \u2013            <p>If teardown of any module fails.</p> </li> </ul>"},{"location":"api/importer/#spoc.core.importer.Importer.keys","title":"<code>keys()</code>","text":"<p>Get a list of all module names in the cache.</p>"},{"location":"api/importer/#moduleinfo-class","title":"ModuleInfo Class","text":""},{"location":"api/importer/#spoc.core.importer.ModuleInfo","title":"<code>spoc.core.importer.ModuleInfo(name, module, dependencies=None, initialize_func='initialize', teardown_func='teardown')</code>","text":"<p>Information about a dynamically loaded module.</p> <p>Stores metadata and lifecycle hooks for a module.</p> <p>Attributes:</p> <ul> <li> <code>name</code>           \u2013            <p>The module name</p> </li> <li> <code>module</code>           \u2013            <p>The loaded module object</p> </li> <li> <code>dependencies</code>           \u2013            <p>List of module names this module depends on</p> </li> <li> <code>initialize_func</code>           \u2013            <p>Name of the initialization function in the module, or None</p> </li> <li> <code>teardown_func</code>           \u2013            <p>Name of the teardown function in the module, or None</p> </li> <li> <code>initialized</code>           \u2013            <p>Whether the module has been initialized</p> </li> </ul> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The module name.</p> </li> <li> <code>module</code>               (<code>ModuleType</code>)           \u2013            <p>The loaded module object.</p> </li> <li> <code>dependencies</code>               (<code>list[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>List of module names this module depends on.</p> </li> <li> <code>initialize_func</code>               (<code>str | None</code>, default:                   <code>'initialize'</code> )           \u2013            <p>Name of the initialization function in the module, or None.</p> </li> <li> <code>teardown_func</code>               (<code>str | None</code>, default:                   <code>'teardown'</code> )           \u2013            <p>Name of the teardown function in the module, or None.</p> </li> </ul>"},{"location":"api/importer/#spoc.core.importer.ModuleInfo.has_initialize","title":"<code>has_initialize()</code>","text":"<p>Check if the module has an initialize function.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if the module has an initialize function, False otherwise.</p> </li> </ul>"},{"location":"api/importer/#spoc.core.importer.ModuleInfo.has_teardown","title":"<code>has_teardown()</code>","text":"<p>Check if the module has a teardown function.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if the module has a teardown function, False otherwise.</p> </li> </ul>"},{"location":"api/importer/#spoc.core.importer.ModuleInfo.initialize","title":"<code>initialize()</code>","text":"<p>Initialize the module if it has an initialize function.</p> <p>Sets the initialized flag to True after successful initialization.</p>"},{"location":"api/importer/#spoc.core.importer.ModuleInfo.teardown","title":"<code>teardown()</code>","text":"<p>Tear down the module if it has a teardown function.</p> <p>Resets the initialized flag to False after successful teardown.</p>"},{"location":"api/importer/#related-exceptions","title":"Related Exceptions","text":"<p>The Importer may raise the following exceptions:</p> <ul> <li>SpocError - Base exception for all SPOC errors</li> <li>AppNotFoundError - Raised when a module cannot be found</li> <li>ModuleNotCachedError - Raised when accessing a module not in cache</li> <li>CircularDependencyError - Raised when circular dependencies are detected</li> </ul> <p>See Core Utilities for full exception documentation. </p>"},{"location":"api/tools/","title":"Tools","text":"<p>The tools module provides a flexible tool registration and discovery system for Python functions. It enables you to mark functions as discoverable tools with metadata like categories and descriptions, then automatically register and introspect them at runtime.</p>"},{"location":"api/tools/#key-features","title":"Key Features","text":"<ul> <li>Tool Decorator: Mark any function as a tool with optional category and description metadata</li> <li>Automatic Discovery: Scan modules to find all decorated tool functions</li> <li>Rich Metadata: Extract function signatures, parameter types, defaults, and return types</li> <li>Dynamic Registration: Build tool registries at runtime for plugin systems and extensible applications</li> </ul>"},{"location":"api/tools/#use-cases","title":"Use Cases","text":"<p>The tool system is ideal for:</p> <ul> <li>Building plugin architectures where tools can be dynamically discovered</li> <li>Creating command-line interfaces with auto-generated help text</li> <li>Implementing chatbot or AI assistant function calling</li> <li>Organizing utility functions with categorization and documentation</li> </ul>"},{"location":"api/tools/#basic-usage","title":"Basic Usage","text":"<pre><code>from spoc.tools import tool, register_tools\n\n# Simple tool with default category\n@tool\ndef hello():\n    \"\"\"Say hello\"\"\"\n    return \"Hello, world!\"\n\n# Tool with custom category and description\n@tool(category=\"math\", description=\"Add two numbers together\")\ndef add(a: int, b: int) -&gt; int:\n    return a + b\n\n# Register all tools in current module\nimport sys\ntools = register_tools(sys.modules[__name__])\n</code></pre>"},{"location":"api/tools/#spoc.tools","title":"<code>spoc.tools</code>","text":"<p>Generic tools for working with Python modules.</p> <p>This module provides utilities for creating and managing tool functions that can be registered, discovered, and called dynamically.</p>"},{"location":"api/tools/#spoc.tools.tool","title":"<code>tool(func=None, *, category='general', description=None)</code>","text":"<p>Decorator to mark a function as a tool.</p> <p>Parameters:</p> <ul> <li> <code>func</code>               (<code>Optional[F]</code>, default:                   <code>None</code> )           \u2013            <p>The function to mark as a tool</p> </li> <li> <code>category</code>               (<code>str</code>, default:                   <code>'general'</code> )           \u2013            <p>The category this tool belongs to (default: \"general\")</p> </li> <li> <code>description</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>Custom description for the tool (defaults to function docstring)</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Union[F, Callable[[F], F]]</code>           \u2013            <p>The decorated function with tool attributes</p> </li> </ul> Example <p>@tool def my_tool():     '''This is a tool'''     return \"result\"</p> <p>@tool(category=\"math\", description=\"Add two numbers\") def add(a, b):     return a + b</p>"},{"location":"api/tools/#spoc.tools.register_tools","title":"<code>register_tools(module)</code>","text":"<p>Find and register all tool functions in a module.</p> <p>Parameters:</p> <ul> <li> <code>module</code>               (<code>ModuleType</code>)           \u2013            <p>The module containing tool functions</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Dict[str, Dict[str, Any]]</code>           \u2013            <p>A dictionary mapping tool names to their metadata</p> </li> </ul> Example <p>import my_tools tools_dict = register_tools(my_tools)</p>"},{"location":"api/tools/#spoc.tools.get_submodules","title":"<code>get_submodules(module)</code>","text":"<p>Get a list of non-private attributes from a module.</p> <p>Parameters:</p> <ul> <li> <code>module</code>               (<code>ModuleType</code>)           \u2013            <p>The module to inspect</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[str]</code>           \u2013            <p>A list of module attribute names that don't start or end with underscore</p> </li> </ul>"},{"location":"api/workers/","title":"Workers","text":"<p>The workers module provides background task management with support for both thread-based and process-based concurrency strategies. It offers a consistent interface for running tasks in the background with proper lifecycle management, error handling, and graceful shutdown capabilities.</p>"},{"location":"api/workers/#overview","title":"Overview","text":"<p>Workers are designed for running long-running background tasks with different concurrency models:</p> <ul> <li>ThreadWorker: Ideal for I/O-bound tasks that benefit from shared memory access with the main process</li> <li>ProcessWorker: Best for CPU-bound tasks that need to bypass Python's Global Interpreter Lock (GIL)</li> <li>Server: Manages multiple workers collectively with signal handling for graceful shutdowns</li> </ul> <p>All workers share a common lifecycle with <code>setup()</code>, <code>main()</code>, and <code>teardown()</code> hooks, supporting both synchronous and asynchronous implementations. The module also includes utilities for working with async code and optionally integrating uvloop for improved async performance.</p>"},{"location":"api/workers/#api-reference","title":"API Reference","text":""},{"location":"api/workers/#spoc.workers","title":"<code>spoc.workers</code>","text":"<p>Worker module providing different concurrency strategies for background tasks.</p> <p>This module implements various worker classes that can run tasks in different concurrency contexts (threads, processes) with consistent lifecycle management and error handling. It also provides a server to manage multiple workers.</p>"},{"location":"api/workers/#spoc.workers.AbstractWorker","title":"<code>AbstractWorker(name)</code>","text":"<p>Abstract base class for all worker implementations.</p> <p>Provides a consistent interface for different worker types (thread, process) with unified lifecycle management and error handling.</p>"},{"location":"api/workers/#spoc.workers.AbstractWorker.is_running","title":"<code>is_running</code>  <code>property</code>","text":"<p>Return True if the worker is running.</p>"},{"location":"api/workers/#spoc.workers.AbstractWorker.stop","title":"<code>stop()</code>","text":"<p>Signal the worker to stop.</p>"},{"location":"api/workers/#spoc.workers.AbstractWorker.start","title":"<code>start()</code>","text":"<p>Start the worker.</p>"},{"location":"api/workers/#spoc.workers.AbstractWorker.join","title":"<code>join(timeout=None)</code>","text":"<p>Join the worker, with optional timeout.</p>"},{"location":"api/workers/#spoc.workers.AbstractWorker.run","title":"<code>run()</code>","text":"<p>Main run method that handles the worker lifecycle.</p>"},{"location":"api/workers/#spoc.workers.AbstractWorker.setup","title":"<code>setup()</code>","text":"<p>Setup method called before main. Override in subclasses.</p>"},{"location":"api/workers/#spoc.workers.AbstractWorker.main","title":"<code>main()</code>  <code>abstractmethod</code>","text":"<p>Main worker method. Must be implemented by subclasses.</p>"},{"location":"api/workers/#spoc.workers.AbstractWorker.teardown","title":"<code>teardown()</code>","text":"<p>Teardown method called after main. Override in subclasses.</p>"},{"location":"api/workers/#spoc.workers.AbstractWorker.lifecycle","title":"<code>lifecycle(event_type, **data)</code>","text":"<p>Lifecycle event handler. Override in subclasses.</p>"},{"location":"api/workers/#spoc.workers.ThreadWorker","title":"<code>ThreadWorker(name='ThreadWorker', daemon=True)</code>","text":"<p>Worker implementation that runs in a thread.</p> <p>Useful for I/O-bound tasks or tasks that need to share memory with the main process.</p>"},{"location":"api/workers/#spoc.workers.ProcessWorker","title":"<code>ProcessWorker(name='ProcessWorker', daemon=True)</code>","text":"<p>Worker implementation that runs in a separate process.</p> <p>Useful for CPU-bound tasks that benefit from bypassing the GIL.</p>"},{"location":"api/workers/#spoc.workers.Server","title":"<code>Server(name='Server')</code>","text":"<p>Server to manage multiple workers.</p> <p>Provides methods to start, stop, and manage the lifecycle of workers collectively, with proper signal handling for graceful shutdowns.</p>"},{"location":"api/workers/#spoc.workers.Server.add_worker","title":"<code>add_worker(worker)</code>","text":"<p>Add a worker to be managed by this server.</p>"},{"location":"api/workers/#spoc.workers.Server.start","title":"<code>start()</code>","text":"<p>Start all managed workers.</p>"},{"location":"api/workers/#spoc.workers.Server.stop","title":"<code>stop()</code>","text":"<p>Stop all managed workers.</p>"},{"location":"api/workers/#spoc.workers.Server.join_all","title":"<code>join_all(timeout=5)</code>","text":"<p>Join all workers with a shared timeout.</p>"},{"location":"api/workers/#spoc.workers.Server.run_forever","title":"<code>run_forever()</code>","text":"<p>Run the server until stopped by signal or exception.</p>"},{"location":"api/workers/#spoc.workers.set_uvloop_if_available","title":"<code>set_uvloop_if_available()</code>","text":"<p>Set uvloop as the event loop policy if installed.</p>"},{"location":"api/workers/#spoc.workers.run_async_safely","title":"<code>run_async_safely(coro)</code>","text":"<p>Run coroutine safely whether in an existing event loop or not.</p>"},{"location":"core/app-system/","title":"App-Based Architecture","text":"<p>SPOC's app system provides a Django-inspired way to organize your Python applications into self-contained, reusable modules. This guide explains the conceptual foundation of SPOC's app architecture.</p>"},{"location":"core/app-system/#what-are-apps-in-spoc","title":"What Are Apps in SPOC?","text":"<p>In SPOC, an app is a self-contained Python package that encapsulates related functionality. Similar to Django apps, SPOC apps are:</p> <ul> <li>Modular: Each app focuses on a specific domain or feature</li> <li>Self-contained: Apps have their own models, views, services, and logic</li> <li>Reusable: Apps can be shared across projects</li> <li>Isolated: Apps minimize dependencies on other apps</li> <li>Discoverable: SPOC automatically finds and loads configured apps</li> </ul>"},{"location":"core/app-system/#apps-vs-modules","title":"Apps vs. Modules","text":"<p>Understanding the distinction is crucial:</p> <ul> <li>App: A Python package (directory with <code>__init__.py</code>) containing related functionality</li> <li>Module: A Python file (<code>.py</code>) within an app (e.g., <code>models.py</code>, <code>views.py</code>)</li> </ul> <pre><code>apps/blog/          # This is an app\n    \u251c\u2500\u2500 models.py   # This is a module\n    \u251c\u2500\u2500 views.py    # This is a module\n    \u2514\u2500\u2500 services.py # This is a module\n</code></pre>"},{"location":"core/app-system/#app-directory-structure","title":"App Directory Structure","text":"<p>SPOC expects apps to be organized in an <code>apps/</code> directory at the root of your project. The framework automatically adds this directory to Python's import path.</p>"},{"location":"core/app-system/#basic-structure","title":"Basic Structure","text":"<pre><code>myproject/\n\u251c\u2500\u2500 apps/                   # Apps directory (auto-injected into Python path)\n\u2502   \u251c\u2500\u2500 blog/              # Blog app\n\u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502   \u251c\u2500\u2500 models.py      # Data models\n\u2502   \u2502   \u251c\u2500\u2500 views.py       # View functions/classes\n\u2502   \u2502   \u2514\u2500\u2500 services.py    # Business logic\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 users/             # Users app\n\u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502   \u251c\u2500\u2500 models.py\n\u2502   \u2502   \u251c\u2500\u2500 views.py\n\u2502   \u2502   \u2514\u2500\u2500 auth.py        # Custom module\n\u2502   \u2502\n\u2502   \u2514\u2500\u2500 api/               # API app\n\u2502       \u251c\u2500\u2500 __init__.py\n\u2502       \u251c\u2500\u2500 endpoints.py\n\u2502       \u2514\u2500\u2500 serializers.py\n\u2502\n\u251c\u2500\u2500 config/                 # Configuration directory\n\u2502   \u251c\u2500\u2500 settings.py        # Application settings\n\u2502   \u2514\u2500\u2500 spoc.toml          # SPOC configuration\n\u2502\n\u2514\u2500\u2500 main.py                # Application entry point\n</code></pre>"},{"location":"core/app-system/#architecture-diagram","title":"Architecture Diagram","text":"<pre><code>graph TB\n    subgraph \"Project Root\"\n        MAIN[main.py]\n        CONFIG[config/]\n        APPS[apps/]\n    end\n\n    subgraph \"Apps Directory\"\n        BLOG[blog/]\n        USERS[users/]\n        API[api/]\n    end\n\n    subgraph \"Blog App\"\n        BLOG_INIT[__init__.py]\n        BLOG_MODELS[models.py]\n        BLOG_VIEWS[views.py]\n        BLOG_SERVICES[services.py]\n    end\n\n    subgraph \"Users App\"\n        USERS_INIT[__init__.py]\n        USERS_MODELS[models.py]\n        USERS_VIEWS[views.py]\n        USERS_AUTH[auth.py]\n    end\n\n    MAIN --&gt; CONFIG\n    MAIN --&gt; APPS\n    APPS --&gt; BLOG\n    APPS --&gt; USERS\n    APPS --&gt; API\n    BLOG --&gt; BLOG_MODELS\n    BLOG --&gt; BLOG_VIEWS\n    BLOG --&gt; BLOG_SERVICES\n    USERS --&gt; USERS_MODELS\n    USERS --&gt; USERS_VIEWS\n    USERS --&gt; USERS_AUTH\n\n    style APPS fill:#e1f5ff\n    style BLOG fill:#fff4e1\n    style USERS fill:#fff4e1\n    style API fill:#fff4e1</code></pre>"},{"location":"core/app-system/#app-discovery-and-configuration","title":"App Discovery and Configuration","text":"<p>SPOC discovers apps through configuration settings. Apps can be registered in two locations:</p>"},{"location":"core/app-system/#1-python-settings-configsettingspy","title":"1. Python Settings (<code>config/settings.py</code>)","text":"<p>The <code>INSTALLED_APPS</code> list in your settings file defines apps that are always loaded, regardless of environment:</p> <pre><code>\"\"\"Application Settings\"\"\"\n\nfrom pathlib import Path\n\n# Base Directory\nBASE_DIR: Path = Path(__file__).resolve().parent.parent\n\n# Always-installed apps (loaded in all environments)\nINSTALLED_APPS: list = [\n    \"core\",      # Core functionality\n    \"auth\",      # Authentication\n    \"api\",       # API endpoints\n]\n\n# Plugins for extending functionality\nPLUGINS: dict = {\n    \"middleware\": [\"core.middleware\"],\n    \"hooks\": [\"auth.hooks\"],\n}\n</code></pre>"},{"location":"core/app-system/#2-toml-configuration-configspoctoml","title":"2. TOML Configuration (<code>config/spoc.toml</code>)","text":"<p>Environment-specific apps can be defined in <code>spoc.toml</code>:</p> <pre><code>[spoc]\nmode = \"development\"  # Current environment mode\n\n# Apps loaded per environment\n[spoc.apps]\nproduction = [\"analytics\", \"monitoring\"]\nstaging = [\"debugging\"]\ndevelopment = [\"testing_utils\", \"dev_tools\"]\n</code></pre>"},{"location":"core/app-system/#app-loading-order","title":"App Loading Order","text":"<p>SPOC loads apps in a specific order with environment cascading:</p> <pre><code>flowchart LR\n    A[INSTALLED_APPS] --&gt; B[Development Apps]\n    B --&gt; C[Staging Apps]\n    C --&gt; D[Production Apps]\n\n    subgraph \"Development Mode\"\n        A\n        B\n        C\n        D\n    end\n\n    subgraph \"Staging Mode\"\n        A2[INSTALLED_APPS]\n        C2[Staging Apps]\n        D2[Production Apps]\n    end\n\n    subgraph \"Production Mode\"\n        A3[INSTALLED_APPS]\n        D3[Production Apps]\n    end\n\n    style A fill:#4CAF50\n    style B fill:#FFC107\n    style C fill:#FF9800\n    style D fill:#F44336</code></pre> <p>Loading rules:</p> <ol> <li>Development mode: Loads all apps (development \u2192 staging \u2192 production)</li> <li>Staging mode: Loads staging + production apps only</li> <li>Production mode: Loads production apps only</li> <li>INSTALLED_APPS: Always loaded first, regardless of mode</li> </ol> <p>Example:</p> <pre><code># In development mode, this app list is assembled:\n[\n    \"core\",           # From INSTALLED_APPS\n    \"auth\",           # From INSTALLED_APPS\n    \"api\",            # From INSTALLED_APPS\n    \"testing_utils\",  # From [spoc.apps.development]\n    \"dev_tools\",      # From [spoc.apps.development]\n    \"debugging\",      # From [spoc.apps.staging]\n    \"analytics\",      # From [spoc.apps.production]\n    \"monitoring\",     # From [spoc.apps.production]\n]\n</code></pre>"},{"location":"core/app-system/#the-inject_apps-function","title":"The <code>inject_apps()</code> Function","text":"<p>The <code>inject_apps()</code> function is the mechanism that makes app imports work. It adds the <code>apps/</code> directory to Python's <code>sys.path</code>.</p>"},{"location":"core/app-system/#how-it-works","title":"How It Works","text":"<pre><code>def inject_apps(\n    base_dir: Path,\n    apps_dir_name: str = \"apps\",\n    *,\n    position: int = 0\n) -&gt; Path:\n    \"\"\"\n    Ensure an 'apps' directory exists under `base_dir`\n    and inject it into Python's import path.\n    \"\"\"\n    apps_path = base_dir / apps_dir_name\n    ensure_directory(apps_path)\n    add_to_python_path(apps_path, position=position)\n    return apps_path\n</code></pre>"},{"location":"core/app-system/#what-it-does","title":"What It Does","text":"<ol> <li>Creates the apps directory if it doesn't exist</li> <li>Adds the directory to <code>sys.path</code> at the specified position (default: beginning)</li> <li>Returns the path to the apps directory</li> </ol>"},{"location":"core/app-system/#automatic-injection","title":"Automatic Injection","text":"<p>The Framework automatically calls <code>inject_apps()</code> during initialization:</p> <pre><code>class Framework:\n    def __init__(\n        self,\n        base_dir: Path,\n        schema: Schema,\n        echo: bool = False,\n        mode: FrameworkMode = \"strict\",\n    ) -&gt; None:\n        # Inject apps directory into Python path\n        inject_apps(base_dir)\n\n        # ... rest of initialization\n</code></pre>"},{"location":"core/app-system/#import-path-behavior","title":"Import Path Behavior","text":"<p>After <code>inject_apps()</code> runs, apps become importable as top-level packages:</p> <pre><code># Before inject_apps()\n# \u274c Cannot import\nfrom blog.models import Post  # ModuleNotFoundError\n\n# After inject_apps()\n# \u2705 Can import\nfrom blog.models import Post      # Works!\nfrom users.auth import login      # Works!\nfrom api.endpoints import router  # Works!\n</code></pre>"},{"location":"core/app-system/#module-naming-conventions","title":"Module Naming Conventions","text":"<p>SPOC uses a consistent naming pattern for loading modules from apps.</p>"},{"location":"core/app-system/#fully-qualified-module-names","title":"Fully Qualified Module Names","text":"<p>Apps are loaded using the pattern: <code>appname.modulename</code></p> <p>Examples:</p> <pre><code>\"blog.models\"      # models.py in the blog app\n\"blog.views\"       # views.py in the blog app\n\"users.models\"     # models.py in the users app\n\"users.auth\"       # auth.py in the users app\n\"api.endpoints\"    # endpoints.py in the api app\n</code></pre>"},{"location":"core/app-system/#schema-based-loading","title":"Schema-Based Loading","text":"<p>The Framework Schema defines which modules to load from each app:</p> <pre><code>from spoc import Framework, Schema\n\nschema = Schema(\n    # These modules will be loaded from EVERY app\n    modules=[\"models\", \"views\", \"services\"],\n\n    # Module dependencies\n    dependencies={\n        \"views\": [\"models\"],       # views.py depends on models.py\n        \"services\": [\"models\"],    # services.py depends on models.py\n    }\n)\n</code></pre>"},{"location":"core/app-system/#how-it-works_1","title":"How It Works","text":"<p>For each app in <code>INSTALLED_APPS</code>, SPOC attempts to load the specified modules:</p> <pre><code># Given INSTALLED_APPS = [\"blog\", \"users\"]\n# and modules = [\"models\", \"views\"]\n\n# SPOC will try to load:\n\"blog.models\"   # \u2705 apps/blog/models.py\n\"blog.views\"    # \u2705 apps/blog/views.py\n\"users.models\"  # \u2705 apps/users/models.py\n\"users.views\"   # \u2705 apps/users/views.py\n</code></pre>"},{"location":"core/app-system/#strict-vs-loose-mode","title":"Strict vs. Loose Mode","text":"<p>SPOC supports two loading modes:</p> <ul> <li>Strict mode (default): All modules must exist in all apps, or an error is raised</li> <li>Loose mode: Missing modules are skipped without errors</li> </ul> <pre><code># Strict mode - all apps MUST have models.py and views.py\nframework = Framework(\n    base_dir=BASE_DIR,\n    schema=schema,\n    mode=\"strict\"  # Default\n)\n\n# Loose mode - apps without models.py or views.py are OK\nframework = Framework(\n    base_dir=BASE_DIR,\n    schema=schema,\n    mode=\"loose\"\n)\n</code></pre>"},{"location":"core/app-system/#app-isolation-and-reusability","title":"App Isolation and Reusability","text":"<p>Designing apps for isolation and reusability is a core principle in SPOC.</p>"},{"location":"core/app-system/#isolation-principles","title":"Isolation Principles","text":"<p>1. Minimize Cross-App Dependencies</p> <p>Apps should be as self-contained as possible:</p> <pre><code># \u274c Bad: Direct import from another app\n# In apps/blog/views.py\nfrom users.models import User  # Tight coupling!\n\n# \u2705 Good: Use dependency injection or interfaces\n# In apps/blog/views.py\ndef create_post(user_service):\n    \"\"\"Create a post using an injected user service.\"\"\"\n    user = user_service.get_user(user_id=1)\n    # ... create post\n</code></pre> <p>2. Use Components for Discoverability</p> <p>Instead of direct imports, use SPOC's component system:</p> <pre><code># In apps/users/models.py\nfrom spoc import Components\n\ncomponents = Components()\ncomponents.add_type(\"model\")\n\n@components.register(\"model\")\nclass User:\n    \"\"\"User model.\"\"\"\n    id: int\n    username: str\n</code></pre> <pre><code># In apps/blog/services.py\n# Access via the framework's component registry\ndef create_post(framework, user_id: int):\n    \"\"\"Create a post for a user.\"\"\"\n    # Get the User component from the registry\n    User = framework.get_component(\"model\", \"User\")\n    user = User(id=user_id, username=\"john\")\n    # ... rest of logic\n</code></pre> <p>3. Clear Boundaries</p> <p>Each app should have a well-defined purpose:</p> <pre><code>apps/\n\u251c\u2500\u2500 auth/          # Authentication and authorization only\n\u251c\u2500\u2500 blog/          # Blog posts and comments only\n\u251c\u2500\u2500 users/         # User profiles and management only\n\u2514\u2500\u2500 notifications/ # Notification system only\n</code></pre>"},{"location":"core/app-system/#reusability-strategies","title":"Reusability Strategies","text":"<p>1. Generic App Design</p> <p>Design apps to be context-independent:</p> <pre><code># apps/notifications/services.py\n\"\"\"Generic notification service - works in any project.\"\"\"\n\ndef send_notification(user_id: int, message: str, channel: str = \"email\"):\n    \"\"\"Send a notification to a user.\"\"\"\n    # This doesn't know about blogs, e-commerce, etc.\n    # It's a generic notification service\n    pass\n</code></pre> <p>2. Configuration-Driven Behavior</p> <p>Use settings to customize app behavior:</p> <pre><code># config/settings.py\nNOTIFICATION_CHANNELS = [\"email\", \"sms\", \"push\"]\nNOTIFICATION_TEMPLATES_DIR = BASE_DIR / \"templates\" / \"notifications\"\n</code></pre> <pre><code># apps/notifications/services.py\nfrom config import settings\n\ndef get_available_channels():\n    \"\"\"Get configured notification channels.\"\"\"\n    return settings.NOTIFICATION_CHANNELS\n</code></pre> <p>3. App-Specific Settings</p> <p>Apps can define their own configuration:</p> <pre><code># apps/blog/settings.py\n\"\"\"Blog app configuration.\"\"\"\n\nMAX_POST_LENGTH = 10000\nPOSTS_PER_PAGE = 20\nALLOW_COMMENTS = True\nCOMMENT_MODERATION = False\n</code></pre>"},{"location":"core/app-system/#best-practices-for-organizing-apps","title":"Best Practices for Organizing Apps","text":""},{"location":"core/app-system/#1-single-responsibility-principle","title":"1. Single Responsibility Principle","text":"<p>Each app should have one clear purpose:</p> <pre><code>\u2705 Good:\napps/\n\u251c\u2500\u2500 authentication/  # User login, logout, password reset\n\u251c\u2500\u2500 blog/           # Blog posts and comments\n\u2514\u2500\u2500 analytics/      # Usage tracking and reporting\n\n\u274c Bad:\napps/\n\u2514\u2500\u2500 everything/     # Users, posts, comments, analytics, etc.\n</code></pre>"},{"location":"core/app-system/#2-consistent-module-structure","title":"2. Consistent Module Structure","text":"<p>Use consistent naming across apps:</p> <pre><code>apps/\n\u251c\u2500\u2500 blog/\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 models.py      # Data models\n\u2502   \u251c\u2500\u2500 views.py       # Request handlers\n\u2502   \u251c\u2500\u2500 services.py    # Business logic\n\u2502   \u2514\u2500\u2500 utils.py       # Helper functions\n\u2502\n\u2514\u2500\u2500 users/\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 models.py      # Data models (same structure)\n    \u251c\u2500\u2500 views.py       # Request handlers\n    \u251c\u2500\u2500 services.py    # Business logic\n    \u2514\u2500\u2500 utils.py       # Helper functions\n</code></pre>"},{"location":"core/app-system/#3-app-dependencies-in-schema","title":"3. App Dependencies in Schema","text":"<p>Declare dependencies explicitly in your schema:</p> <pre><code>schema = Schema(\n    modules=[\"models\", \"views\", \"services\"],\n    dependencies={\n        \"views\": [\"models\"],           # views need models\n        \"services\": [\"models\"],        # services need models\n    }\n)\n</code></pre>"},{"location":"core/app-system/#4-use-__init__py-for-public-api","title":"4. Use <code>__init__.py</code> for Public API","text":"<p>Expose only what's needed:</p> <pre><code># apps/blog/__init__.py\n\"\"\"Blog app public API.\"\"\"\n\nfrom .models import Post, Comment\nfrom .services import create_post, delete_post\n\n__all__ = [\n    \"Post\",\n    \"Comment\",\n    \"create_post\",\n    \"delete_post\",\n]\n</code></pre>"},{"location":"core/app-system/#5-documentation-in-each-app","title":"5. Documentation in Each App","text":"<p>Document app purpose and usage:</p> <pre><code># apps/blog/__init__.py\n\"\"\"\nBlog App\n========\n\nProvides blog post and comment functionality.\n\nComponents:\n    - Post model: Blog post data\n    - Comment model: Comment data\n    - create_post(): Create new posts\n    - delete_post(): Delete posts\n\nDependencies:\n    - users app (for authentication)\n\nConfiguration:\n    - MAX_POST_LENGTH: Maximum post length\n    - ALLOW_COMMENTS: Enable/disable comments\n\"\"\"\n</code></pre>"},{"location":"core/app-system/#6-testing-strategy","title":"6. Testing Strategy","text":"<p>Each app should have its own tests:</p> <pre><code>tests/\n\u251c\u2500\u2500 test_blog.py       # Tests for blog app\n\u251c\u2500\u2500 test_users.py      # Tests for users app\n\u2514\u2500\u2500 test_api.py        # Tests for api app\n</code></pre>"},{"location":"core/app-system/#7-environment-specific-apps","title":"7. Environment-Specific Apps","text":"<p>Use TOML configuration for environment-specific apps:</p> <pre><code>[spoc.apps]\nproduction = [\n    \"monitoring\",    # Only in production\n    \"analytics\",     # Only in production\n]\n\ndevelopment = [\n    \"debug_toolbar\", # Only in development\n    \"test_data\",     # Only in development\n]\n</code></pre>"},{"location":"core/app-system/#complete-example","title":"Complete Example","text":"<p>Here's a complete example showing the app system in action:</p>"},{"location":"core/app-system/#project-structure","title":"Project Structure","text":"<pre><code>myproject/\n\u251c\u2500\u2500 apps/\n\u2502   \u251c\u2500\u2500 users/\n\u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502   \u2514\u2500\u2500 models.py\n\u2502   \u2502\n\u2502   \u2514\u2500\u2500 blog/\n\u2502       \u251c\u2500\u2500 __init__.py\n\u2502       \u251c\u2500\u2500 models.py\n\u2502       \u251c\u2500\u2500 views.py\n\u2502       \u2514\u2500\u2500 services.py\n\u2502\n\u251c\u2500\u2500 config/\n\u2502   \u251c\u2500\u2500 settings.py\n\u2502   \u2514\u2500\u2500 spoc.toml\n\u2502\n\u2514\u2500\u2500 main.py\n</code></pre>"},{"location":"core/app-system/#configuration","title":"Configuration","text":"<pre><code># config/settings.py\nfrom pathlib import Path\n\nBASE_DIR: Path = Path(__file__).resolve().parent.parent\n\nINSTALLED_APPS: list = [\n    \"users\",\n    \"blog\",\n]\n\nPLUGINS: dict = {\n    \"middleware\": [],\n    \"hooks\": [],\n}\n</code></pre> <pre><code># config/spoc.toml\n[spoc]\nmode = \"development\"\n</code></pre>"},{"location":"core/app-system/#app-implementation","title":"App Implementation","text":"<pre><code># apps/users/models.py\n\"\"\"User models.\"\"\"\n\nimport dataclasses as dc\nfrom spoc import Components\n\ncomponents = Components()\ncomponents.add_type(\"model\")\n\n@dc.dataclass\n@components.register(\"model\")\nclass User:\n    \"\"\"User model.\"\"\"\n    id: int\n    username: str\n    email: str\n</code></pre> <pre><code># apps/blog/models.py\n\"\"\"Blog models.\"\"\"\n\nimport dataclasses as dc\nfrom spoc import Components\n\ncomponents = Components()\ncomponents.add_type(\"model\")\n\n@dc.dataclass\n@components.register(\"model\")\nclass Post:\n    \"\"\"Blog post model.\"\"\"\n    id: int\n    title: str\n    content: str\n    author_id: int\n</code></pre> <pre><code># apps/blog/views.py\n\"\"\"Blog views.\"\"\"\n\nfrom spoc import Components\n\ncomponents = Components()\ncomponents.add_type(\"view\")\n\n@components.register(\"view\")\ndef list_posts():\n    \"\"\"List all blog posts.\"\"\"\n    return {\"action\": \"list_posts\"}\n\n@components.register(\"view\")\ndef create_post():\n    \"\"\"Create a new blog post.\"\"\"\n    return {\"action\": \"create_post\"}\n</code></pre> <pre><code># apps/blog/services.py\n\"\"\"Blog business logic.\"\"\"\n\nfrom spoc import Components\n\ncomponents = Components()\ncomponents.add_type(\"service\")\n\n@components.register(\"service\")\nclass PostService:\n    \"\"\"Service for managing blog posts.\"\"\"\n\n    def create_post(self, title: str, content: str, author_id: int):\n        \"\"\"Create a new blog post.\"\"\"\n        # Business logic here\n        return {\"title\": title, \"content\": content, \"author_id\": author_id}\n\n    def delete_post(self, post_id: int):\n        \"\"\"Delete a blog post.\"\"\"\n        # Business logic here\n        return {\"deleted\": post_id}\n</code></pre>"},{"location":"core/app-system/#application-entry-point","title":"Application Entry Point","text":"<pre><code># main.py\n\"\"\"Main application entry point.\"\"\"\n\nfrom pathlib import Path\nfrom spoc import Framework, Schema\n\nBASE_DIR = Path(__file__).resolve().parent\n\n# Define schema\nschema = Schema(\n    modules=[\"models\", \"views\", \"services\"],\n    dependencies={\n        \"views\": [\"models\"],\n        \"services\": [\"models\"],\n    }\n)\n\n# Initialize framework\nframework = Framework(\n    base_dir=BASE_DIR,\n    schema=schema,\n    echo=True,\n    mode=\"strict\"\n)\n\n# Access components\nprint(\"Installed apps:\", framework.installed_apps)\n# Output: ['users', 'blog']\n\n# Get a specific component\nPost = framework.get_component(\"model\", \"Post\")\nprint(f\"Post component: {Post}\")\n\n# Shutdown when done\nframework.shutdown()\n</code></pre>"},{"location":"core/app-system/#summary","title":"Summary","text":"<p>SPOC's app-based architecture provides:</p> <ol> <li>Clear Organization: Apps group related functionality</li> <li>Automatic Discovery: Framework finds and loads apps from configuration</li> <li>Path Injection: <code>inject_apps()</code> makes apps importable</li> <li>Naming Conventions: Consistent <code>appname.modulename</code> pattern</li> <li>Isolation: Apps are self-contained with minimal coupling</li> <li>Reusability: Apps can be shared across projects</li> <li>Environment Control: Load different apps per environment</li> </ol> <p>By following these patterns and best practices, you can build maintainable, scalable applications with SPOC's app system.</p>"},{"location":"core/app-system/#next-steps","title":"Next Steps","text":"<ul> <li>Quick Start Guide - Build your first SPOC app</li> <li>Configuration Guide - Learn about settings and TOML config</li> <li>Components API - Component registration and discovery</li> <li>Framework API - Framework lifecycle and management</li> </ul>"},{"location":"core/components/","title":"Components","text":"<p>SPOC's component system provides a flexible, metadata-driven approach to organizing and managing classes and functions in your application. Components are the fundamental building blocks that enable SPOC's modular architecture.</p>"},{"location":"core/components/#what-are-components","title":"What Are Components?","text":"<p>Components are classes or functions that have been tagged with metadata using decorators. This metadata allows SPOC to:</p> <ul> <li>Identify and categorize different types of objects (models, views, services, etc.)</li> <li>Attach configuration data to components</li> <li>Discover components automatically from modules</li> <li>Organize components into registries for easy access</li> </ul> <p>Think of components as annotated objects that SPOC can recognize and work with systematically.</p>"},{"location":"core/components/#the-component-decorator","title":"The @component Decorator","text":"<p>The <code>@component</code> decorator is the simplest way to mark an object as a SPOC component. It attaches metadata to your classes or functions without changing their behavior.</p>"},{"location":"core/components/#basic-usage","title":"Basic Usage","text":"<pre><code>from spoc.components import component\n\n@component\nclass User:\n    def __init__(self, name):\n        self.name = name\n</code></pre> <p>This creates a component with empty configuration and metadata dictionaries.</p>"},{"location":"core/components/#with-configuration-and-metadata","title":"With Configuration and Metadata","text":"<p>You can attach configuration and metadata when decorating:</p> <pre><code>@component(\n    config={\"database\": \"users_db\", \"timeout\": 30},\n    metadata={\"type\": \"model\", \"version\": \"1.0\"}\n)\nclass User:\n    def __init__(self, name):\n        self.name = name\n</code></pre> <ul> <li>config: Runtime configuration for the component (database settings, timeouts, etc.)</li> <li>metadata: Descriptive information about the component (type, version, tags, etc.)</li> </ul>"},{"location":"core/components/#direct-application","title":"Direct Application","text":"<p>You can also apply the decorator directly to an existing object:</p> <pre><code>class Product:\n    pass\n\nProduct = component(Product, config={\"cache\": True})\n</code></pre>"},{"location":"core/components/#how-it-works","title":"How It Works","text":"<p>The <code>@component</code> decorator attaches an <code>__spoc__</code> attribute to the decorated object containing an <code>Internal</code> dataclass with your config and metadata:</p> <pre><code>@component(config={\"key\": \"value\"})\nclass MyClass:\n    pass\n\nprint(MyClass.__spoc__)\n# Internal(config={'key': 'value'}, metadata={})\n</code></pre>"},{"location":"core/components/#the-components-registry","title":"The Components Registry","text":"<p>The <code>Components</code> class provides a registry for managing different types of components with type-specific validation and metadata.</p>"},{"location":"core/components/#creating-a-registry","title":"Creating a Registry","text":"<p>Initialize a registry by specifying the component types you want to work with:</p> <pre><code>from spoc.components import Components\n\ncomponents = Components(\"model\", \"view\", \"service\")\n</code></pre> <p>This creates a registry that can manage three types of components: models, views, and services.</p>"},{"location":"core/components/#registering-components","title":"Registering Components","text":"<p>Use the <code>register()</code> method to tag components with a specific type:</p> <pre><code>@components.register(\"model\")\nclass User:\n    def __init__(self, name):\n        self.name = name\n\n@components.register(\"service\", config={\"timeout\": 60})\nclass UserService:\n    def __init__(self, user_model):\n        self.model = user_model\n</code></pre> <p>The registry automatically:</p> <ul> <li>Adds <code>{\"type\": \"model\"}</code> to the component's metadata</li> <li>Validates that the type was declared during registry initialization</li> <li>Stores any additional configuration you provide</li> </ul>"},{"location":"core/components/#type-checking","title":"Type Checking","text":"<p>Check if an object is a component of a specific type:</p> <pre><code>@components.register(\"model\")\nclass User:\n    pass\n\n@components.register(\"view\")\nclass UserView:\n    pass\n\n# Check component types\ncomponents.is_component(\"model\", User)      # True\ncomponents.is_component(\"view\", User)       # False\ncomponents.is_component(\"model\", UserView)  # False\n\n# Check if any SPOC component\ncomponents.is_spoc(User)      # True\ncomponents.is_spoc(object())  # False\n</code></pre>"},{"location":"core/components/#adding-types-dynamically","title":"Adding Types Dynamically","text":"<p>Add new component types to an existing registry:</p> <pre><code>components = Components(\"model\")\n\n# Add a new type with default metadata\ncomponents.add_type(\"command\", default_meta={\"async\": True})\n\n@components.register(\"command\")\nclass SyncUsersCommand:\n    pass\n\n# The command now has both type and default metadata\ninfo = components.get_info(SyncUsersCommand)\nprint(info.metadata)\n# {'type': 'command', 'async': True}\n</code></pre>"},{"location":"core/components/#building-component-objects","title":"Building Component Objects","text":"<p>The <code>builder()</code> method creates a structured <code>Component</code> object from a decorated component:</p> <pre><code>@components.register(\"model\")\nclass User:\n    pass\n\ncomponent_obj = components.builder(User)\n\nprint(component_obj.type)      # \"model\"\nprint(component_obj.name)      # \"User\"\nprint(component_obj.app)       # Module name (e.g., \"myapp\")\nprint(component_obj.uri)       # \"myapp_user\"\nprint(component_obj.object)    # The User class itself\nprint(component_obj.internal)  # Internal(config={}, metadata={'type': 'model'})\n</code></pre> <p>The <code>Component</code> object provides a complete view of the component with all its metadata in a structured format.</p>"},{"location":"core/components/#component-and-internal-dataclasses","title":"Component and Internal Dataclasses","text":"<p>SPOC uses two dataclasses to store component information:</p>"},{"location":"core/components/#internal","title":"Internal","text":"<p>Stores the raw metadata attached to a component:</p> <pre><code>from spoc.components import Internal\n\ninternal = Internal(\n    config={\"database\": \"users_db\"},\n    metadata={\"type\": \"model\", \"version\": \"1.0\"}\n)\n</code></pre> <p>Attributes:</p> <ul> <li><code>config</code>: Dictionary of configuration data</li> <li><code>metadata</code>: Dictionary of metadata</li> </ul> <p>This is what gets attached to your component as the <code>__spoc__</code> attribute.</p>"},{"location":"core/components/#component","title":"Component","text":"<p>Represents a complete component with context:</p> <pre><code>from spoc.components import Component, Internal\n\ncomponent = Component(\n    type=\"model\",\n    uri=\"myapp_user\",\n    app=\"myapp\",\n    name=\"User\",\n    object=User,  # The actual class\n    internal=Internal(config={}, metadata={\"type\": \"model\"})\n)\n</code></pre> <p>Attributes:</p> <ul> <li><code>type</code>: Component type identifier (e.g., \"model\", \"view\")</li> <li><code>uri</code>: Unique resource identifier (app_name in snake_case)</li> <li><code>app</code>: Application/module name the component belongs to</li> <li><code>name</code>: Component class/function name</li> <li><code>object</code>: The actual component object (class or function)</li> <li><code>internal</code>: The Internal dataclass with config and metadata</li> </ul>"},{"location":"core/components/#discovering-components-from-modules","title":"Discovering Components from Modules","text":"<p>SPOC automatically discovers components when modules are loaded through the framework. The Importer class scans module attributes looking for objects with the <code>__spoc__</code> attribute.</p>"},{"location":"core/components/#how-discovery-works","title":"How Discovery Works","text":"<p>When a module is loaded:</p> <ol> <li>The Importer scans all public attributes (not starting/ending with <code>_</code>)</li> <li>For each attribute with <code>__spoc__</code>, it extracts the type from metadata</li> <li>Components are organized by type and stored with their fully-qualified name</li> </ol> <p>For example, in <code>myapp/models.py</code>:</p> <pre><code>from spoc.components import component\n\n@component(metadata={\"type\": \"model\"})\nclass User:\n    pass\n\n@component(metadata={\"type\": \"model\"})\nclass Product:\n    pass\n</code></pre> <p>After loading, SPOC stores:</p> <pre><code>{\n    \"model\": {\n        \"myapp.User\": User,\n        \"myapp.Product\": Product\n    }\n}\n</code></pre>"},{"location":"core/components/#framework-integration","title":"Framework Integration","text":"<p>The Framework class coordinates component loading and provides runtime access to discovered components.</p>"},{"location":"core/components/#how-framework-loads-components","title":"How Framework Loads Components","text":"<p>When you start a SPOC application:</p> <pre><code>from pathlib import Path\nfrom spoc.framework import Framework, Schema\n\nschema = Schema(\n    modules=[\"models\", \"views\", \"services\"],\n    dependencies={\"views\": [\"models\"], \"services\": [\"models\"]},\n    hooks={}\n)\n\nframework = Framework(\n    base_dir=Path(\"/path/to/myapp\"),\n    schema=schema\n)\n</code></pre> <p>The framework:</p> <ol> <li>Registers all installed apps and their modules</li> <li>Loads modules in dependency order</li> <li>Discovers components in each module</li> <li>Organizes components by type (models, views, services)</li> <li>Makes them available through <code>framework.components</code></li> </ol>"},{"location":"core/components/#component-organization","title":"Component Organization","text":"<p>Components are organized hierarchically:</p> <pre><code>framework.components\n\u251c\u2500\u2500 models\n\u2502   \u251c\u2500\u2500 myapp.User\n\u2502   \u2514\u2500\u2500 myapp.Product\n\u251c\u2500\u2500 views\n\u2502   \u251c\u2500\u2500 myapp.UserView\n\u2502   \u2514\u2500\u2500 myapp.ProductView\n\u2514\u2500\u2500 services\n    \u2514\u2500\u2500 myapp.UserService\n</code></pre>"},{"location":"core/components/#accessing-components-at-runtime","title":"Accessing Components at Runtime","text":"<p>Once the framework has started, you can access discovered components in several ways.</p>"},{"location":"core/components/#through-the-framework","title":"Through the Framework","text":"<p>Access components via the <code>components</code> namespace:</p> <pre><code># Get all models\nall_models = framework.components.models\n\n# Access a specific component by fully-qualified name\nuser_model = framework.components.models.get(\"myapp.User\")\n</code></pre>"},{"location":"core/components/#using-get_component","title":"Using get_component()","text":"<p>The framework provides a convenience method:</p> <pre><code># Get a specific component by type and name\nuser_model = framework.get_component(\"model\", \"myapp.User\")\n</code></pre>"},{"location":"core/components/#direct-component-access","title":"Direct Component Access","text":"<p>Components are regular Python objects, so you can import and use them normally:</p> <pre><code>from myapp.models import User\n\n# Create an instance\nuser = User(name=\"Alice\")\n</code></pre> <p>The component metadata is always accessible through the <code>__spoc__</code> attribute:</p> <pre><code>from myapp.models import User\n\nprint(User.__spoc__.config)\nprint(User.__spoc__.metadata)\n</code></pre>"},{"location":"core/components/#practical-examples","title":"Practical Examples","text":""},{"location":"core/components/#example-1-multi-tier-application","title":"Example 1: Multi-Tier Application","text":"<p>Organize components by architectural layer:</p> <pre><code>from spoc.components import Components\n\n# Define component types\ncomponents = Components(\"model\", \"repository\", \"service\", \"controller\")\n\n# Data layer\n@components.register(\"model\")\nclass User:\n    def __init__(self, id, name, email):\n        self.id = id\n        self.name = name\n        self.email = email\n\n# Repository layer\n@components.register(\"repository\", config={\"database\": \"postgres\"})\nclass UserRepository:\n    def find_by_id(self, user_id):\n        # Database logic here\n        pass\n\n# Service layer\n@components.register(\"service\", config={\"cache\": True})\nclass UserService:\n    def __init__(self, repository):\n        self.repository = repository\n\n    def get_user(self, user_id):\n        return self.repository.find_by_id(user_id)\n\n# Controller layer\n@components.register(\"controller\")\nclass UserController:\n    def __init__(self, service):\n        self.service = service\n</code></pre>"},{"location":"core/components/#example-2-plugin-system","title":"Example 2: Plugin System","text":"<p>Use components to create a plugin system:</p> <pre><code>from spoc.components import Components\n\nplugins = Components(\"plugin\")\nplugins.add_type(\"plugin\", default_meta={\"enabled\": True})\n\n@plugins.register(\"plugin\", config={\"priority\": 10})\nclass AuthenticationPlugin:\n    def process(self, request):\n        # Authentication logic\n        pass\n\n@plugins.register(\"plugin\", config={\"priority\": 20})\nclass LoggingPlugin:\n    def process(self, request):\n        # Logging logic\n        pass\n\n# Sort plugins by priority\nall_plugins = plugins.get_info(...)\nsorted_plugins = sorted(\n    all_plugins,\n    key=lambda p: p.config.get(\"priority\", 0)\n)\n</code></pre>"},{"location":"core/components/#example-3-feature-flags","title":"Example 3: Feature Flags","text":"<p>Use component metadata for feature management:</p> <pre><code>from spoc.components import component\n\n@component(\n    config={\"enabled\": True},\n    metadata={\"feature\": \"new_dashboard\", \"version\": \"2.0\"}\n)\nclass NewDashboardView:\n    def render(self):\n        if not self.__spoc__.config.get(\"enabled\"):\n            raise FeatureDisabledError(\"Dashboard v2 is disabled\")\n        # Render dashboard\n        pass\n</code></pre>"},{"location":"core/components/#best-practices","title":"Best Practices","text":""},{"location":"core/components/#1-use-meaningful-type-names","title":"1. Use Meaningful Type Names","text":"<p>Choose component type names that reflect your architecture:</p> <pre><code># Good - clear architectural meaning\nComponents(\"model\", \"view\", \"controller\", \"service\")\n\n# Avoid - vague or inconsistent\nComponents(\"thing\", \"stuff\", \"MyComponents\")\n</code></pre>"},{"location":"core/components/#2-keep-configuration-separate-from-code","title":"2. Keep Configuration Separate from Code","text":"<p>Store configuration in config dictionaries, not hardcoded:</p> <pre><code># Good\n@components.register(\"service\", config={\"timeout\": 30, \"retry\": 3})\nclass APIService:\n    def __init__(self):\n        config = self.__spoc__.config\n        self.timeout = config.get(\"timeout\")\n        self.retry = config.get(\"retry\")\n\n# Avoid\n@components.register(\"service\")\nclass APIService:\n    def __init__(self):\n        self.timeout = 30  # Hardcoded\n        self.retry = 3\n</code></pre>"},{"location":"core/components/#3-use-metadata-for-descriptive-information","title":"3. Use Metadata for Descriptive Information","text":"<p>Metadata should describe the component, not configure it:</p> <pre><code># Good - descriptive metadata, runtime config\n@component(\n    config={\"database\": \"users\"},\n    metadata={\"type\": \"model\", \"version\": \"2.0\", \"author\": \"team-backend\"}\n)\nclass User:\n    pass\n\n# Avoid - mixing runtime config with metadata\n@component(\n    metadata={\"type\": \"model\", \"database\": \"users\"}  # Don't put config in metadata\n)\nclass User:\n    pass\n</code></pre>"},{"location":"core/components/#4-validate-component-types","title":"4. Validate Component Types","text":"<p>Always declare component types before using them:</p> <pre><code># Good\ncomponents = Components(\"model\", \"service\")\n\n@components.register(\"model\")\nclass User:\n    pass\n\n# This will raise KeyError - type not declared\n@components.register(\"repository\")  # KeyError!\nclass UserRepo:\n    pass\n</code></pre>"},{"location":"core/components/#5-use-uris-for-component-identification","title":"5. Use URIs for Component Identification","text":"<p>The component URI provides a stable identifier:</p> <pre><code>components = Components(\"model\")\n\n@components.register(\"model\")\nclass User:\n    pass\n\ncomp = components.builder(User)\n# Use the URI as a stable key\ncomponent_map = {comp.uri: comp}  # {\"myapp_user\": Component(...)}\n</code></pre>"},{"location":"core/components/#summary","title":"Summary","text":"<p>SPOC's component system provides:</p> <ul> <li>Simple decoration: Tag classes/functions with <code>@component</code></li> <li>Type-safe registries: Organize components by type with <code>Components</code></li> <li>Rich metadata: Attach configuration and descriptive information</li> <li>Automatic discovery: Components are found and loaded automatically</li> <li>Framework integration: Access components at runtime through the framework</li> <li>Flexibility: Use components for any organizational pattern you need</li> </ul> <p>By leveraging components, you can build modular, organized applications where SPOC handles the tedious work of discovering, organizing, and providing access to your application's building blocks.</p>"},{"location":"core/dependencies/","title":"Dependency Management","text":"<p>SPOC's dependency management system ensures modules are loaded in the correct order, preventing initialization failures and runtime errors. This guide explains how SPOC resolves dependencies, detects circular dependencies, and provides best practices for structuring your application.</p>"},{"location":"core/dependencies/#why-dependency-management-matters","title":"Why Dependency Management Matters","text":"<p>In modular applications, components often depend on each other. For example:</p> <ul> <li>Views depend on models being loaded first</li> <li>Services depend on database connections being established</li> <li>API handlers depend on authentication middleware</li> </ul> <p>Without proper dependency management, you might encounter:</p> <ul> <li>Initialization Errors: Accessing undefined modules or resources</li> <li>Runtime Failures: Missing dependencies causing crashes</li> <li>Unpredictable Behavior: Different initialization order in different runs</li> </ul> <p>SPOC's dependency graph ensures deterministic, correct initialization order automatically.</p>"},{"location":"core/dependencies/#defining-dependencies-in-schema","title":"Defining Dependencies in Schema","text":"<p>Dependencies are declared in the <code>Schema</code> object when creating your framework:</p> <pre><code>from spoc import Framework, Schema\nfrom pathlib import Path\n\nschema = Schema(\n    # List all modules to load\n    modules=[\"models\", \"views\", \"services\"],\n\n    # Define dependencies between modules\n    dependencies={\n        \"views\": [\"models\"],         # views depends on models\n        \"services\": [\"models\", \"views\"]  # services depends on both\n    }\n)\n\nframework = Framework(\n    base_dir=Path(__file__).parent,\n    schema=schema\n)\n</code></pre>"},{"location":"core/dependencies/#dependency-rules","title":"Dependency Rules","text":"<ol> <li>Key: The module that has dependencies</li> <li>Value: List of modules it depends on</li> <li>Resolution: SPOC loads dependencies before dependents</li> <li>Transitive: Dependencies are resolved recursively</li> </ol>"},{"location":"core/dependencies/#how-dependency-resolution-works","title":"How Dependency Resolution Works","text":"<p>SPOC uses a Directed Acyclic Graph (DAG) with topological sorting to determine the correct initialization order.</p>"},{"location":"core/dependencies/#example-three-module-system","title":"Example: Three-Module System","text":"<pre><code>schema = Schema(\n    modules=[\"models\", \"views\", \"services\"],\n    dependencies={\n        \"views\": [\"models\"],\n        \"services\": [\"models\", \"views\"]\n    }\n)\n</code></pre> <p>Dependency Graph:</p> <pre><code>graph LR\n    models[models] --&gt; views[views]\n    models --&gt; services[services]\n    views --&gt; services\n\n    style models fill:#e1f5ff\n    style views fill:#fff4e1\n    style services fill:#ffe1f5</code></pre> <p>Initialization Order:</p> <pre><code>sequenceDiagram\n    participant Framework\n    participant Models\n    participant Views\n    participant Services\n\n    Framework-&gt;&gt;Models: 1. Load &amp; Initialize\n    Models--&gt;&gt;Framework: Ready\n    Framework-&gt;&gt;Views: 2. Load &amp; Initialize\n    Views--&gt;&gt;Framework: Ready\n    Framework-&gt;&gt;Services: 3. Load &amp; Initialize\n    Services--&gt;&gt;Framework: Ready\n\n    Note over Framework: All modules loaded in correct order</code></pre> <p>Result: <code>models</code> \u2192 <code>views</code> \u2192 <code>services</code></p>"},{"location":"core/dependencies/#the-dependencygraph-class","title":"The DependencyGraph Class","text":"<p>SPOC's dependency resolution is powered by the <code>DependencyGraph</code> class in <code>spoc.core.utils</code>.</p>"},{"location":"core/dependencies/#core-methods","title":"Core Methods","text":""},{"location":"core/dependencies/#add_nodenode","title":"<code>add_node(node)</code>","text":"<p>Adds a node to the graph representing a module.</p> <pre><code>from spoc.core.utils import DependencyGraph\n\ngraph = DependencyGraph[str]()\ngraph.add_node(\"models\")\ngraph.add_node(\"views\")\n</code></pre>"},{"location":"core/dependencies/#add_edgefrom_node-to_node","title":"<code>add_edge(from_node, to_node)</code>","text":"<p>Creates a directed edge from one node to another, indicating that <code>to_node</code> depends on <code>from_node</code>.</p> <pre><code># views depends on models\ngraph.add_edge(\"models\", \"views\")\n\n# services depends on both models and views\ngraph.add_edge(\"models\", \"services\")\ngraph.add_edge(\"views\", \"services\")\n</code></pre>"},{"location":"core/dependencies/#topological_sort","title":"<code>topological_sort()</code>","text":"<p>Performs topological sort to determine initialization order.</p> <pre><code># Returns modules in dependency order\norder = graph.topological_sort()\n# Result: [\"models\", \"views\", \"services\"]\n</code></pre> <p>Algorithm: Uses Kahn's algorithm with in-degree calculation.</p> <p>Time Complexity: O(V + E) where V = vertices (modules), E = edges (dependencies)</p>"},{"location":"core/dependencies/#reversed","title":"<code>reversed()</code>","text":"<p>Creates a new graph with all edges reversed, used for shutdown order.</p> <pre><code># Reverse the graph for shutdown\nshutdown_graph = graph.reversed()\nshutdown_order = shutdown_graph.topological_sort()\n# Result: [\"services\", \"views\", \"models\"]\n</code></pre>"},{"location":"core/dependencies/#circular-dependency-detection","title":"Circular Dependency Detection","text":"<p>SPOC automatically detects circular dependencies and raises <code>CircularDependencyError</code> with a detailed error message.</p>"},{"location":"core/dependencies/#example-circular-dependency","title":"Example: Circular Dependency","text":"<pre><code>schema = Schema(\n    modules=[\"models\", \"views\", \"services\"],\n    dependencies={\n        \"views\": [\"models\"],\n        \"models\": [\"services\"],  # Creates a cycle!\n        \"services\": [\"views\"]\n    }\n)\n\n# This will raise CircularDependencyError\nframework = Framework(base_dir=Path(\".\"), schema=schema)\n</code></pre> <p>Problem Visualization:</p> <pre><code>graph LR\n    models[models] --&gt; services[services]\n    services --&gt; views[views]\n    views --&gt; models\n\n    style models fill:#ffcccc\n    style views fill:#ffcccc\n    style services fill:#ffcccc</code></pre> <p>Error Message:</p> <pre><code>CircularDependencyError: Circular dependency detected: models -&gt; services -&gt; views -&gt; models\n</code></pre>"},{"location":"core/dependencies/#how-detection-works","title":"How Detection Works","text":"<p>During <code>topological_sort()</code>:</p> <ol> <li>Calculate in-degree for each node</li> <li>Process nodes with in-degree of 0</li> <li>If unprocessed nodes remain, a cycle exists</li> <li>Perform depth-first search to identify the exact cycle</li> <li>Raise <code>CircularDependencyError</code> with cycle path</li> </ol>"},{"location":"core/dependencies/#dependency-resolution-examples","title":"Dependency Resolution Examples","text":""},{"location":"core/dependencies/#example-1-linear-dependencies","title":"Example 1: Linear Dependencies","text":"<p>Simple chain where each module depends on the previous one.</p> <pre><code>schema = Schema(\n    modules=[\"database\", \"models\", \"services\", \"api\"],\n    dependencies={\n        \"models\": [\"database\"],\n        \"services\": [\"models\"],\n        \"api\": [\"services\"]\n    }\n)\n</code></pre> <p>Graph:</p> <pre><code>graph LR\n    database[database] --&gt; models[models]\n    models --&gt; services[services]\n    services --&gt; api[api]\n\n    style database fill:#e1f5ff\n    style models fill:#fff4e1\n    style services fill:#ffe1f5\n    style api fill:#e1ffe1</code></pre> <p>Initialization Order: <code>database</code> \u2192 <code>models</code> \u2192 <code>services</code> \u2192 <code>api</code></p> <p>Shutdown Order: <code>api</code> \u2192 <code>services</code> \u2192 <code>models</code> \u2192 <code>database</code></p>"},{"location":"core/dependencies/#example-2-diamond-dependencies","title":"Example 2: Diamond Dependencies","text":"<p>Multiple modules depend on a common base module.</p> <pre><code>schema = Schema(\n    modules=[\"database\", \"models\", \"cache\", \"api\"],\n    dependencies={\n        \"models\": [\"database\"],\n        \"cache\": [\"database\"],\n        \"api\": [\"models\", \"cache\"]\n    }\n)\n</code></pre> <p>Graph:</p> <pre><code>graph TD\n    database[database] --&gt; models[models]\n    database --&gt; cache[cache]\n    models --&gt; api[api]\n    cache --&gt; api\n\n    style database fill:#e1f5ff\n    style models fill:#fff4e1\n    style cache fill:#fff4e1\n    style api fill:#ffe1f5</code></pre> <p>Possible Initialization Orders:</p> <ul> <li><code>database</code> \u2192 <code>models</code> \u2192 <code>cache</code> \u2192 <code>api</code></li> <li><code>database</code> \u2192 <code>cache</code> \u2192 <code>models</code> \u2192 <code>api</code></li> </ul> <p>Both are valid. SPOC guarantees <code>database</code> loads first and <code>api</code> loads last.</p>"},{"location":"core/dependencies/#example-3-complex-multi-layer-application","title":"Example 3: Complex Multi-Layer Application","text":"<p>Real-world application with multiple layers and dependencies.</p> <pre><code>schema = Schema(\n    modules=[\n        \"config\",\n        \"database\",\n        \"cache\",\n        \"models\",\n        \"repositories\",\n        \"services\",\n        \"middleware\",\n        \"views\",\n        \"api\"\n    ],\n    dependencies={\n        \"database\": [\"config\"],\n        \"cache\": [\"config\"],\n        \"models\": [\"database\"],\n        \"repositories\": [\"models\", \"cache\"],\n        \"services\": [\"repositories\"],\n        \"middleware\": [\"services\"],\n        \"views\": [\"services\"],\n        \"api\": [\"middleware\", \"views\"]\n    }\n)\n</code></pre> <p>Graph:</p> <pre><code>graph TD\n    config[config] --&gt; database[database]\n    config --&gt; cache[cache]\n    database --&gt; models[models]\n    models --&gt; repositories[repositories]\n    cache --&gt; repositories\n    repositories --&gt; services[services]\n    services --&gt; middleware[middleware]\n    services --&gt; views[views]\n    middleware --&gt; api[api]\n    views --&gt; api\n\n    style config fill:#e1f5ff\n    style database fill:#fff4e1\n    style cache fill:#fff4e1\n    style models fill:#ffe1f5\n    style repositories fill:#e1ffe1\n    style services fill:#e1f5ff\n    style middleware fill:#fff4e1\n    style views fill:#fff4e1\n    style api fill:#ffe1f5</code></pre> <p>Initialization Flow:</p> <pre><code>flowchart TD\n    Start([Framework Startup]) --&gt; Load1[Load: config]\n    Load1 --&gt; Load2[Load: database, cache]\n    Load2 --&gt; Load3[Load: models]\n    Load3 --&gt; Load4[Load: repositories]\n    Load4 --&gt; Load5[Load: services]\n    Load5 --&gt; Load6[Load: middleware, views]\n    Load6 --&gt; Load7[Load: api]\n    Load7 --&gt; Done([Ready])\n\n    style Start fill:#e1f5ff\n    style Done fill:#e1ffe1</code></pre>"},{"location":"core/dependencies/#startup-and-shutdown-order","title":"Startup and Shutdown Order","text":"<p>SPOC ensures proper initialization and cleanup by using the dependency graph in both directions.</p>"},{"location":"core/dependencies/#startup-order","title":"Startup Order","text":"<p>Modules are initialized in dependency order (leaves to root):</p> <pre><code>framework = Framework(base_dir=Path(\".\"), schema=schema)\n# Automatically calls startup()\n\n# Internally:\n# 1. Build dependency graph\n# 2. Perform topological sort\n# 3. Load modules in order: models \u2192 views \u2192 services\n# 4. Call initialize() on each module\n</code></pre>"},{"location":"core/dependencies/#shutdown-order","title":"Shutdown Order","text":"<p>Modules are torn down in reverse dependency order (root to leaves):</p> <pre><code>framework.shutdown()\n\n# Internally:\n# 1. Reverse the dependency graph\n# 2. Perform topological sort on reversed graph\n# 3. Teardown modules in order: services \u2192 views \u2192 models\n# 4. Call teardown() on each module\n</code></pre> <p>Example:</p> <pre><code>sequenceDiagram\n    participant Framework\n    participant Models\n    participant Views\n    participant Services\n\n    Note over Framework,Services: STARTUP\n    Framework-&gt;&gt;Models: initialize()\n    Framework-&gt;&gt;Views: initialize()\n    Framework-&gt;&gt;Services: initialize()\n\n    Note over Framework,Services: Application runs...\n\n    Note over Framework,Services: SHUTDOWN\n    Framework-&gt;&gt;Services: teardown()\n    Framework-&gt;&gt;Views: teardown()\n    Framework-&gt;&gt;Models: teardown()</code></pre>"},{"location":"core/dependencies/#best-practices","title":"Best Practices","text":""},{"location":"core/dependencies/#1-keep-dependencies-minimal","title":"1. Keep Dependencies Minimal","text":"<p>Only declare dependencies you actually need.</p> <p>Bad:</p> <pre><code># views doesn't actually use services\ndependencies={\n    \"views\": [\"models\", \"services\"],\n    \"services\": [\"models\"]\n}\n</code></pre> <p>Good:</p> <pre><code># Minimal dependencies\ndependencies={\n    \"views\": [\"models\"],\n    \"services\": [\"models\"]\n}\n</code></pre>"},{"location":"core/dependencies/#2-avoid-circular-dependencies","title":"2. Avoid Circular Dependencies","text":"<p>Design your architecture to prevent circular dependencies.</p> <p>Bad:</p> <pre><code>graph LR\n    models[models] --&gt; services[services]\n    services --&gt; models\n\n    style models fill:#ffcccc\n    style services fill:#ffcccc</code></pre> <p>Good:</p> <pre><code>graph LR\n    models[models] --&gt; repositories[repositories]\n    repositories --&gt; services[services]\n\n    style models fill:#e1f5ff\n    style repositories fill:#fff4e1\n    style services fill:#ffe1f5</code></pre>"},{"location":"core/dependencies/#3-layer-your-modules","title":"3. Layer Your Modules","text":"<p>Follow a layered architecture:</p> <pre><code>Data Layer (models, database)\n    \u2193\nLogic Layer (repositories, services)\n    \u2193\nPresentation Layer (views, api)\n</code></pre> <p>Implementation:</p> <pre><code>schema = Schema(\n    modules=[\"models\", \"repositories\", \"services\", \"views\", \"api\"],\n    dependencies={\n        # Data layer\n        \"repositories\": [\"models\"],\n\n        # Logic layer\n        \"services\": [\"repositories\"],\n\n        # Presentation layer\n        \"views\": [\"services\"],\n        \"api\": [\"services\"]\n    }\n)\n</code></pre>"},{"location":"core/dependencies/#4-use-clear-naming-conventions","title":"4. Use Clear Naming Conventions","text":"<p>Name modules to reflect their layer and purpose:</p> <ul> <li><code>database.py</code> - Database connections</li> <li><code>models.py</code> - Data models</li> <li><code>repositories.py</code> - Data access layer</li> <li><code>services.py</code> - Business logic</li> <li><code>views.py</code> - Presentation logic</li> <li><code>api.py</code> - API endpoints</li> </ul>"},{"location":"core/dependencies/#5-document-complex-dependencies","title":"5. Document Complex Dependencies","text":"<p>For complex applications, document why dependencies exist:</p> <pre><code>schema = Schema(\n    modules=[\"cache\", \"models\", \"services\"],\n    dependencies={\n        # services needs models for data structures\n        # services needs cache for performance optimization\n        \"services\": [\"models\", \"cache\"]\n    }\n)\n</code></pre>"},{"location":"core/dependencies/#6-test-dependency-order","title":"6. Test Dependency Order","text":"<p>Write tests to verify initialization order:</p> <pre><code>import pytest\nfrom spoc.core.utils import DependencyGraph\n\ndef test_dependency_order():\n    graph = DependencyGraph[str]()\n    graph.add_edge(\"models\", \"views\")\n    graph.add_edge(\"models\", \"services\")\n    graph.add_edge(\"views\", \"services\")\n\n    order = graph.topological_sort()\n\n    # Verify models loads first\n    assert order.index(\"models\") &lt; order.index(\"views\")\n    assert order.index(\"models\") &lt; order.index(\"services\")\n\n    # Verify services loads last\n    assert order.index(\"services\") &gt; order.index(\"views\")\n    assert order.index(\"services\") &gt; order.index(\"models\")\n</code></pre>"},{"location":"core/dependencies/#7-handle-missing-dependencies-gracefully","title":"7. Handle Missing Dependencies Gracefully","text":"<p>Use <code>mode=\"loose\"</code> for optional dependencies:</p> <pre><code># Strict mode - all modules must exist\nframework = Framework(\n    base_dir=Path(\".\"),\n    schema=schema,\n    mode=\"strict\"  # Raises error if module missing\n)\n\n# Loose mode - allows missing modules\nframework = Framework(\n    base_dir=Path(\".\"),\n    schema=schema,\n    mode=\"loose\"  # Skips missing modules\n)\n</code></pre>"},{"location":"core/dependencies/#common-pitfalls","title":"Common Pitfalls","text":""},{"location":"core/dependencies/#pitfall-1-forgetting-transitive-dependencies","title":"Pitfall 1: Forgetting Transitive Dependencies","text":"<p>Problem: Not declaring indirect dependencies.</p> <pre><code># services uses repositories, which uses models\n# But you only declare direct dependency\ndependencies={\n    \"repositories\": [\"models\"],\n    \"services\": [\"repositories\"]  # Missing models!\n}\n</code></pre> <p>Solution: SPOC handles transitive dependencies automatically. Just declare direct dependencies:</p> <pre><code>dependencies={\n    \"repositories\": [\"models\"],\n    \"services\": [\"repositories\"]  # SPOC knows services needs models\n}\n</code></pre>"},{"location":"core/dependencies/#pitfall-2-dependency-on-self","title":"Pitfall 2: Dependency on Self","text":"<p>Problem: Module depending on itself.</p> <pre><code>dependencies={\n    \"models\": [\"models\"]  # Invalid!\n}\n</code></pre> <p>Solution: Remove self-dependencies. They're always errors.</p>"},{"location":"core/dependencies/#pitfall-3-implicit-dependencies","title":"Pitfall 3: Implicit Dependencies","text":"<p>Problem: Using imports without declaring dependencies.</p> <pre><code># views.py\nfrom .models import User  # Implicit dependency!\n\n# But schema doesn't declare it\ndependencies={}  # Missing: \"views\": [\"models\"]\n</code></pre> <p>Solution: Always declare dependencies explicitly:</p> <pre><code>dependencies={\n    \"views\": [\"models\"]  # Explicit dependency\n}\n</code></pre>"},{"location":"core/dependencies/#advanced-usage","title":"Advanced Usage","text":""},{"location":"core/dependencies/#custom-dependency-graphs","title":"Custom Dependency Graphs","text":"<p>Create custom dependency graphs for specialized use cases:</p> <pre><code>from spoc.core.utils import DependencyGraph\n\n# Build a custom task dependency graph\ntasks = DependencyGraph[str]()\ntasks.add_edge(\"fetch_data\", \"process_data\")\ntasks.add_edge(\"process_data\", \"save_results\")\ntasks.add_edge(\"fetch_data\", \"log_activity\")\n\n# Get execution order\nexecution_order = tasks.topological_sort()\n# [\"fetch_data\", \"process_data\", \"log_activity\", \"save_results\"]\n\nfor task in execution_order:\n    print(f\"Running task: {task}\")\n</code></pre>"},{"location":"core/dependencies/#dynamic-dependencies","title":"Dynamic Dependencies","text":"<p>Add dependencies at runtime based on configuration:</p> <pre><code>def build_schema(config):\n    modules = [\"core\", \"api\"]\n    dependencies = {\"api\": [\"core\"]}\n\n    # Add optional modules based on config\n    if config.get(\"enable_cache\"):\n        modules.append(\"cache\")\n        dependencies[\"api\"] = [\"core\", \"cache\"]\n\n    if config.get(\"enable_auth\"):\n        modules.append(\"auth\")\n        dependencies[\"api\"].append(\"auth\")\n\n    return Schema(modules=modules, dependencies=dependencies)\n</code></pre>"},{"location":"core/dependencies/#summary","title":"Summary","text":"<p>SPOC's dependency management system:</p> <ul> <li>Ensures correct initialization order using topological sorting</li> <li>Detects circular dependencies automatically with detailed error messages</li> <li>Handles shutdown properly by reversing the dependency graph</li> <li>Supports complex architectures with multi-layer dependencies</li> <li>Provides predictable behavior with deterministic ordering</li> </ul> <p>By following best practices and understanding how SPOC resolves dependencies, you can build robust, maintainable applications with confidence that modules will always load in the correct order.</p>"},{"location":"core/dependencies/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about Lifecycle Hooks: Lifecycle Hooks Guide</li> <li>Explore the Framework API: Framework API Reference</li> <li>Study the Importer: Importer Guide</li> <li>Review Examples: Check the <code>examples/</code> directory for real-world patterns</li> </ul>"},{"location":"core/framework/","title":"Understanding the SPOC Framework","text":"<p>The Framework is the heart of SPOC. It's the orchestrator that brings together configuration, modules, components, and lifecycle management into a cohesive application structure. This guide explains the conceptual foundations of the Framework and how it powers your SPOC applications.</p>"},{"location":"core/framework/#what-is-the-framework","title":"What is the Framework?","text":"<p>The Framework is the core orchestrator for SPOC applications. Think of it as the conductor of an orchestra - it doesn't play the instruments (your modules and components), but it coordinates when and how they perform together.</p> <p>The Framework manages:</p> <ul> <li>Configuration Discovery: Locates and loads project settings and environment variables</li> <li>Module Registration: Registers which modules to load from your apps</li> <li>Dependency Resolution: Determines the correct order to load modules based on dependencies</li> <li>Lifecycle Orchestration: Controls startup and shutdown sequences</li> <li>Component Discovery: Finds and indexes components for easy access</li> <li>Plugin Loading: Integrates middleware and extensions</li> </ul> <pre><code>graph TB\n    subgraph \"Framework Responsibilities\"\n        Config[Configuration Management]\n        Modules[Module Loading]\n        Deps[Dependency Resolution]\n        Lifecycle[Lifecycle Control]\n        Components[Component Registry]\n        Plugins[Plugin System]\n    end\n\n    Framework[Framework] --&gt; Config\n    Framework --&gt; Modules\n    Framework --&gt; Deps\n    Framework --&gt; Lifecycle\n    Framework --&gt; Components\n    Framework --&gt; Plugins\n\n    Config --&gt; Apps[Your Applications]\n    Modules --&gt; Apps\n    Components --&gt; Apps\n    Plugins --&gt; Apps\n\n    style Framework fill:#4a90e2,color:#fff\n    style Apps fill:#50c878,color:#fff</code></pre>"},{"location":"core/framework/#the-big-picture","title":"The Big Picture","text":"<p>Before diving into details, let's see how the Framework fits into your application:</p> <pre><code>from pathlib import Path\nfrom spoc import Framework, Schema\n\n# 1. Define your application structure\nschema = Schema(\n    modules=[\"models\", \"views\", \"services\"],\n    dependencies={\n        \"views\": [\"models\"],\n        \"services\": [\"models\"]\n    },\n    hooks={\n        \"models\": {\n            \"startup\": lambda m: print(f\"Models loaded: {m}\"),\n        }\n    }\n)\n\n# 2. Initialize the Framework\nframework = Framework(\n    base_dir=Path(\"./my_project\"),\n    schema=schema,\n    echo=False,\n    mode=\"strict\"\n)\n\n# 3. Use your application\nuser_model = framework.get_component(\"model\", \"users.User\")\n\n# 4. Clean shutdown\nframework.shutdown()\n</code></pre> <p>That's it! The Framework handles everything else behind the scenes.</p>"},{"location":"core/framework/#framework-initialization","title":"Framework Initialization","text":"<p>When you create a Framework instance, several things happen in sequence:</p>"},{"location":"core/framework/#1-parameter-configuration","title":"1. Parameter Configuration","text":"<pre><code>framework = Framework(\n    base_dir=Path(\"./my_project\"),  # Project root directory\n    schema=schema,                  # Module structure definition\n    echo=False,                     # Verbose output control\n    mode=\"strict\"                   # Error handling mode\n)\n</code></pre>"},{"location":"core/framework/#parameter-details","title":"Parameter Details","text":"<p><code>base_dir</code> - The project root directory - Must be a <code>Path</code> object pointing to your project root - This directory typically contains your <code>apps/</code> folder and <code>config/</code> directory - All module discovery and configuration loading starts from this location</p> <p><code>schema</code> - Defines your application's module structure - A <code>Schema</code> object specifying modules, dependencies, and hooks - See Schema Definition for details</p> <p><code>echo</code> - Verbose output control - <code>True</code>: Prints detailed debug information during operations - <code>False</code>: Silent operation (default) - Useful for debugging module loading issues</p> <p><code>mode</code> - Error handling mode - <code>\"strict\"</code>: Raises errors if modules don't exist (recommended for development) - <code>\"loose\"</code>: Silently skips missing modules (useful for optional features) - Controls the Importer's behavior when encountering missing modules</p>"},{"location":"core/framework/#2-app-discovery-and-injection","title":"2. App Discovery and Injection","text":"<p>The Framework automatically discovers and makes your apps available for import:</p> <pre><code># Framework adds C:/path/to/my_project/apps to sys.path\n# Now you can import: from blog import models\n</code></pre> <p>This happens via the <code>inject_apps()</code> function, which: 1. Looks for an <code>apps/</code> directory in your <code>base_dir</code> 2. Adds it to Python's module search path 3. Enables direct imports of your applications</p>"},{"location":"core/framework/#3-configuration-loading","title":"3. Configuration Loading","text":"<p>The Framework builds a <code>Config</code> object containing three parts:</p> <pre><code>graph LR\n    Config[Config Object] --&gt; Project[Project Configuration]\n    Config --&gt; Settings[Settings Module]\n    Config --&gt; Environment[Environment Variables]\n\n    Project --&gt; TOML[spoc.toml]\n    Settings --&gt; PY[settings.py]\n    Environment --&gt; ENV[.env/development.toml]\n\n    style Config fill:#4a90e2,color:#fff\n    style TOML fill:#f39c12,color:#fff\n    style PY fill:#e74c3c,color:#fff\n    style ENV fill:#9b59b6,color:#fff</code></pre> <p>Project Configuration (<code>config.project</code>) - Loaded from <code>spoc.toml</code> in your config directory - Contains mode, app lists, plugin configurations - Accessed via <code>framework.config.project</code></p> <p>Settings Module (<code>config.settings</code>) - Loaded from <code>settings.py</code> or <code>config.py</code> - Contains Python constants like <code>INSTALLED_APPS</code>, <code>PLUGINS</code> - Accessed via <code>framework.config.settings</code></p> <p>Environment Variables (<code>config.environment</code>) - Loaded from <code>.env/&lt;mode&gt;.toml</code> based on current mode - Mode-specific environment configuration - Accessed via <code>framework.config.environment</code></p> <p>Example configuration access:</p> <pre><code># Get the current mode\nmode = framework.config.project.get(\"mode\", \"development\")\n\n# Get installed apps from settings\napps = framework.config.settings.INSTALLED_APPS\n\n# Get environment variables\ndb_host = framework.config.environment.get(\"DATABASE_HOST\")\n</code></pre>"},{"location":"core/framework/#4-plugin-collection","title":"4. Plugin Collection","text":"<p>The Framework collects and loads plugins from two sources:</p> <pre><code># From spoc.toml\n[spoc.plugins]\nmiddleware = [\"myapp.middleware.auth_middleware\"]\n\n# From settings.py\nPLUGINS = {\n    \"hooks\": [\"myapp.hooks.logging_hook\"]\n}\n</code></pre> <p>Plugins are organized by group and loaded via URI references. Access them via:</p> <pre><code># Get all middleware plugins\nmiddleware = framework.plugins.get(\"middleware\", {})\n</code></pre>"},{"location":"core/framework/#5-automatic-startup","title":"5. Automatic Startup","text":"<p>Important: The Framework calls <code>startup()</code> automatically during initialization!</p> <pre><code># These are equivalent:\nframework = Framework(base_dir, schema)  # startup() called automatically\n\n# You don't need to do this:\nframework = Framework(base_dir, schema)\nframework.startup()  # Already called!\n</code></pre> <p>The startup process: 1. Registers all apps and their modules 2. Resolves dependencies 3. Loads modules in dependency order 4. Executes startup hooks 5. Initializes components registry</p>"},{"location":"core/framework/#schema-definition","title":"Schema Definition","text":"<p>The Schema defines what your application is made of - which modules exist and how they relate to each other.</p>"},{"location":"core/framework/#basic-schema","title":"Basic Schema","text":"<pre><code>from spoc import Schema\n\nschema = Schema(\n    modules=[\"models\", \"views\"],\n    dependencies={},\n    hooks={}\n)\n</code></pre>"},{"location":"core/framework/#complete-schema-example","title":"Complete Schema Example","text":"<pre><code>schema = Schema(\n    # List of module names to load from each app\n    modules=[\"models\", \"views\", \"services\", \"commands\"],\n\n    # Module dependencies (key depends on values)\n    dependencies={\n        \"views\": [\"models\"],           # views need models\n        \"services\": [\"models\"],        # services need models\n        \"commands\": [\"services\"],      # commands need services\n    },\n\n    # Lifecycle hooks for modules\n    hooks={\n        \"models\": {\n            \"startup\": lambda module_set: print(f\"Models initialized: {module_set}\"),\n            \"shutdown\": lambda module_set: print(f\"Models shutting down\"),\n        },\n        \"services\": {\n            \"startup\": lambda module_set: initialize_services(module_set),\n            \"shutdown\": lambda module_set: cleanup_services(module_set),\n        },\n    },\n)\n</code></pre>"},{"location":"core/framework/#schema-components","title":"Schema Components","text":"<p><code>modules</code> - List of module names - These names correspond to Python files in your apps - Example: <code>[\"models\"]</code> means each app should have a <code>models.py</code> - In <code>\"strict\"</code> mode, all apps must have all modules - In <code>\"loose\"</code> mode, apps can skip modules</p> <p><code>dependencies</code> - Dependency mapping - Dictionary where keys are modules and values are their dependencies - Format: <code>{\"dependent\": [\"dependency1\", \"dependency2\"]}</code> - Example: <code>{\"views\": [\"models\"]}</code> means views must load after models - The Framework uses this to determine loading order</p> <p><code>hooks</code> - Lifecycle callbacks - Dictionary mapping module names to Hook dictionaries - Hooks receive a set of module objects (not individual modules) - <code>startup</code> hook: Called after module loads, receives all instances of that module type - <code>shutdown</code> hook: Called before module unloads</p>"},{"location":"core/framework/#hook-pattern-matching","title":"Hook Pattern Matching","text":"<p>Hooks support pattern matching with wildcards:</p> <pre><code>def handle_all_models(module_set):\n    \"\"\"Called for any app's models module.\"\"\"\n    print(f\"Loaded {len(module_set)} model modules\")\n\nschema = Schema(\n    modules=[\"models\"],\n    hooks={\n        # Matches blog.models, users.models, etc.\n        \"*.models\": {\n            \"startup\": handle_all_models,\n        }\n    }\n)\n</code></pre>"},{"location":"core/framework/#the-config-object","title":"The Config Object","text":"<p>The Config object is an immutable (frozen) dataclass that holds all configuration:</p> <pre><code>@dataclass(frozen=True)\nclass Config:\n    project: Dict[str, Any]      # From spoc.toml\n    settings: Any                # From settings.py\n    environment: Any             # From .env/&lt;mode&gt;.toml\n</code></pre>"},{"location":"core/framework/#accessing-configuration","title":"Accessing Configuration","text":"<pre><code># Project configuration (from spoc.toml)\nframework.config.project[\"mode\"]           # \"development\"\nframework.config.project[\"debug\"]          # True\nframework.config.project[\"apps\"]           # {\"production\": [...], ...}\n\n# Settings (from settings.py)\nframework.config.settings.INSTALLED_APPS   # [\"blog\", \"users\"]\nframework.config.settings.BASE_DIR         # Path object\nframework.config.settings.PLUGINS          # Plugin configuration\n\n# Environment (from .env/development.toml)\nframework.config.environment[\"DATABASE_URL\"]\nframework.config.environment[\"API_KEY\"]\n</code></pre>"},{"location":"core/framework/#configuration-search-paths","title":"Configuration Search Paths","text":"<p>The Framework searches for configuration files in standard locations:</p> <p>spoc.toml: 1. <code>{base_dir}/config/spoc.toml</code> 2. <code>{base_dir}/spoc.toml</code></p> <p>settings.py: 1. <code>{base_dir}/config/settings.py</code> 2. <code>{base_dir}/conf/settings.py</code> 3. <code>{base_dir}/settings.py</code></p> <p>Also accepts: <code>config.py</code>, <code>configuration.py</code></p> <p>Environment files: 1. <code>{base_dir}/config/.env/{mode}.toml</code> 2. <code>{base_dir}/.env/{mode}.toml</code></p> <p>Falls back to <code>default.toml</code> if mode-specific file not found.</p>"},{"location":"core/framework/#framework-lifecycle","title":"Framework Lifecycle","text":"<p>The Framework manages your application through distinct lifecycle phases:</p> <pre><code>sequenceDiagram\n    participant User\n    participant Framework\n    participant Config\n    participant Importer\n    participant Apps\n    participant Components\n\n    User-&gt;&gt;Framework: Framework(base_dir, schema)\n    Framework-&gt;&gt;Config: Load configuration\n    Config--&gt;&gt;Framework: Config object\n\n    Framework-&gt;&gt;Framework: Collect plugins\n    Framework-&gt;&gt;Framework: startup() [automatic]\n\n    Framework-&gt;&gt;Apps: Register all apps\n    Framework-&gt;&gt;Importer: Register modules with dependencies\n    Importer-&gt;&gt;Importer: Topological sort\n\n    loop For each module in dependency order\n        Importer-&gt;&gt;Apps: Import module\n        Importer-&gt;&gt;Apps: Execute startup hook\n        Importer-&gt;&gt;Apps: Call initialize() if exists\n    end\n\n    Framework-&gt;&gt;Components: Build component registry\n    Components--&gt;&gt;Framework: components namespace\n\n    Note over User,Framework: Application runs...\n\n    User-&gt;&gt;Framework: shutdown()\n\n    loop For each module in reverse order\n        Importer-&gt;&gt;Apps: Call shutdown hook\n        Importer-&gt;&gt;Apps: Call teardown() if exists\n    end\n\n    Framework--&gt;&gt;User: Application stopped</code></pre>"},{"location":"core/framework/#startup-sequence","title":"Startup Sequence","text":"<p>The <code>startup()</code> method orchestrates module initialization:</p> <pre><code>def startup(self) -&gt; Framework:\n    \"\"\"Bootstrap the application.\"\"\"\n    self._register_all_apps()    # 1. Register apps\n    self.importer.startup()       # 2. Load modules\n    self._init_components()       # 3. Index components\n    return self\n</code></pre> <p>Step 1: Register Apps</p> <pre><code># Collects apps from two sources:\ninstalled_apps = [\n    # From settings.py\n    *config.settings.INSTALLED_APPS,\n\n    # From spoc.toml based on mode\n    *config.project[\"apps\"][mode]\n]\n\n# For each app, register its modules:\nfor app in installed_apps:\n    for module in schema.modules:\n        importer.register(\n            f\"{app}.{module}\",\n            dependencies=[f\"{app}.{dep}\" for dep in schema.dependencies.get(module, [])]\n        )\n</code></pre> <p>Step 2: Load Modules</p> <p>The Importer performs a topological sort to determine loading order:</p> <pre><code># Example with dependencies: {\"views\": [\"models\"]}\n# Loading order: blog.models, users.models, blog.views, users.views\n</code></pre> <p>For each module in order: 1. Import the module 2. Execute startup hook (if defined) 3. Call <code>module.initialize()</code> (if exists) 4. Mark as initialized</p> <p>Step 3: Initialize Components</p> <p>The Framework scans loaded modules for decorated components:</p> <pre><code># Finds objects with __spoc__ attribute\n# Organizes by type (models, views, etc.)\n# Creates namespace for easy access\nframework.components.models  # {\"blog.Post\": Post, ...}\nframework.components.views   # {\"blog.list_posts\": list_posts, ...}\n</code></pre>"},{"location":"core/framework/#shutdown-sequence","title":"Shutdown Sequence","text":"<p>The <code>shutdown()</code> method tears down in reverse order:</p> <pre><code>def shutdown(self) -&gt; Framework:\n    \"\"\"Tear down the application.\"\"\"\n    self.importer.shutdown()\n    return self\n</code></pre> <p>For each module in reverse dependency order: 1. Execute shutdown hook (if defined) 2. Call <code>module.teardown()</code> (if exists and initialized) 3. Mark as uninitialized</p> <p>Example shutdown order: <pre><code>views \u2192 services \u2192 models\n(reverse of startup order)\n</code></pre></p>"},{"location":"core/framework/#lifecycle-hooks-in-action","title":"Lifecycle Hooks in Action","text":"<p>Hooks receive a set of component objects from the module:</p> <pre><code>def initialize_models(model_set):\n    \"\"\"Called when a models module loads.\"\"\"\n    print(f\"Initializing {len(model_set)} models\")\n    for model in model_set:\n        # Setup database tables, validate schema, etc.\n        print(f\"  - {model.__name__}\")\n\nschema = Schema(\n    modules=[\"models\"],\n    hooks={\n        \"models\": {\n            \"startup\": initialize_models,\n        }\n    }\n)\n</code></pre> <p>When <code>blog.models</code> loads with decorated <code>Post</code> and <code>Comment</code> classes: <pre><code>Initializing 2 models\n  - Post\n  - Comment\n</code></pre></p>"},{"location":"core/framework/#accessing-components","title":"Accessing Components","text":"<p>The Framework provides multiple ways to access your components:</p>"},{"location":"core/framework/#1-component-namespace","title":"1. Component Namespace","text":"<p>Direct attribute access to component dictionaries:</p> <pre><code># Access all models\nall_models = framework.components.models\n\n# Iterate over models\nfor name, model_class in framework.components.models.items():\n    print(f\"{name}: {model_class}\")\n\n# Output:\n# blog.Post: &lt;class 'blog.models.Post'&gt;\n# blog.Comment: &lt;class 'blog.models.Comment'&gt;\n# users.User: &lt;class 'users.models.User'&gt;\n</code></pre>"},{"location":"core/framework/#2-get-component-method","title":"2. Get Component Method","text":"<p>Retrieve a specific component by kind and name:</p> <pre><code># Get a specific component\nPost = framework.get_component(\"model\", \"blog.Post\")\n\n# Returns None if not found\nresult = framework.get_component(\"model\", \"nonexistent.Model\")  # None\n</code></pre> <p>Method signature: <pre><code>def get_component(self, kind: str, name: str) -&gt; Any:\n    \"\"\"\n    Get a framework component by &lt;kind&gt;.&lt;name&gt;\n\n    Args:\n        kind: Component type (e.g., \"model\", \"view\")\n        name: Component name including app (e.g., \"blog.Post\")\n\n    Returns:\n        The component object or None if not found\n    \"\"\"\n</code></pre></p>"},{"location":"core/framework/#3-installed-apps-list","title":"3. Installed Apps List","text":"<p>Access the list of loaded applications:</p> <pre><code># Get all installed apps\napps = framework.installed_apps\n# [\"blog\", \"users\"]\n\n# Check if an app is loaded\nif \"admin\" in framework.installed_apps:\n    admin_views = framework.components.views.get(\"admin.dashboard\")\n</code></pre>"},{"location":"core/framework/#component-organization","title":"Component Organization","text":"<p>Components are organized by type (module name):</p> <pre><code>framework.components\n\u251c\u2500\u2500 models          # Dict of model components\n\u2502   \u251c\u2500\u2500 \"blog.Post\"       \u2192 &lt;class Post&gt;\n\u2502   \u251c\u2500\u2500 \"blog.Comment\"    \u2192 &lt;class Comment&gt;\n\u2502   \u2514\u2500\u2500 \"users.User\"      \u2192 &lt;class User&gt;\n\u251c\u2500\u2500 views           # Dict of view components\n\u2502   \u251c\u2500\u2500 \"blog.list_posts\" \u2192 &lt;function list_posts&gt;\n\u2502   \u2514\u2500\u2500 \"blog.create_post\" \u2192 &lt;function create_post&gt;\n\u2514\u2500\u2500 services        # Dict of service components\n    \u2514\u2500\u2500 \"blog.PostService\" \u2192 &lt;class PostService&gt;\n</code></pre>"},{"location":"core/framework/#dependency-resolution","title":"Dependency Resolution","text":"<p>The Framework uses a dependency graph to ensure modules load in the correct order:</p>"},{"location":"core/framework/#how-dependencies-work","title":"How Dependencies Work","text":"<pre><code>schema = Schema(\n    modules=[\"models\", \"views\", \"services\"],\n    dependencies={\n        \"views\": [\"models\"],      # views need models\n        \"services\": [\"models\"],   # services need models\n    }\n)\n</code></pre> <p>Dependency graph for apps <code>[\"blog\", \"users\"]</code>:</p> <pre><code>graph TD\n    A[blog.models] --&gt; B[blog.views]\n    A --&gt; C[blog.services]\n    D[users.models] --&gt; E[users.views]\n    D --&gt; F[users.services]\n\n    style A fill:#e74c3c,color:#fff\n    style D fill:#e74c3c,color:#fff\n    style B fill:#3498db,color:#fff\n    style E fill:#3498db,color:#fff\n    style C fill:#2ecc71,color:#fff\n    style F fill:#2ecc71,color:#fff</code></pre> <p>Loading order (topological sort): 1. <code>blog.models</code> 2. <code>users.models</code> 3. <code>blog.views</code> 4. <code>blog.services</code> 5. <code>users.views</code> 6. <code>users.services</code></p>"},{"location":"core/framework/#circular-dependency-detection","title":"Circular Dependency Detection","text":"<p>The Framework detects and prevents circular dependencies:</p> <pre><code># This will raise CircularDependencyError\nschema = Schema(\n    modules=[\"a\", \"b\"],\n    dependencies={\n        \"a\": [\"b\"],  # a depends on b\n        \"b\": [\"a\"],  # b depends on a - CIRCULAR!\n    }\n)\n\n# Error: Circular dependency detected: a \u2192 b \u2192 a\n</code></pre> <p>Best practices: - Keep dependencies unidirectional - Models should have no dependencies - Views depend on models - Services depend on models - Commands depend on services</p>"},{"location":"core/framework/#cross-app-dependencies","title":"Cross-App Dependencies","text":"<p>Dependencies are per module type, not per app:</p> <pre><code># CORRECT: Module-level dependencies\ndependencies = {\n    \"views\": [\"models\"]  # ALL views depend on ALL models\n}\n\n# Note: You cannot specify that blog.views depends on users.models\n# Dependencies are defined at the module level, not the app level\n</code></pre> <p>If you need app-specific dependencies, consider: - Splitting into separate module types - Using lazy imports within the module - Restructuring your application architecture</p>"},{"location":"core/framework/#working-with-the-importer","title":"Working with the Importer","text":"<p>The Framework delegates module loading to an Importer instance:</p> <pre><code># Access the importer\nimporter = framework.importer\n\n# Check if a module is loaded\nif importer.has(\"blog.models\"):\n    models = importer.get(\"blog.models\")\n\n# Get all loaded module names\nmodules = importer.keys()\n</code></pre>"},{"location":"core/framework/#importer-modes","title":"Importer Modes","text":"<p>The <code>mode</code> parameter controls error handling:</p> <p>Strict Mode (recommended): <pre><code>framework = Framework(base_dir, schema, mode=\"strict\")\n\n# Raises AppNotFoundError if module doesn't exist\n# Good for development: catches missing modules immediately\n</code></pre></p> <p>Loose Mode: <pre><code>framework = Framework(base_dir, schema, mode=\"loose\")\n\n# Returns None if module doesn't exist\n# Good for optional features or testing\n</code></pre></p>"},{"location":"core/framework/#module-loading-pattern","title":"Module Loading Pattern","text":"<p>The Importer uses a caching pattern:</p> <pre><code># First call: imports and caches\nmodule1 = importer.load(\"blog.models\")\n\n# Second call: returns cached version\nmodule2 = importer.load(\"blog.models\")\n\nassert module1 is module2  # Same object\n</code></pre>"},{"location":"core/framework/#practical-examples","title":"Practical Examples","text":""},{"location":"core/framework/#example-1-database-connection-management","title":"Example 1: Database Connection Management","text":"<pre><code>def connect_db(model_set):\n    \"\"\"Connect to database when models load.\"\"\"\n    import sqlite3\n    db = sqlite3.connect(\"app.db\")\n    # Store connection somewhere accessible\n    print(f\"Database connected for {len(model_set)} models\")\n\ndef disconnect_db(model_set):\n    \"\"\"Disconnect from database when models unload.\"\"\"\n    # Close database connection\n    print(\"Database disconnected\")\n\nschema = Schema(\n    modules=[\"models\", \"views\"],\n    dependencies={\"views\": [\"models\"]},\n    hooks={\n        \"models\": {\n            \"startup\": connect_db,\n            \"shutdown\": disconnect_db,\n        }\n    }\n)\n</code></pre>"},{"location":"core/framework/#example-2-cache-warmup","title":"Example 2: Cache Warmup","text":"<pre><code>def warmup_cache(view_set):\n    \"\"\"Pre-load frequently accessed data.\"\"\"\n    print(f\"Warming up cache for {len(view_set)} views\")\n    for view in view_set:\n        if hasattr(view, \"warmup\"):\n            view.warmup()\n\nschema = Schema(\n    modules=[\"models\", \"views\"],\n    dependencies={\"views\": [\"models\"]},\n    hooks={\n        \"views\": {\n            \"startup\": warmup_cache,\n        }\n    }\n)\n</code></pre>"},{"location":"core/framework/#example-3-component-discovery","title":"Example 3: Component Discovery","text":"<pre><code>def discover_commands(command_set):\n    \"\"\"Register CLI commands.\"\"\"\n    import sys\n    cli_registry = {}\n\n    for cmd in command_set:\n        cmd_name = cmd.__name__.lower()\n        cli_registry[cmd_name] = cmd\n        print(f\"Registered command: {cmd_name}\")\n\n    # Store registry for CLI tool\n    sys.modules[\"__main__\"].commands = cli_registry\n\nschema = Schema(\n    modules=[\"commands\"],\n    hooks={\n        \"commands\": {\n            \"startup\": discover_commands,\n        }\n    }\n)\n</code></pre>"},{"location":"core/framework/#example-4-multi-app-project","title":"Example 4: Multi-App Project","text":"<pre><code>from pathlib import Path\nfrom spoc import Framework, Schema\n\n# Define schema for e-commerce app\nschema = Schema(\n    modules=[\"models\", \"views\", \"services\", \"tasks\"],\n    dependencies={\n        \"views\": [\"models\"],\n        \"services\": [\"models\"],\n        \"tasks\": [\"services\"],\n    }\n)\n\n# Initialize framework\nframework = Framework(\n    base_dir=Path(__file__).parent,\n    schema=schema,\n    mode=\"strict\",\n)\n\n# Access components from different apps\nProduct = framework.get_component(\"model\", \"catalog.Product\")\nOrder = framework.get_component(\"model\", \"orders.Order\")\nUser = framework.get_component(\"model\", \"auth.User\")\n\ncheckout_service = framework.get_component(\"service\", \"orders.CheckoutService\")\n</code></pre>"},{"location":"core/framework/#common-patterns","title":"Common Patterns","text":""},{"location":"core/framework/#pattern-1-singleton-framework","title":"Pattern 1: Singleton Framework","text":"<p>Create a single framework instance for your entire application:</p> <pre><code># framework.py\nfrom pathlib import Path\nfrom spoc import Framework, Schema\n\n_framework = None\n\ndef get_framework() -&gt; Framework:\n    \"\"\"Get or create the framework instance.\"\"\"\n    global _framework\n    if _framework is None:\n        schema = Schema(modules=[\"models\", \"views\"])\n        _framework = Framework(\n            base_dir=Path(__file__).parent,\n            schema=schema,\n        )\n    return _framework\n\n# Use anywhere in your app\nfrom framework import get_framework\n\nframework = get_framework()\nUser = framework.get_component(\"model\", \"auth.User\")\n</code></pre>"},{"location":"core/framework/#pattern-2-lazy-component-loading","title":"Pattern 2: Lazy Component Loading","text":"<p>Access components only when needed:</p> <pre><code>class PostService:\n    def __init__(self, framework):\n        self.framework = framework\n        self._post_model = None\n\n    @property\n    def Post(self):\n        \"\"\"Lazy load Post model.\"\"\"\n        if self._post_model is None:\n            self._post_model = self.framework.get_component(\"model\", \"blog.Post\")\n        return self._post_model\n\n    def create_post(self, title, content):\n        return self.Post(title=title, content=content)\n</code></pre>"},{"location":"core/framework/#pattern-3-environment-based-configuration","title":"Pattern 3: Environment-Based Configuration","text":"<pre><code># spoc.toml\n[spoc]\nmode = \"production\"\n\n[spoc.apps]\nproduction = [\"core\", \"api\"]\nstaging = [\"core\", \"api\", \"monitoring\"]\ndevelopment = [\"core\", \"api\", \"monitoring\", \"debug\"]\n\n# Different apps load based on mode\nframework = Framework(base_dir, schema)\nprint(framework.installed_apps)  # [\"core\", \"api\"] in production\n</code></pre>"},{"location":"core/framework/#pattern-4-custom-hook-functions","title":"Pattern 4: Custom Hook Functions","text":"<pre><code>class DatabaseManager:\n    def __init__(self):\n        self.connections = {}\n\n    def startup(self, model_set):\n        \"\"\"Create database connections for models.\"\"\"\n        for model in model_set:\n            if hasattr(model, \"DATABASE\"):\n                db_name = model.DATABASE\n                if db_name not in self.connections:\n                    self.connections[db_name] = self.connect(db_name)\n\n    def shutdown(self, model_set):\n        \"\"\"Close all database connections.\"\"\"\n        for conn in self.connections.values():\n            conn.close()\n        self.connections.clear()\n\ndb_manager = DatabaseManager()\n\nschema = Schema(\n    modules=[\"models\"],\n    hooks={\n        \"models\": {\n            \"startup\": db_manager.startup,\n            \"shutdown\": db_manager.shutdown,\n        }\n    }\n)\n</code></pre>"},{"location":"core/framework/#troubleshooting","title":"Troubleshooting","text":""},{"location":"core/framework/#issue-modules-not-loading","title":"Issue: Modules Not Loading","text":"<p>Symptoms: Components are empty, modules not found</p> <p>Solutions: 1. Check that <code>apps/</code> directory exists in <code>base_dir</code> 2. Verify each app has an <code>__init__.py</code> file 3. Ensure module files match <code>schema.modules</code> names 4. Use <code>mode=\"loose\"</code> temporarily to identify which modules are missing 5. Enable <code>echo=True</code> for detailed loading information</p>"},{"location":"core/framework/#issue-import-errors","title":"Issue: Import Errors","text":"<p>Symptoms: <code>ModuleNotFoundError</code> or <code>ImportError</code></p> <p>Solutions: 1. Verify <code>base_dir</code> points to correct directory 2. Check that apps are in <code>apps/</code> subdirectory 3. Ensure all dependencies are installed 4. Check for typos in module names</p>"},{"location":"core/framework/#issue-circular-dependencies","title":"Issue: Circular Dependencies","text":"<p>Symptoms: <code>CircularDependencyError</code> during startup</p> <p>Solutions: 1. Review <code>schema.dependencies</code> for cycles 2. Restructure dependencies to be unidirectional 3. Consider splitting modules differently 4. Use lazy imports within modules if needed</p>"},{"location":"core/framework/#issue-hooks-not-executing","title":"Issue: Hooks Not Executing","text":"<p>Symptoms: Startup/shutdown hooks don't run</p> <p>Solutions: 1. Verify hook names match module names in schema 2. Check hook signatures accept correct parameters 3. Ensure hooks are registered before Framework creation 4. Check for exceptions in hook functions (use logging)</p>"},{"location":"core/framework/#issue-components-not-found","title":"Issue: Components Not Found","text":"<p>Symptoms: <code>get_component()</code> returns <code>None</code></p> <p>Solutions: 1. Verify component is decorated with <code>@component</code> or <code>@components.register()</code> 2. Check component type matches (e.g., \"model\" vs \"models\") 3. Ensure app containing component is in installed_apps 4. Use correct full name: <code>\"app.Component\"</code> not just <code>\"Component\"</code></p>"},{"location":"core/framework/#best-practices","title":"Best Practices","text":""},{"location":"core/framework/#1-use-strict-mode-in-development","title":"1. Use Strict Mode in Development","text":"<pre><code># Catches missing modules early\nframework = Framework(base_dir, schema, mode=\"strict\")\n</code></pre>"},{"location":"core/framework/#2-keep-dependencies-simple","title":"2. Keep Dependencies Simple","text":"<pre><code># Good: Simple, clear dependencies\ndependencies = {\n    \"views\": [\"models\"],\n    \"services\": [\"models\"],\n}\n\n# Avoid: Complex dependency chains\ndependencies = {\n    \"views\": [\"models\", \"services\"],\n    \"services\": [\"models\", \"utils\"],\n    \"utils\": [\"config\"],\n}\n</code></pre>"},{"location":"core/framework/#3-use-meaningful-hook-functions","title":"3. Use Meaningful Hook Functions","text":"<pre><code># Good: Clear, focused hook\ndef initialize_database(model_set):\n    \"\"\"Create database tables for models.\"\"\"\n    create_tables(model_set)\n\n# Avoid: Hook doing too much\ndef startup_hook(model_set):\n    create_tables(model_set)\n    warmup_cache()\n    send_startup_notification()\n    check_api_keys()  # Too many responsibilities\n</code></pre>"},{"location":"core/framework/#4-organize-configuration-properly","title":"4. Organize Configuration Properly","text":"<pre><code>my_project/\n\u251c\u2500\u2500 apps/              # Application modules\n\u251c\u2500\u2500 config/            # All configuration\n\u2502   \u251c\u2500\u2500 settings.py    # Python settings\n\u2502   \u251c\u2500\u2500 spoc.toml      # SPOC config\n\u2502   \u2514\u2500\u2500 .env/          # Environment files\n\u2502       \u251c\u2500\u2500 development.toml\n\u2502       \u251c\u2500\u2500 staging.toml\n\u2502       \u2514\u2500\u2500 production.toml\n\u2514\u2500\u2500 main.py            # Entry point\n</code></pre>"},{"location":"core/framework/#5-leverage-component-namespace","title":"5. Leverage Component Namespace","text":"<pre><code># Good: Use namespace for type safety\nall_models = framework.components.models.values()\n\n# Avoid: Using get_component for iteration\nfor app in framework.installed_apps:\n    model = framework.get_component(\"model\", f\"{app}.SomeModel\")  # Fragile\n</code></pre>"},{"location":"core/framework/#summary","title":"Summary","text":"<p>The Framework is the orchestration layer that:</p> <ol> <li>Discovers configuration from standard locations</li> <li>Registers apps and modules with dependencies</li> <li>Loads modules in the correct order</li> <li>Executes lifecycle hooks at appropriate times</li> <li>Indexes components for easy access</li> <li>Manages startup and shutdown sequences</li> </ol> <p>Understanding the Framework's lifecycle and configuration system enables you to build robust, maintainable SPOC applications with clear separation of concerns and proper dependency management.</p> <p>For API-level details, see the Framework API Reference.</p> <p>For practical examples, check the Quick Start Guide.</p>"},{"location":"core/importer/","title":"Importer - Dynamic Module Loading","text":"<p>The Importer is SPOC's dynamic module loader that handles runtime module imports, dependency tracking, and lifecycle management. It provides the foundation for building modular applications with clear dependency relationships and predictable initialization order.</p>"},{"location":"core/importer/#what-the-importer-does","title":"What the Importer Does","text":"<p>The Importer serves three critical functions in SPOC applications:</p> <ol> <li>Dynamic Module Loading: Import Python modules at runtime instead of static imports</li> <li>Module Caching: Store loaded modules for O(1) lookup performance</li> <li>Lifecycle Management: Initialize and tear down modules in dependency order</li> </ol> <p>Think of the Importer as a smart module loader that not only loads Python modules but also understands their relationships and manages their entire lifecycle.</p> <pre><code>from spoc import Importer\n\n# Get the importer instance\nimporter = Importer()\n\n# Load a module dynamically\nmodule = importer.load(\"myapp.models\")\n\n# Register a module with dependencies\nimporter.register(\"myapp.views\", dependencies=[\"myapp.models\"])\n\n# Initialize all modules in correct order\nimporter.startup()\n\n# ... use your modules ...\n\n# Clean shutdown in reverse order\nimporter.shutdown()\n</code></pre>"},{"location":"core/importer/#the-singleton-pattern","title":"The Singleton Pattern","text":"<p>The Importer uses the Singleton pattern, ensuring only one instance exists per application. This guarantees:</p> <ul> <li>Consistent State: All parts of your application share the same module cache</li> <li>Dependency Graph Integrity: A single source of truth for module relationships</li> <li>Predictable Lifecycle: One coordinated startup and shutdown sequence</li> </ul> <pre><code>from spoc import Importer\n\n# These are the same instance\nimporter1 = Importer()\nimporter2 = Importer()\n\nassert importer1 is importer2  # True - same object\n</code></pre> <p>Singleton Benefits</p> <p>The singleton pattern prevents conflicting module states and ensures that dependency relationships remain consistent throughout your application's lifetime.</p>"},{"location":"core/importer/#loading-modules","title":"Loading Modules","text":""},{"location":"core/importer/#basic-loading","title":"Basic Loading","text":"<p>The <code>load()</code> method imports a module and adds it to the cache:</p> <pre><code>from spoc import Importer\n\nimporter = Importer()\n\n# Load a module\nos_module = importer.load(\"os\")\n\n# Load from your application\nmodels = importer.load(\"myapp.models\")\n</code></pre> <p>Time Complexity:</p> <ul> <li>First load: O(1) - standard Python import</li> <li>Subsequent loads: O(1) - cached lookup</li> </ul>"},{"location":"core/importer/#checking-the-cache","title":"Checking the Cache","text":"<p>Before loading, you can check if a module is already cached:</p> <pre><code>if importer.has(\"myapp.models\"):\n    models = importer.get(\"myapp.models\")  # Get from cache\nelse:\n    models = importer.load(\"myapp.models\")  # Load and cache\n</code></pre>"},{"location":"core/importer/#loading-from-uri","title":"Loading from URI","text":"<p>Load specific functions or classes from modules using URI notation:</p> <pre><code># Load a function from a module\njoin_func = importer.load_from_uri(\"os.path.join\")\n\n# Load a class\nvalue_error = importer.load_from_uri(\"builtins.ValueError\")\n\n# Load from your app\nuser_model = importer.load_from_uri(\"myapp.models.User\")\n</code></pre>"},{"location":"core/importer/#registering-with-dependencies","title":"Registering with Dependencies","text":"<p>The <code>register()</code> method loads a module AND establishes its dependency relationships:</p> <pre><code>from spoc import Importer\n\nimporter = Importer()\n\n# Register modules with dependencies\nimporter.register(\"myapp.utils\")                           # No dependencies\nimporter.register(\"myapp.models\", dependencies=[\"myapp.utils\"])\nimporter.register(\"myapp.views\", dependencies=[\"myapp.models\"])\nimporter.register(\"myapp.api\", dependencies=[\"myapp.views\", \"myapp.models\"])\n</code></pre> <p>This creates a dependency graph:</p> <pre><code>graph LR\n    utils[myapp.utils]\n    models[myapp.models]\n    views[myapp.views]\n    api[myapp.api]\n\n    utils --&gt; models\n    models --&gt; views\n    models --&gt; api\n    views --&gt; api\n\n    style utils fill:#4CAF50\n    style models fill:#2196F3\n    style views fill:#FF9800\n    style api fill:#9C27B0</code></pre> <p>Circular Dependencies</p> <p>The Importer detects circular dependencies and raises <code>CircularDependencyError</code> during startup. This prevents initialization deadlocks.</p>"},{"location":"core/importer/#the-module-cache","title":"The Module Cache","text":"<p>The Importer maintains an internal cache of loaded modules for efficient reuse:</p> <pre><code># Internal structure (simplified)\n_module_cache = {\n    \"myapp.models\": ModuleInfo(...),\n    \"myapp.views\": ModuleInfo(...),\n    \"myapp.api\": ModuleInfo(...),\n}\n</code></pre> <p>Performance Characteristics:</p> Operation Time Complexity Description <code>has(name)</code> O(1) Check if module is cached <code>get(name)</code> O(1) Retrieve cached module <code>load(name)</code> O(1) amortized First load imports, subsequent loads use cache <code>clear(name)</code> O(1) Remove from cache"},{"location":"core/importer/#cache-management","title":"Cache Management","text":"<pre><code># Check cache\nif importer.has(\"myapp.models\"):\n    models = importer.get(\"myapp.models\")\n\n# Clear a single module\nimporter.clear(\"myapp.models\")\n\n# Clear all modules (keeps them in sys.modules)\nimporter.clear_all()\n\n# Complete unload (removes from sys.modules too)\nimporter.unload_all()\n</code></pre> <p>Unloading Modules</p> <p><code>unload_all()</code> removes modules from <code>sys.modules</code>. This can cause unexpected behavior if other code still references the modules. Use with caution, primarily for testing scenarios.</p>"},{"location":"core/importer/#lifecycle-hooks","title":"Lifecycle Hooks","text":"<p>Modules can define special functions that run during application startup and shutdown:</p> <pre><code># myapp/models.py\n\ndef initialize():\n    \"\"\"Called during startup.\"\"\"\n    print(\"Initializing database connections...\")\n    # Connect to database\n    # Set up connection pools\n    # Migrate schemas\n\ndef teardown():\n    \"\"\"Called during shutdown.\"\"\"\n    print(\"Closing database connections...\")\n    # Close connections\n    # Clean up resources\n</code></pre>"},{"location":"core/importer/#custom-hook-names","title":"Custom Hook Names","text":"<p>You can specify different function names when creating the Importer:</p> <pre><code># Use custom hook names\nimporter = Importer(\n    on_startup_name=\"setup\",\n    on_shutdown_name=\"cleanup\"\n)\n</code></pre> <pre><code># myapp/models.py\n\ndef setup():\n    \"\"\"Custom startup hook.\"\"\"\n    print(\"Setting up models...\")\n\ndef cleanup():\n    \"\"\"Custom teardown hook.\"\"\"\n    print(\"Cleaning up models...\")\n</code></pre>"},{"location":"core/importer/#optional-hooks","title":"Optional Hooks","text":"<p>Hooks are completely optional. Modules without lifecycle functions work normally:</p> <pre><code># myapp/utils.py\n# No initialize() or teardown() needed\n\ndef helper_function():\n    return \"This works fine!\"\n</code></pre>"},{"location":"core/importer/#startup-and-shutdown","title":"startup() and shutdown()","text":"<p>The <code>startup()</code> and <code>shutdown()</code> methods orchestrate module lifecycle in dependency order.</p>"},{"location":"core/importer/#startup-process","title":"Startup Process","text":"<pre><code>importer.startup()\n</code></pre> <p>What happens:</p> <ol> <li>Topological Sort: Orders modules based on dependencies</li> <li>Sequential Initialization: Calls <code>initialize()</code> in dependency order</li> <li>Error Detection: Catches circular dependencies and initialization errors</li> </ol> <pre><code>sequenceDiagram\n    participant App as Application\n    participant Imp as Importer\n    participant Utils as myapp.utils\n    participant Models as myapp.models\n    participant Views as myapp.views\n\n    App-&gt;&gt;Imp: startup()\n    Imp-&gt;&gt;Imp: Topological sort\n    Note over Imp: Order: utils \u2192 models \u2192 views\n\n    Imp-&gt;&gt;Utils: initialize()\n    Utils--&gt;&gt;Imp: \u2713\n\n    Imp-&gt;&gt;Models: initialize()\n    Models--&gt;&gt;Imp: \u2713\n\n    Imp-&gt;&gt;Views: initialize()\n    Views--&gt;&gt;Imp: \u2713\n\n    Imp--&gt;&gt;App: All modules initialized</code></pre> <p>Time Complexity: O(N + E)</p> <ul> <li>N = number of modules</li> <li>E = number of dependency edges</li> </ul>"},{"location":"core/importer/#shutdown-process","title":"Shutdown Process","text":"<pre><code>importer.shutdown()\n</code></pre> <p>What happens:</p> <ol> <li>Reverse Topological Sort: Orders modules in reverse dependency order</li> <li>Sequential Teardown: Calls <code>teardown()</code> in reverse order</li> <li>Resource Cleanup: Ensures resources are released properly</li> </ol> <pre><code>sequenceDiagram\n    participant App as Application\n    participant Imp as Importer\n    participant Views as myapp.views\n    participant Models as myapp.models\n    participant Utils as myapp.utils\n\n    App-&gt;&gt;Imp: shutdown()\n    Imp-&gt;&gt;Imp: Reverse topological sort\n    Note over Imp: Order: views \u2192 models \u2192 utils\n\n    Imp-&gt;&gt;Views: teardown()\n    Views--&gt;&gt;Imp: \u2713\n\n    Imp-&gt;&gt;Models: teardown()\n    Models--&gt;&gt;Imp: \u2713\n\n    Imp-&gt;&gt;Utils: teardown()\n    Utils--&gt;&gt;Imp: \u2713\n\n    Imp--&gt;&gt;App: All modules cleaned up</code></pre> <p>Time Complexity: O(N + E)</p> <ul> <li>N = number of modules</li> <li>E = number of dependency edges</li> </ul>"},{"location":"core/importer/#the-moduleinfo-class","title":"The ModuleInfo Class","text":"<p>Each loaded module is wrapped in a <code>ModuleInfo</code> object that stores metadata:</p> <pre><code>from spoc.core.importer import ModuleInfo\n\nmodule_info = ModuleInfo(\n    name=\"myapp.models\",\n    module=models_module,\n    dependencies=[\"myapp.utils\"],\n    initialize_func=\"initialize\",\n    teardown_func=\"teardown\"\n)\n</code></pre> <p>Attributes:</p> Attribute Type Description <code>name</code> <code>str</code> Fully-qualified module name <code>module</code> <code>ModuleType</code> The actual Python module object <code>dependencies</code> <code>list[str]</code> List of module names this depends on <code>initialize_func</code> <code>str \\| None</code> Name of the initialization function <code>teardown_func</code> <code>str \\| None</code> Name of the teardown function <code>initialized</code> <code>bool</code> Whether the module has been initialized <p>Methods:</p> <pre><code># Check for lifecycle hooks\nif module_info.has_initialize():\n    module_info.initialize()\n\nif module_info.has_teardown():\n    module_info.teardown()\n</code></pre>"},{"location":"core/importer/#pattern-based-hooks","title":"Pattern-Based Hooks","text":"<p>Register custom hooks that apply to modules matching a pattern:</p> <pre><code>from spoc import Importer\n\ndef database_startup(module):\n    \"\"\"Custom startup for database modules.\"\"\"\n    print(f\"Connecting database module: {module}\")\n\ndef database_shutdown(module):\n    \"\"\"Custom shutdown for database modules.\"\"\"\n    print(f\"Disconnecting database module: {module}\")\n\n# Register hooks for all database-related modules\nImporter.register_hook(\n    pattern=\"myapp.*.models\",\n    on_startup=database_startup,\n    on_shutdown=database_shutdown\n)\n</code></pre>"},{"location":"core/importer/#pattern-syntax","title":"Pattern Syntax","text":"<p>Patterns support wildcards:</p> Pattern Matches Example Matches <code>\"myapp.models\"</code> Exact match <code>myapp.models</code> <code>\"myapp.*\"</code> One level <code>myapp.models</code>, <code>myapp.views</code> <code>\"myapp.*.models\"</code> Middle wildcard <code>myapp.blog.models</code>, <code>myapp.auth.models</code> <code>\"*.models\"</code> Suffix <code>myapp.models</code>, <code>auth.models</code>"},{"location":"core/importer/#wildcard-characters","title":"Wildcard Characters","text":"<ul> <li><code>*</code> - Matches zero or more characters</li> <li><code>?</code> - Matches exactly one character</li> <li><code>.</code> - Literal dot (automatically escaped)</li> </ul> <pre><code># Match all models in any app\nImporter.register_hook(\n    pattern=\"*.models\",\n    on_startup=lambda m: print(f\"Loading models: {m}\")\n)\n\n# Match specific app pattern\nImporter.register_hook(\n    pattern=\"myapp.auth.?\",\n    on_startup=lambda m: print(f\"Loading auth module: {m}\")\n)\n</code></pre>"},{"location":"core/importer/#dependency-ordering-diagram","title":"Dependency Ordering Diagram","text":"<p>Understanding how the Importer resolves dependencies:</p> <pre><code>graph TD\n    subgraph \"Module Dependency Graph\"\n        A[myapp.utils]\n        B[myapp.config]\n        C[myapp.models]\n        D[myapp.services]\n        E[myapp.views]\n        F[myapp.api]\n\n        A --&gt; C\n        B --&gt; C\n        C --&gt; D\n        C --&gt; E\n        D --&gt; F\n        E --&gt; F\n    end\n\n    subgraph \"Startup Order\"\n        S1[1. utils, config]\n        S2[2. models]\n        S3[3. services, views]\n        S4[4. api]\n\n        S1 --&gt; S2 --&gt; S3 --&gt; S4\n    end\n\n    subgraph \"Shutdown Order\"\n        T1[1. api]\n        T2[2. services, views]\n        T3[3. models]\n        T4[4. utils, config]\n\n        T1 --&gt; T2 --&gt; T3 --&gt; T4\n    end\n\n    style A fill:#4CAF50\n    style B fill:#4CAF50\n    style C fill:#2196F3\n    style D fill:#FF9800\n    style E fill:#FF9800\n    style F fill:#9C27B0</code></pre> <p>Key Points:</p> <ol> <li>Parallel Initialization: Modules at the same dependency level can be initialized in any order</li> <li>No Cycles: Circular dependencies are detected and rejected</li> <li>Reverse Order: Shutdown happens in exact reverse of startup</li> </ol>"},{"location":"core/importer/#time-complexity-benefits","title":"Time Complexity Benefits","text":"<p>The Importer is designed for performance:</p> <pre><code># Scenario: Large application with many modules\n# 100 modules, 200 dependencies\n\n# Without Importer (manual management)\n# - Load all modules: O(N) = 100 imports\n# - Figure out order: Manual work, error-prone\n# - Each lookup: O(N) = Linear search through 100 modules\n\n# With Importer (optimized)\n# - Load all modules: O(N) = 100 imports (same)\n# - Figure out order: O(N + E) = O(300) one-time cost\n# - Each lookup: O(1) = Hash table lookup\n</code></pre> <p>Performance Summary:</p> Operation Complexity Benefit Initial registration O(N + E) One-time cost Module lookup O(1) Constant time access Startup/shutdown O(N + E) Optimal dependency resolution Cache check O(1) Instant verification"},{"location":"core/importer/#complete-example","title":"Complete Example","text":"<p>Putting it all together:</p> <pre><code>from spoc import Importer\nfrom pathlib import Path\n\n# Create the importer\nimporter = Importer(\n    on_startup_name=\"initialize\",\n    on_shutdown_name=\"teardown\"\n)\n\n# Register a pattern-based hook\nImporter.register_hook(\n    pattern=\"myapp.*.models\",\n    on_startup=lambda m: print(f\"\ud83d\udce6 Loading models: {m}\"),\n    on_shutdown=lambda m: print(f\"\ud83d\udce6 Unloading models: {m}\")\n)\n\n# Register modules with dependencies\nimporter.register(\"myapp.utils\")\nimporter.register(\"myapp.config\")\nimporter.register(\"myapp.database.models\", dependencies=[\"myapp.utils\", \"myapp.config\"])\nimporter.register(\"myapp.auth.models\", dependencies=[\"myapp.database.models\"])\nimporter.register(\"myapp.api.views\", dependencies=[\"myapp.auth.models\"])\n\n# Start the application\ntry:\n    importer.startup()\n\n    # Your application runs here\n    # All modules are initialized in correct order\n\n    # Access modules from cache (O(1))\n    models = importer.get(\"myapp.database.models\")\n    views = importer.get(\"myapp.api.views\")\n\n    # Check what's loaded\n    print(f\"Loaded modules: {importer.keys()}\")\n\nfinally:\n    # Always clean up\n    importer.shutdown()\n</code></pre> <p>Output:</p> <pre><code>\ud83d\udce6 Loading models: myapp.database.models\n\ud83d\udce6 Loading models: myapp.auth.models\nInitializing myapp.utils...\nInitializing myapp.config...\nInitializing myapp.database.models...\nInitializing myapp.auth.models...\nInitializing myapp.api.views...\nLoaded modules: ['myapp.utils', 'myapp.config', 'myapp.database.models', 'myapp.auth.models', 'myapp.api.views']\nTearing down myapp.api.views...\nTearing down myapp.auth.models...\nTearing down myapp.database.models...\n\ud83d\udce6 Unloading models: myapp.auth.models\n\ud83d\udce6 Unloading models: myapp.database.models\nTearing down myapp.config...\nTearing down myapp.utils...\n</code></pre>"},{"location":"core/importer/#best-practices","title":"Best Practices","text":"<p>Design Guidelines</p> <ol> <li>Keep Dependencies Minimal: Only declare what you actually need</li> <li>Use Lifecycle Hooks: Initialize resources in <code>initialize()</code>, clean up in <code>teardown()</code></li> <li>Check the Cache: Use <code>has()</code> before <code>get()</code> to avoid errors</li> <li>Pattern Hooks for Groups: Use patterns for common initialization logic</li> <li>Avoid Circular Dependencies: Design module relationships as a DAG (Directed Acyclic Graph)</li> </ol> <p>Common Pitfalls</p> <ul> <li>Forgetting teardown(): Always clean up resources to prevent leaks</li> <li>Circular dependencies: Design dependencies as a tree or DAG</li> <li>Unloading prematurely: Don't call <code>unload_all()</code> while modules are in use</li> <li>Ignoring singleton: Remember all Importer instances are the same object</li> </ul>"},{"location":"core/importer/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about the Framework which builds on the Importer</li> <li>Explore Dependency Management patterns</li> <li>See Lifecycle Hooks for advanced usage</li> <li>Check the API Reference for complete method documentation</li> </ul>"},{"location":"examples/app-example/","title":"Multi-App SPOC Application","text":"<p>A comprehensive example showing how to build a production-ready multi-app SPOC application with users, blog functionality, background workers, and environment-based configuration.</p>"},{"location":"examples/app-example/#what-youll-learn","title":"What You'll Learn","text":"<p>This example demonstrates:</p> <ul> <li>Multi-app architecture: Organizing code into separate apps (users, blog)</li> <li>Component types: Models, views, services with proper separation of concerns</li> <li>Cross-app dependencies: How apps interact through components</li> <li>Lifecycle hooks: Database initialization and cleanup</li> <li>Environment variables: Configuration for different deployment environments</li> <li>Background workers: Processing tasks asynchronously</li> <li>Dependency injection: Accessing framework components throughout your app</li> </ul>"},{"location":"examples/app-example/#project-structure","title":"Project Structure","text":"<pre><code>blog_platform/\n\u251c\u2500\u2500 apps/\n\u2502   \u251c\u2500\u2500 users/\n\u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502   \u251c\u2500\u2500 models.py\n\u2502   \u2502   \u251c\u2500\u2500 views.py\n\u2502   \u2502   \u251c\u2500\u2500 services.py\n\u2502   \u2502   \u2514\u2500\u2500 workers.py\n\u2502   \u2514\u2500\u2500 blog/\n\u2502       \u251c\u2500\u2500 __init__.py\n\u2502       \u251c\u2500\u2500 models.py\n\u2502       \u251c\u2500\u2500 views.py\n\u2502       \u251c\u2500\u2500 services.py\n\u2502       \u2514\u2500\u2500 workers.py\n\u251c\u2500\u2500 config/\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 settings.py\n\u2502   \u251c\u2500\u2500 spoc.toml\n\u2502   \u2514\u2500\u2500 .env.example\n\u251c\u2500\u2500 framework/\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 components.py\n\u2502   \u2514\u2500\u2500 database.py\n\u251c\u2500\u2500 main.py\n\u2514\u2500\u2500 requirements.txt\n</code></pre>"},{"location":"examples/app-example/#complete-implementation","title":"Complete Implementation","text":""},{"location":"examples/app-example/#1-configuration-files","title":"1. Configuration Files","text":""},{"location":"examples/app-example/#configsettingspy","title":"<code>config/settings.py</code>","text":"<pre><code>\"\"\"\nProject settings configuration.\n\nDefines the base configuration for the blog platform including\ninstalled apps, database settings, and plugin configuration.\n\"\"\"\n\nfrom pathlib import Path\n\n# Base directory of the project\nBASE_DIR: Path = Path(__file__).resolve().parent.parent\n\n# Apps always installed regardless of environment\nINSTALLED_APPS: list = [\n    \"users\",  # User management (authentication, profiles)\n    \"blog\",   # Blog functionality (posts, comments)\n]\n\n# Plugin configuration for cross-cutting concerns\nPLUGINS: dict = {\n    \"middleware\": [\n        # Add middleware plugins here\n        # Example: \"framework.middleware.LoggingMiddleware\"\n    ],\n    \"hooks\": [\n        # Add hook plugins here\n        # Example: \"framework.hooks.MetricsHook\"\n    ],\n}\n\n# Database configuration (loaded from environment variables)\nDATABASE: dict = {\n    \"engine\": \"sqlite\",  # Will be overridden by environment\n    \"name\": \"blog_platform.db\",\n    \"host\": \"localhost\",\n    \"port\": 5432,\n    \"user\": \"\",\n    \"password\": \"\",\n}\n\n# Worker configuration\nWORKERS: dict = {\n    \"email_notifications\": {\n        \"enabled\": True,\n        \"interval\": 60,  # Check every 60 seconds\n    },\n    \"content_indexer\": {\n        \"enabled\": True,\n        \"interval\": 300,  # Re-index every 5 minutes\n    },\n}\n</code></pre>"},{"location":"examples/app-example/#configspoctoml","title":"<code>config/spoc.toml</code>","text":"<pre><code># SPOC Configuration File\n# Defines environment-specific settings and app loading\n\n[spoc]\nmode = \"development\"  # Options: development, staging, production\ndebug = true\n\n# Environment-specific apps\n[spoc.apps]\n# These apps are ONLY loaded in production\nproduction = []\n\n# These apps load in staging and production\nstaging = []\n\n# These apps load only in development\ndevelopment = []\n\n# Additional plugins by environment\n[spoc.plugins]\nmiddleware = []\nhooks = []\n</code></pre>"},{"location":"examples/app-example/#configenvexample","title":"<code>config/.env.example</code>","text":"<pre><code># Development Environment Variables\n# Copy this to .env and update with your values\n\n# Application\nSPOC_MODE=development\nDEBUG=true\n\n# Database\nDB_ENGINE=sqlite\nDB_NAME=blog_platform.db\nDB_HOST=localhost\nDB_PORT=5432\nDB_USER=\nDB_PASSWORD=\n\n# Email\nEMAIL_HOST=smtp.example.com\nEMAIL_PORT=587\nEMAIL_USER=\nEMAIL_PASSWORD=\n\n# Workers\nENABLE_EMAIL_WORKER=true\nENABLE_INDEXER_WORKER=true\n</code></pre>"},{"location":"examples/app-example/#2-framework-setup","title":"2. Framework Setup","text":""},{"location":"examples/app-example/#frameworkcomponentspy","title":"<code>framework/components.py</code>","text":"<pre><code>\"\"\"\nShared component registry for the application.\n\nThis module defines the component types used across all apps\nand provides decorator functions for consistent registration.\n\"\"\"\n\nfrom spoc import Components\n\n# Initialize the component registry with all types\ncomponents = Components()\n\n# Register component types\ncomponents.add_type(\"model\")\ncomponents.add_type(\"view\")\ncomponents.add_type(\"service\")\ncomponents.add_type(\"worker\")\n\n\n# Convenience decorator functions\ndef model(cls):\n    \"\"\"Register a class as a model component.\"\"\"\n    return components.register(\"model\")(cls)\n\n\ndef view(func):\n    \"\"\"Register a function as a view component.\"\"\"\n    return components.register(\"view\")(func)\n\n\ndef service(cls):\n    \"\"\"Register a class as a service component.\"\"\"\n    return components.register(\"service\")(cls)\n\n\ndef worker(cls):\n    \"\"\"Register a class as a worker component.\"\"\"\n    return components.register(\"worker\")(cls)\n</code></pre>"},{"location":"examples/app-example/#frameworkdatabasepy","title":"<code>framework/database.py</code>","text":"<pre><code>\"\"\"\nDatabase management utilities.\n\nProvides a simple in-memory database simulation for the example.\nIn production, this would connect to a real database.\n\"\"\"\n\nfrom typing import Any, Dict, List\n\n\nclass Database:\n    \"\"\"Simple in-memory database for demonstration purposes.\"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize the database with empty tables.\"\"\"\n        self._tables: Dict[str, List[Dict[str, Any]]] = {\n            \"users\": [],\n            \"posts\": [],\n            \"comments\": [],\n        }\n        self._sequences: Dict[str, int] = {\n            \"users\": 1,\n            \"posts\": 1,\n            \"comments\": 1,\n        }\n\n    def insert(self, table: str, data: Dict[str, Any]) -&gt; int:\n        \"\"\"\n        Insert a record into a table.\n\n        Args:\n            table: Name of the table\n            data: Record data to insert\n\n        Returns:\n            The ID of the inserted record\n        \"\"\"\n        record_id = self._sequences[table]\n        self._sequences[table] += 1\n\n        record = {\"id\": record_id, **data}\n        self._tables[table].append(record)\n        return record_id\n\n    def find_by_id(self, table: str, record_id: int) -&gt; Dict[str, Any] | None:\n        \"\"\"\n        Find a record by ID.\n\n        Args:\n            table: Name of the table\n            record_id: ID of the record to find\n\n        Returns:\n            The record if found, None otherwise\n        \"\"\"\n        for record in self._tables[table]:\n            if record[\"id\"] == record_id:\n                return record\n        return None\n\n    def find_all(self, table: str) -&gt; List[Dict[str, Any]]:\n        \"\"\"\n        Get all records from a table.\n\n        Args:\n            table: Name of the table\n\n        Returns:\n            List of all records in the table\n        \"\"\"\n        return self._tables[table].copy()\n\n    def clear(self):\n        \"\"\"Clear all data from the database.\"\"\"\n        for table in self._tables:\n            self._tables[table].clear()\n            self._sequences[table] = 1\n\n\n# Global database instance\ndb = Database()\n</code></pre>"},{"location":"examples/app-example/#3-users-app","title":"3. Users App","text":""},{"location":"examples/app-example/#appsusers__init__py","title":"<code>apps/users/__init__.py</code>","text":"<pre><code>\"\"\"\nUsers app initialization.\n\nThis app handles user authentication, profiles, and user management.\n\"\"\"\n</code></pre>"},{"location":"examples/app-example/#appsusersmodelspy","title":"<code>apps/users/models.py</code>","text":"<pre><code>\"\"\"\nUser models.\n\nDefines the data structures for user-related entities.\n\"\"\"\n\nimport dataclasses as dc\nfrom datetime import datetime\nfrom framework.components import model\n\n\n@dc.dataclass\n@model\nclass User:\n    \"\"\"\n    User model representing a registered user.\n\n    Attributes:\n        id: Unique user identifier\n        username: Unique username for login\n        email: User's email address\n        full_name: User's full name\n        created_at: Timestamp when user was created\n        is_active: Whether the user account is active\n    \"\"\"\n\n    id: int\n    username: str\n    email: str\n    full_name: str\n    created_at: datetime\n    is_active: bool = True\n\n    def __str__(self) -&gt; str:\n        return f\"User(id={self.id}, username={self.username})\"\n\n\n@dc.dataclass\n@model\nclass UserProfile:\n    \"\"\"\n    Extended user profile information.\n\n    Attributes:\n        user_id: Reference to the User\n        bio: User biography\n        avatar_url: URL to user's avatar image\n        website: User's website URL\n    \"\"\"\n\n    user_id: int\n    bio: str = \"\"\n    avatar_url: str = \"\"\n    website: str = \"\"\n</code></pre>"},{"location":"examples/app-example/#appsusersservicespy","title":"<code>apps/users/services.py</code>","text":"<pre><code>\"\"\"\nUser services.\n\nBusiness logic for user management operations.\n\"\"\"\n\nfrom datetime import datetime\nfrom typing import Optional\n\nfrom framework.components import service\nfrom framework.database import db\n\n\n@service\nclass UserService:\n    \"\"\"\n    Service for managing user operations.\n\n    Provides methods for user registration, authentication,\n    and profile management.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize the user service.\"\"\"\n        self.db = db\n\n    def create_user(\n        self,\n        username: str,\n        email: str,\n        full_name: str,\n    ) -&gt; int:\n        \"\"\"\n        Create a new user.\n\n        Args:\n            username: Unique username\n            email: User's email address\n            full_name: User's full name\n\n        Returns:\n            The ID of the created user\n        \"\"\"\n        user_data = {\n            \"username\": username,\n            \"email\": email,\n            \"full_name\": full_name,\n            \"created_at\": datetime.now(),\n            \"is_active\": True,\n        }\n        user_id = self.db.insert(\"users\", user_data)\n        print(f\"  [UserService] Created user: {username} (ID: {user_id})\")\n        return user_id\n\n    def get_user(self, user_id: int) -&gt; Optional[dict]:\n        \"\"\"\n        Get a user by ID.\n\n        Args:\n            user_id: The user's ID\n\n        Returns:\n            User data if found, None otherwise\n        \"\"\"\n        return self.db.find_by_id(\"users\", user_id)\n\n    def list_users(self) -&gt; list:\n        \"\"\"\n        List all users.\n\n        Returns:\n            List of all users\n        \"\"\"\n        return self.db.find_all(\"users\")\n\n    def authenticate(self, username: str) -&gt; Optional[dict]:\n        \"\"\"\n        Authenticate a user by username.\n\n        Args:\n            username: Username to authenticate\n\n        Returns:\n            User data if authenticated, None otherwise\n        \"\"\"\n        users = self.db.find_all(\"users\")\n        for user in users:\n            if user[\"username\"] == username and user[\"is_active\"]:\n                return user\n        return None\n</code></pre>"},{"location":"examples/app-example/#appsusersviewspy","title":"<code>apps/users/views.py</code>","text":"<pre><code>\"\"\"\nUser views.\n\nHTTP request handlers for user-related endpoints.\n\"\"\"\n\nfrom typing import Any, Dict\n\nfrom framework.components import view\n\n\n@view\ndef register_user(data: Dict[str, Any]) -&gt; Dict[str, Any]:\n    \"\"\"\n    Handle user registration request.\n\n    Args:\n        data: Registration data containing username, email, full_name\n\n    Returns:\n        Response with user ID and status\n    \"\"\"\n    # In a real app, this would validate input and call the service\n    return {\n        \"action\": \"register_user\",\n        \"status\": \"success\",\n        \"data\": data,\n    }\n\n\n@view\ndef login_user(data: Dict[str, Any]) -&gt; Dict[str, Any]:\n    \"\"\"\n    Handle user login request.\n\n    Args:\n        data: Login credentials\n\n    Returns:\n        Response with authentication token\n    \"\"\"\n    return {\n        \"action\": \"login_user\",\n        \"status\": \"success\",\n        \"username\": data.get(\"username\"),\n    }\n\n\n@view\ndef get_profile(user_id: int) -&gt; Dict[str, Any]:\n    \"\"\"\n    Get user profile.\n\n    Args:\n        user_id: ID of the user\n\n    Returns:\n        User profile data\n    \"\"\"\n    return {\n        \"action\": \"get_profile\",\n        \"status\": \"success\",\n        \"user_id\": user_id,\n    }\n</code></pre>"},{"location":"examples/app-example/#appsusersworkerspy","title":"<code>apps/users/workers.py</code>","text":"<pre><code>\"\"\"\nUser workers.\n\nBackground tasks for user-related operations.\n\"\"\"\n\nimport time\nfrom framework.components import worker\nfrom spoc.workers import ThreadWorker\n\n\n@worker\nclass EmailNotificationWorker(ThreadWorker):\n    \"\"\"\n    Background worker for sending email notifications.\n\n    Periodically checks for pending notifications and sends emails.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize the email notification worker.\"\"\"\n        super().__init__(name=\"EmailNotificationWorker\", daemon=True)\n        self.check_interval = 60  # Check every 60 seconds\n\n    def setup(self) -&gt; None:\n        \"\"\"Setup the worker (runs before main loop).\"\"\"\n        print(f\"  [{self.name}] Initializing email service...\")\n        self.context.email_queue = []\n        self.context.sent_count = 0\n\n    def main(self) -&gt; None:\n        \"\"\"\n        Main worker loop.\n\n        Checks for pending emails and sends them.\n        \"\"\"\n        print(f\"  [{self.name}] Started monitoring email queue\")\n\n        while self.is_running:\n            # Simulate checking for pending emails\n            pending = len(self.context.email_queue)\n            if pending &gt; 0:\n                print(f\"  [{self.name}] Processing {pending} pending emails...\")\n                self.context.sent_count += pending\n                self.context.email_queue.clear()\n\n            # Wait before next check\n            time.sleep(self.check_interval)\n\n    def teardown(self) -&gt; None:\n        \"\"\"Cleanup when worker stops.\"\"\"\n        print(\n            f\"  [{self.name}] Shutting down. \"\n            f\"Total emails sent: {self.context.sent_count}\"\n        )\n\n    def lifecycle(self, event_type: str, **data) -&gt; None:\n        \"\"\"Handle lifecycle events.\"\"\"\n        if event_type == \"startup\":\n            print(f\"  [{self.name}] Lifecycle: Started\")\n        elif event_type == \"shutdown\":\n            print(f\"  [{self.name}] Lifecycle: Stopped\")\n        elif event_type == \"error\":\n            print(f\"  [{self.name}] Error: {data.get('exception')}\")\n</code></pre>"},{"location":"examples/app-example/#4-blog-app","title":"4. Blog App","text":""},{"location":"examples/app-example/#appsblog__init__py","title":"<code>apps/blog/__init__.py</code>","text":"<pre><code>\"\"\"\nBlog app initialization.\n\nThis app handles blog posts, comments, and content management.\n\"\"\"\n</code></pre>"},{"location":"examples/app-example/#appsblogmodelspy","title":"<code>apps/blog/models.py</code>","text":"<pre><code>\"\"\"\nBlog models.\n\nDefines the data structures for blog-related entities.\n\"\"\"\n\nimport dataclasses as dc\nfrom datetime import datetime\nfrom framework.components import model\n\n\n@dc.dataclass\n@model\nclass Post:\n    \"\"\"\n    Blog post model.\n\n    Attributes:\n        id: Unique post identifier\n        title: Post title\n        content: Post content (markdown supported)\n        author_id: ID of the user who created the post\n        created_at: When the post was created\n        updated_at: When the post was last updated\n        published: Whether the post is published\n        slug: URL-friendly version of the title\n    \"\"\"\n\n    id: int\n    title: str\n    content: str\n    author_id: int\n    created_at: datetime\n    updated_at: datetime\n    published: bool = False\n    slug: str = \"\"\n\n    def __str__(self) -&gt; str:\n        return f\"Post(id={self.id}, title={self.title})\"\n\n\n@dc.dataclass\n@model\nclass Comment:\n    \"\"\"\n    Comment model for blog posts.\n\n    Attributes:\n        id: Unique comment identifier\n        post_id: ID of the post being commented on\n        author_id: ID of the user who wrote the comment\n        text: Comment text\n        created_at: When the comment was created\n        approved: Whether the comment is approved for display\n    \"\"\"\n\n    id: int\n    post_id: int\n    author_id: int\n    text: str\n    created_at: datetime\n    approved: bool = False\n\n    def __str__(self) -&gt; str:\n        return f\"Comment(id={self.id}, post_id={self.post_id})\"\n</code></pre>"},{"location":"examples/app-example/#appsblogservicespy","title":"<code>apps/blog/services.py</code>","text":"<pre><code>\"\"\"\nBlog services.\n\nBusiness logic for blog operations including post and comment management.\n\"\"\"\n\nfrom datetime import datetime\nfrom typing import List, Optional\n\nfrom framework.components import service\nfrom framework.database import db\n\n\n@service\nclass PostService:\n    \"\"\"\n    Service for managing blog posts.\n\n    Handles post creation, updates, publishing, and retrieval.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize the post service.\"\"\"\n        self.db = db\n\n    def create_post(\n        self,\n        title: str,\n        content: str,\n        author_id: int,\n    ) -&gt; int:\n        \"\"\"\n        Create a new blog post.\n\n        Args:\n            title: Post title\n            content: Post content\n            author_id: ID of the author\n\n        Returns:\n            The ID of the created post\n        \"\"\"\n        slug = title.lower().replace(\" \", \"-\")\n        post_data = {\n            \"title\": title,\n            \"content\": content,\n            \"author_id\": author_id,\n            \"slug\": slug,\n            \"created_at\": datetime.now(),\n            \"updated_at\": datetime.now(),\n            \"published\": False,\n        }\n        post_id = self.db.insert(\"posts\", post_data)\n        print(f\"  [PostService] Created post: {title} (ID: {post_id})\")\n        return post_id\n\n    def publish_post(self, post_id: int) -&gt; bool:\n        \"\"\"\n        Publish a post.\n\n        Args:\n            post_id: ID of the post to publish\n\n        Returns:\n            True if successful, False otherwise\n        \"\"\"\n        post = self.db.find_by_id(\"posts\", post_id)\n        if post:\n            post[\"published\"] = True\n            post[\"updated_at\"] = datetime.now()\n            print(f\"  [PostService] Published post ID: {post_id}\")\n            return True\n        return False\n\n    def get_post(self, post_id: int) -&gt; Optional[dict]:\n        \"\"\"\n        Get a post by ID.\n\n        Args:\n            post_id: The post's ID\n\n        Returns:\n            Post data if found, None otherwise\n        \"\"\"\n        return self.db.find_by_id(\"posts\", post_id)\n\n    def list_posts(self, published_only: bool = False) -&gt; List[dict]:\n        \"\"\"\n        List all posts.\n\n        Args:\n            published_only: Whether to return only published posts\n\n        Returns:\n            List of posts\n        \"\"\"\n        posts = self.db.find_all(\"posts\")\n        if published_only:\n            return [p for p in posts if p.get(\"published\", False)]\n        return posts\n\n\n@service\nclass CommentService:\n    \"\"\"\n    Service for managing blog comments.\n\n    Handles comment creation, moderation, and retrieval.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize the comment service.\"\"\"\n        self.db = db\n\n    def create_comment(\n        self,\n        post_id: int,\n        author_id: int,\n        text: str,\n    ) -&gt; int:\n        \"\"\"\n        Create a new comment.\n\n        Args:\n            post_id: ID of the post being commented on\n            author_id: ID of the comment author\n            text: Comment text\n\n        Returns:\n            The ID of the created comment\n        \"\"\"\n        comment_data = {\n            \"post_id\": post_id,\n            \"author_id\": author_id,\n            \"text\": text,\n            \"created_at\": datetime.now(),\n            \"approved\": False,\n        }\n        comment_id = self.db.insert(\"comments\", comment_data)\n        print(f\"  [CommentService] Created comment on post {post_id} (ID: {comment_id})\")\n        return comment_id\n\n    def approve_comment(self, comment_id: int) -&gt; bool:\n        \"\"\"\n        Approve a comment for display.\n\n        Args:\n            comment_id: ID of the comment to approve\n\n        Returns:\n            True if successful, False otherwise\n        \"\"\"\n        comment = self.db.find_by_id(\"comments\", comment_id)\n        if comment:\n            comment[\"approved\"] = True\n            print(f\"  [CommentService] Approved comment ID: {comment_id}\")\n            return True\n        return False\n\n    def get_comments_for_post(self, post_id: int) -&gt; List[dict]:\n        \"\"\"\n        Get all comments for a post.\n\n        Args:\n            post_id: ID of the post\n\n        Returns:\n            List of comments\n        \"\"\"\n        comments = self.db.find_all(\"comments\")\n        return [c for c in comments if c[\"post_id\"] == post_id]\n</code></pre>"},{"location":"examples/app-example/#appsblogviewspy","title":"<code>apps/blog/views.py</code>","text":"<pre><code>\"\"\"\nBlog views.\n\nHTTP request handlers for blog-related endpoints.\n\"\"\"\n\nfrom typing import Any, Dict\n\nfrom framework.components import view\n\n\n@view\ndef list_posts() -&gt; Dict[str, Any]:\n    \"\"\"\n    List all blog posts.\n\n    Returns:\n        Response with list of posts\n    \"\"\"\n    return {\n        \"action\": \"list_posts\",\n        \"status\": \"success\",\n    }\n\n\n@view\ndef create_post(data: Dict[str, Any]) -&gt; Dict[str, Any]:\n    \"\"\"\n    Create a new blog post.\n\n    Args:\n        data: Post data including title, content, author_id\n\n    Returns:\n        Response with created post ID\n    \"\"\"\n    return {\n        \"action\": \"create_post\",\n        \"status\": \"success\",\n        \"data\": data,\n    }\n\n\n@view\ndef get_post(post_id: int) -&gt; Dict[str, Any]:\n    \"\"\"\n    Get a specific blog post.\n\n    Args:\n        post_id: ID of the post to retrieve\n\n    Returns:\n        Response with post data\n    \"\"\"\n    return {\n        \"action\": \"get_post\",\n        \"status\": \"success\",\n        \"post_id\": post_id,\n    }\n\n\n@view\ndef add_comment(data: Dict[str, Any]) -&gt; Dict[str, Any]:\n    \"\"\"\n    Add a comment to a post.\n\n    Args:\n        data: Comment data including post_id, author_id, text\n\n    Returns:\n        Response with created comment ID\n    \"\"\"\n    return {\n        \"action\": \"add_comment\",\n        \"status\": \"success\",\n        \"data\": data,\n    }\n</code></pre>"},{"location":"examples/app-example/#appsblogworkerspy","title":"<code>apps/blog/workers.py</code>","text":"<pre><code>\"\"\"\nBlog workers.\n\nBackground tasks for blog-related operations.\n\"\"\"\n\nimport time\nfrom framework.components import worker\nfrom spoc.workers import ProcessWorker\n\n\n@worker\nclass ContentIndexerWorker(ProcessWorker):\n    \"\"\"\n    Background worker for indexing blog content.\n\n    Periodically re-indexes blog posts for search functionality.\n    This runs in a separate process to avoid blocking the main application.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize the content indexer worker.\"\"\"\n        super().__init__(name=\"ContentIndexerWorker\", daemon=True)\n        self.index_interval = 300  # Re-index every 5 minutes\n\n    def setup(self) -&gt; None:\n        \"\"\"Setup the worker (runs before main loop).\"\"\"\n        print(f\"  [{self.name}] Initializing search index...\")\n        self.context.indexed_posts = 0\n        self.context.last_index_time = None\n\n    def main(self) -&gt; None:\n        \"\"\"\n        Main worker loop.\n\n        Periodically re-indexes all blog posts for search.\n        \"\"\"\n        print(f\"  [{self.name}] Started content indexing\")\n\n        while self.is_running:\n            # Simulate indexing posts\n            print(f\"  [{self.name}] Re-indexing content...\")\n            self.context.indexed_posts += 10  # Simulated\n            self.context.last_index_time = time.time()\n\n            # Wait before next index\n            time.sleep(self.index_interval)\n\n    def teardown(self) -&gt; None:\n        \"\"\"Cleanup when worker stops.\"\"\"\n        print(\n            f\"  [{self.name}] Shutting down. \"\n            f\"Total posts indexed: {self.context.indexed_posts}\"\n        )\n\n    def lifecycle(self, event_type: str, **data) -&gt; None:\n        \"\"\"Handle lifecycle events.\"\"\"\n        if event_type == \"startup\":\n            print(f\"  [{self.name}] Lifecycle: Started\")\n        elif event_type == \"shutdown\":\n            print(f\"  [{self.name}] Lifecycle: Stopped\")\n        elif event_type == \"error\":\n            print(f\"  [{self.name}] Error: {data.get('exception')}\")\n</code></pre>"},{"location":"examples/app-example/#5-main-application","title":"5. Main Application","text":""},{"location":"examples/app-example/#mainpy","title":"<code>main.py</code>","text":"<pre><code>\"\"\"\nMain application entry point.\n\nThis module bootstraps the SPOC framework, initializes all apps,\nsets up lifecycle hooks, and starts background workers.\n\"\"\"\n\nfrom pathlib import Path\nimport time\n\nfrom spoc import Framework, Schema, Hook\nfrom spoc.workers import Server\nfrom config import settings\nfrom framework.database import db\n\n\ndef init_database(module) -&gt; None:\n    \"\"\"\n    Initialize the database when models are loaded.\n\n    This hook is called when model modules are loaded, allowing\n    database setup before any data operations occur.\n\n    Args:\n        module: The module being loaded\n    \"\"\"\n    print(f\"  [Database] Initializing tables for: {module.__name__}\")\n    # In a real app, create tables, run migrations, etc.\n\n\ndef close_database(module) -&gt; None:\n    \"\"\"\n    Close database connections when shutting down.\n\n    This hook is called when the application is shutting down,\n    ensuring proper cleanup of database resources.\n\n    Args:\n        module: The module being unloaded\n    \"\"\"\n    print(f\"  [Database] Closing connections for: {module.__name__}\")\n    # In a real app, close connections, save state, etc.\n\n\ndef init_services(module) -&gt; None:\n    \"\"\"\n    Initialize services when loaded.\n\n    Args:\n        module: The service module being loaded\n    \"\"\"\n    print(f\"  [Services] Initializing: {module.__name__}\")\n\n\n# Define the application schema\nschema = Schema(\n    # Modules to load from each app (in order)\n    modules=[\"models\", \"views\", \"services\", \"workers\"],\n    # Module dependencies (ensure models load before views and services)\n    dependencies={\n        \"views\": [\"models\"],\n        \"services\": [\"models\"],\n        \"workers\": [\"models\", \"services\"],\n    },\n    # Lifecycle hooks for module initialization and cleanup\n    hooks={\n        \"models\": Hook(\n            startup=init_database,\n            shutdown=close_database,\n        ),\n        \"services\": Hook(\n            startup=init_services,\n        ),\n        \"views\": Hook(\n            startup=lambda m: print(f\"  [Views] Loaded: {m.__name__}\"),\n        ),\n        \"workers\": Hook(\n            startup=lambda m: print(f\"  [Workers] Registered: {m.__name__}\"),\n        ),\n    },\n)\n\n# Create the framework instance\nframework = Framework(\n    base_dir=settings.BASE_DIR,\n    schema=schema,\n    echo=False,\n    mode=\"strict\",\n)\n\n\ndef demonstrate_app_interaction():\n    \"\"\"\n    Demonstrate how apps interact through the framework.\n\n    Shows dependency injection, service usage, and cross-app communication.\n    \"\"\"\n    print(\"\\n\" + \"=\" * 60)\n    print(\"DEMONSTRATING APP INTERACTION\")\n    print(\"=\" * 60)\n\n    # Get services from the framework\n    UserService = framework.get_component(\"services\", \"users.UserService\")\n    PostService = framework.get_component(\"services\", \"blog.PostService\")\n    CommentService = framework.get_component(\"services\", \"blog.CommentService\")\n\n    if not all([UserService, PostService, CommentService]):\n        print(\"  [ERROR] Could not load all required services\")\n        return\n\n    # Instantiate services\n    user_service = UserService()\n    post_service = PostService()\n    comment_service = CommentService()\n\n    print(\"\\n--- Creating Users ---\")\n    user1_id = user_service.create_user(\n        username=\"alice\",\n        email=\"alice@example.com\",\n        full_name=\"Alice Johnson\",\n    )\n    user2_id = user_service.create_user(\n        username=\"bob\",\n        email=\"bob@example.com\",\n        full_name=\"Bob Smith\",\n    )\n\n    print(\"\\n--- Creating Blog Posts ---\")\n    post1_id = post_service.create_post(\n        title=\"Getting Started with SPOC\",\n        content=\"SPOC is a powerful framework for building modular applications...\",\n        author_id=user1_id,\n    )\n    post2_id = post_service.create_post(\n        title=\"Advanced SPOC Patterns\",\n        content=\"Learn about advanced patterns and best practices...\",\n        author_id=user1_id,\n    )\n\n    print(\"\\n--- Publishing Posts ---\")\n    post_service.publish_post(post1_id)\n    post_service.publish_post(post2_id)\n\n    print(\"\\n--- Adding Comments ---\")\n    comment1_id = comment_service.create_comment(\n        post_id=post1_id,\n        author_id=user2_id,\n        text=\"Great article! Very helpful.\",\n    )\n    comment2_id = comment_service.create_comment(\n        post_id=post1_id,\n        author_id=user1_id,\n        text=\"Thank you for the feedback!\",\n    )\n\n    print(\"\\n--- Approving Comments ---\")\n    comment_service.approve_comment(comment1_id)\n    comment_service.approve_comment(comment2_id)\n\n    print(\"\\n--- Summary ---\")\n    print(f\"  Total users: {len(user_service.list_users())}\")\n    print(f\"  Total posts: {len(post_service.list_posts())}\")\n    print(f\"  Published posts: {len(post_service.list_posts(published_only=True))}\")\n    print(f\"  Comments on post 1: {len(comment_service.get_comments_for_post(post1_id))}\")\n\n\ndef demonstrate_components():\n    \"\"\"Display all registered components.\"\"\"\n    print(\"\\n\" + \"=\" * 60)\n    print(\"REGISTERED COMPONENTS\")\n    print(\"=\" * 60)\n\n    # Display models\n    print(\"\\n--- Models ---\")\n    if hasattr(framework.components, \"models\"):\n        for name, model in framework.components.models.items():\n            print(f\"  \u2022 {name}: {model}\")\n\n    # Display views\n    print(\"\\n--- Views ---\")\n    if hasattr(framework.components, \"views\"):\n        for name, view in framework.components.views.items():\n            print(f\"  \u2022 {name}: {view}\")\n\n    # Display services\n    print(\"\\n--- Services ---\")\n    if hasattr(framework.components, \"services\"):\n        for name, service in framework.components.services.items():\n            print(f\"  \u2022 {name}: {service}\")\n\n    # Display workers\n    print(\"\\n--- Workers ---\")\n    if hasattr(framework.components, \"workers\"):\n        for name, worker in framework.components.workers.items():\n            print(f\"  \u2022 {name}: {worker}\")\n\n\ndef start_background_workers():\n    \"\"\"\n    Start background workers using the Server.\n\n    Demonstrates how to initialize and manage multiple workers\n    that run concurrently with the main application.\n    \"\"\"\n    print(\"\\n\" + \"=\" * 60)\n    print(\"STARTING BACKGROUND WORKERS\")\n    print(\"=\" * 60 + \"\\n\")\n\n    # Create worker server\n    server = Server(name=\"BlogPlatformServer\")\n\n    # Get worker classes from framework\n    EmailWorker = framework.get_component(\"workers\", \"users.EmailNotificationWorker\")\n    IndexWorker = framework.get_component(\"workers\", \"blog.ContentIndexerWorker\")\n\n    if EmailWorker:\n        email_worker = EmailWorker()\n        server.add_worker(email_worker)\n        print(f\"  \u2022 Added {email_worker.name}\")\n\n    if IndexWorker:\n        index_worker = IndexWorker()\n        server.add_worker(index_worker)\n        print(f\"  \u2022 Added {index_worker.name}\")\n\n    # Start all workers\n    print(\"\\n  Starting workers...\\n\")\n    server.start()\n\n    # Let workers run for a bit\n    print(\"  Workers are running (will stop in 5 seconds)...\\n\")\n    time.sleep(5)\n\n    # Stop workers\n    print(\"\\n  Stopping workers...\\n\")\n    server.stop()\n    server.join_all(timeout=2)\n\n\ndef main():\n    \"\"\"\n    Main application entry point.\n\n    Orchestrates the entire application lifecycle including:\n    1. Framework initialization\n    2. Component registration and display\n    3. Cross-app interaction demonstration\n    4. Background worker management\n    5. Graceful shutdown\n    \"\"\"\n    print(\"\\n\" + \"=\" * 60)\n    print(\"BLOG PLATFORM - SPOC APPLICATION\")\n    print(\"=\" * 60)\n    print(f\"\\nInstalled apps: {framework.installed_apps}\")\n\n    # Display all registered components\n    demonstrate_components()\n\n    # Demonstrate app interaction\n    demonstrate_app_interaction()\n\n    # Start and manage background workers\n    start_background_workers()\n\n    # Cleanup\n    print(\"\\n\" + \"=\" * 60)\n    print(\"SHUTTING DOWN APPLICATION\")\n    print(\"=\" * 60 + \"\\n\")\n\n    # Clear database\n    db.clear()\n\n    # Shutdown framework\n    framework.shutdown()\n\n    print(\"\\n\" + \"=\" * 60)\n    print(\"APPLICATION STOPPED\")\n    print(\"=\" * 60 + \"\\n\")\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"examples/app-example/#running-the-application","title":"Running the Application","text":""},{"location":"examples/app-example/#1-install-dependencies","title":"1. Install Dependencies","text":"<p>Create <code>requirements.txt</code>:</p> <pre><code>spoc&gt;=0.2.0\n</code></pre> <p>Install:</p> <pre><code>pip install -r requirements.txt\n</code></pre>"},{"location":"examples/app-example/#2-set-up-environment","title":"2. Set Up Environment","text":"<p>Copy the example environment file:</p> <pre><code>cp config/.env.example config/.env\n</code></pre> <p>Edit <code>config/.env</code> with your settings.</p>"},{"location":"examples/app-example/#3-run-the-application","title":"3. Run the Application","text":"<pre><code>python main.py\n</code></pre>"},{"location":"examples/app-example/#expected-output","title":"Expected Output","text":"<pre><code>============================================================\nBLOG PLATFORM - SPOC APPLICATION\n============================================================\n\nInstalled apps: ['users', 'blog']\n\n============================================================\nREGISTERED COMPONENTS\n============================================================\n\n--- Models ---\n  \u2022 users.User: &lt;class 'users.models.User'&gt;\n  \u2022 users.UserProfile: &lt;class 'users.models.UserProfile'&gt;\n  \u2022 blog.Post: &lt;class 'blog.models.Post'&gt;\n  \u2022 blog.Comment: &lt;class 'blog.models.Comment'&gt;\n\n--- Views ---\n  \u2022 users.register_user: &lt;function register_user at 0x...&gt;\n  \u2022 users.login_user: &lt;function login_user at 0x...&gt;\n  \u2022 users.get_profile: &lt;function get_profile at 0x...&gt;\n  \u2022 blog.list_posts: &lt;function list_posts at 0x...&gt;\n  \u2022 blog.create_post: &lt;function create_post at 0x...&gt;\n  \u2022 blog.get_post: &lt;function get_post at 0x...&gt;\n  \u2022 blog.add_comment: &lt;function add_comment at 0x...&gt;\n\n--- Services ---\n  \u2022 users.UserService: &lt;class 'users.services.UserService'&gt;\n  \u2022 blog.PostService: &lt;class 'blog.services.PostService'&gt;\n  \u2022 blog.CommentService: &lt;class 'blog.services.CommentService'&gt;\n\n--- Workers ---\n  \u2022 users.EmailNotificationWorker: &lt;class 'users.workers.EmailNotificationWorker'&gt;\n  \u2022 blog.ContentIndexerWorker: &lt;class 'blog.workers.ContentIndexerWorker'&gt;\n\n============================================================\nDEMONSTRATING APP INTERACTION\n============================================================\n\n--- Creating Users ---\n  [UserService] Created user: alice (ID: 1)\n  [UserService] Created user: bob (ID: 2)\n\n--- Creating Blog Posts ---\n  [PostService] Created post: Getting Started with SPOC (ID: 1)\n  [PostService] Created post: Advanced SPOC Patterns (ID: 2)\n\n--- Publishing Posts ---\n  [PostService] Published post ID: 1\n  [PostService] Published post ID: 2\n\n--- Adding Comments ---\n  [CommentService] Created comment on post 1 (ID: 1)\n  [CommentService] Created comment on post 1 (ID: 2)\n\n--- Approving Comments ---\n  [CommentService] Approved comment ID: 1\n  [CommentService] Approved comment ID: 2\n\n--- Summary ---\n  Total users: 2\n  Total posts: 2\n  Published posts: 2\n  Comments on post 1: 2\n\n============================================================\nSTARTING BACKGROUND WORKERS\n============================================================\n\n  \u2022 Added EmailNotificationWorker\n  \u2022 Added ContentIndexerWorker\n\n  Starting workers...\n\n  [EmailNotificationWorker] Lifecycle: Started\n  [EmailNotificationWorker] Initializing email service...\n  [EmailNotificationWorker] Started monitoring email queue\n  [ContentIndexerWorker] Lifecycle: Started\n  [ContentIndexerWorker] Initializing search index...\n  [ContentIndexerWorker] Started content indexing\n\n  Workers are running (will stop in 5 seconds)...\n\n  Stopping workers...\n\n  [EmailNotificationWorker] Shutting down. Total emails sent: 0\n  [EmailNotificationWorker] Lifecycle: Stopped\n  [ContentIndexerWorker] Shutting down. Total posts indexed: 0\n  [ContentIndexerWorker] Lifecycle: Stopped\n\n============================================================\nSHUTTING DOWN APPLICATION\n============================================================\n\n============================================================\nAPPLICATION STOPPED\n============================================================\n</code></pre>"},{"location":"examples/app-example/#key-concepts-demonstrated","title":"Key Concepts Demonstrated","text":""},{"location":"examples/app-example/#1-multi-app-architecture","title":"1. Multi-App Architecture","text":"<p>The example shows two independent apps (users, blog) that can be developed separately but work together through the framework:</p> <pre><code>INSTALLED_APPS: list = [\n    \"users\",  # User management\n    \"blog\",   # Blog functionality\n]\n</code></pre>"},{"location":"examples/app-example/#2-component-registration","title":"2. Component Registration","text":"<p>Each app registers its components using the shared registry:</p> <pre><code>from framework.components import model, service, view, worker\n\n@model\nclass User:\n    pass\n\n@service\nclass UserService:\n    pass\n</code></pre>"},{"location":"examples/app-example/#3-dependency-resolution","title":"3. Dependency Resolution","text":"<p>The schema defines how modules depend on each other:</p> <pre><code>dependencies={\n    \"views\": [\"models\"],\n    \"services\": [\"models\"],\n    \"workers\": [\"models\", \"services\"],\n}\n</code></pre> <p>This ensures models are loaded before views and services, preventing import errors.</p>"},{"location":"examples/app-example/#4-lifecycle-hooks","title":"4. Lifecycle Hooks","text":"<p>Hooks execute at specific points in the application lifecycle:</p> <pre><code>hooks={\n    \"models\": Hook(\n        startup=init_database,\n        shutdown=close_database,\n    ),\n}\n</code></pre>"},{"location":"examples/app-example/#5-cross-app-communication","title":"5. Cross-App Communication","text":"<p>Apps interact through the framework's component registry:</p> <pre><code># Get services from different apps\nUserService = framework.get_component(\"services\", \"users.UserService\")\nPostService = framework.get_component(\"services\", \"blog.PostService\")\n\n# Use them together\nuser_id = user_service.create_user(...)\npost_id = post_service.create_post(author_id=user_id, ...)\n</code></pre>"},{"location":"examples/app-example/#6-background-workers","title":"6. Background Workers","text":"<p>Workers run concurrently using threads or processes:</p> <pre><code># Thread worker for I/O-bound tasks\nclass EmailNotificationWorker(ThreadWorker):\n    pass\n\n# Process worker for CPU-bound tasks\nclass ContentIndexerWorker(ProcessWorker):\n    pass\n</code></pre>"},{"location":"examples/app-example/#7-environment-configuration","title":"7. Environment Configuration","text":"<p>Settings can be customized per environment:</p> <pre><code>[spoc]\nmode = \"development\"\n\n[spoc.apps]\nproduction = []\ndevelopment = []\n</code></pre>"},{"location":"examples/app-example/#extending-the-example","title":"Extending the Example","text":""},{"location":"examples/app-example/#add-more-apps","title":"Add More Apps","text":"<p>Create new apps following the same structure:</p> <pre><code>apps/\n\u251c\u2500\u2500 analytics/      # Analytics and reporting\n\u251c\u2500\u2500 notifications/  # Push notifications\n\u2514\u2500\u2500 search/        # Full-text search\n</code></pre>"},{"location":"examples/app-example/#add-custom-components","title":"Add Custom Components","text":"<p>Define new component types:</p> <pre><code>from framework.components import components\n\ncomponents.add_type(\"middleware\")\ncomponents.add_type(\"command\")\n</code></pre>"},{"location":"examples/app-example/#add-plugins","title":"Add Plugins","text":"<p>Create plugins for cross-cutting concerns:</p> <pre><code>PLUGINS: dict = {\n    \"middleware\": [\n        \"framework.middleware.LoggingMiddleware\",\n        \"framework.middleware.AuthMiddleware\",\n    ],\n}\n</code></pre>"},{"location":"examples/app-example/#use-real-database","title":"Use Real Database","text":"<p>Replace the in-memory database with SQLAlchemy, Django ORM, or another database library:</p> <pre><code>from sqlalchemy import create_engine\nfrom sqlalchemy.orm import sessionmaker\n\ndef init_database(module):\n    engine = create_engine(settings.DATABASE_URL)\n    Session = sessionmaker(bind=engine)\n    # Create tables, etc.\n</code></pre>"},{"location":"examples/app-example/#best-practices","title":"Best Practices","text":""},{"location":"examples/app-example/#1-separation-of-concerns","title":"1. Separation of Concerns","text":"<p>Keep each app focused on a single domain:</p> <ul> <li><code>users</code> handles authentication and user management</li> <li><code>blog</code> handles content creation and display</li> <li>Keep cross-cutting concerns in the <code>framework</code> package</li> </ul>"},{"location":"examples/app-example/#2-component-naming","title":"2. Component Naming","text":"<p>Use consistent naming conventions:</p> <ul> <li>Models: <code>User</code>, <code>Post</code>, <code>Comment</code></li> <li>Services: <code>UserService</code>, <code>PostService</code></li> <li>Views: <code>list_posts</code>, <code>create_post</code></li> <li>Workers: <code>EmailNotificationWorker</code></li> </ul>"},{"location":"examples/app-example/#3-dependency-injection","title":"3. Dependency Injection","text":"<p>Access framework components through dependency injection:</p> <pre><code>class PostService:\n    def __init__(self):\n        # Get dependencies from the framework\n        self.user_service = framework.get_component(\n            \"services\", \"users.UserService\"\n        )()\n</code></pre>"},{"location":"examples/app-example/#4-error-handling","title":"4. Error Handling","text":"<p>Implement proper error handling in services and workers:</p> <pre><code>def lifecycle(self, event_type: str, **data) -&gt; None:\n    if event_type == \"error\":\n        logger.error(f\"Worker error: {data.get('exception')}\")\n</code></pre>"},{"location":"examples/app-example/#5-testing","title":"5. Testing","text":"<p>Test components in isolation:</p> <pre><code>def test_user_service():\n    service = UserService()\n    user_id = service.create_user(\"test\", \"test@example.com\", \"Test User\")\n    assert user_id &gt; 0\n</code></pre>"},{"location":"examples/app-example/#troubleshooting","title":"Troubleshooting","text":""},{"location":"examples/app-example/#components-not-found","title":"Components Not Found","text":"<p>Problem: <code>framework.get_component()</code> returns <code>None</code>.</p> <p>Solution: Ensure: - The module is listed in <code>schema.modules</code> - The component is decorated with the correct decorator - The app is in <code>INSTALLED_APPS</code></p>"},{"location":"examples/app-example/#circular-dependencies","title":"Circular Dependencies","text":"<p>Problem: <code>CircularDependencyError</code> during startup.</p> <p>Solution: Review your <code>schema.dependencies</code> and restructure to remove cycles.</p>"},{"location":"examples/app-example/#workers-not-starting","title":"Workers Not Starting","text":"<p>Problem: Workers don't run or stop immediately.</p> <p>Solution: Check: - Workers inherit from <code>ThreadWorker</code> or <code>ProcessWorker</code> - The <code>main()</code> method has a loop that checks <code>self.is_running</code> - The worker is added to the server before calling <code>start()</code></p>"},{"location":"examples/app-example/#module-import-errors","title":"Module Import Errors","text":"<p>Problem: <code>ModuleNotFoundError</code> when loading apps.</p> <p>Solution: Ensure: - Each app directory has <code>__init__.py</code> - Module names match file names - Dependencies are declared in the schema</p>"},{"location":"examples/app-example/#summary","title":"Summary","text":"<p>This example demonstrates a production-ready SPOC application with:</p> <ul> <li>Two apps (users, blog) with proper separation of concerns</li> <li>Multiple component types (models, views, services, workers)</li> <li>Cross-app dependencies through the framework registry</li> <li>Lifecycle hooks for database initialization</li> <li>Background workers using threads and processes</li> <li>Environment configuration for different deployment scenarios</li> </ul> <p>You can use this as a starting template for your own SPOC applications, extending it with additional apps, components, and functionality as needed.</p>"},{"location":"examples/app-example/#next-steps","title":"Next Steps","text":"<ul> <li>Read the Framework API for advanced features</li> <li>Explore Lifecycle Hooks for more hook patterns</li> <li>Check out Workers for worker best practices</li> <li>Review Configuration for environment management</li> </ul>"},{"location":"examples/basic/","title":"Basic Example","text":"<p>This guide demonstrates a minimal SPOC application from scratch. You'll build a complete, runnable example that shows the core workflow: project structure, configuration, component registration, and lifecycle management.</p>"},{"location":"examples/basic/#what-youll-build","title":"What You'll Build","text":"<p>A simple greeting application that:</p> <ul> <li>Organizes code into a modular app structure</li> <li>Defines and registers components</li> <li>Manages application lifecycle (startup/shutdown)</li> <li>Accesses components through the framework</li> </ul>"},{"location":"examples/basic/#project-structure","title":"Project Structure","text":"<p>Create the following directory structure:</p> <pre><code>my_project/\n\u251c\u2500\u2500 config/\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 settings.py\n\u2502   \u2514\u2500\u2500 spoc.toml\n\u251c\u2500\u2500 apps/\n\u2502   \u2514\u2500\u2500 hello/\n\u2502       \u251c\u2500\u2500 __init__.py\n\u2502       \u2514\u2500\u2500 greetings.py\n\u2514\u2500\u2500 main.py\n</code></pre>"},{"location":"examples/basic/#step-1-configuration-files","title":"Step 1: Configuration Files","text":""},{"location":"examples/basic/#configinitpy","title":"config/init.py","text":"<p>Create an empty <code>__init__.py</code> to make <code>config</code> a Python package:</p> <pre><code>\"\"\"Configuration package.\"\"\"\n</code></pre>"},{"location":"examples/basic/#configsettingspy","title":"config/settings.py","text":"<p>Define your project settings:</p> <pre><code>\"\"\"Project settings configuration.\"\"\"\n\nfrom pathlib import Path\n\n# Base directory of the project - used by the framework to locate apps\nBASE_DIR: Path = Path(__file__).resolve().parent.parent\n\n# Apps to always load (core apps)\nINSTALLED_APPS: list = [\n    \"hello\",\n]\n\n# Plugins for extending functionality\n# Middleware and hooks can be registered here\nPLUGINS: dict = {\n    \"middleware\": [],\n    \"hooks\": [],\n}\n</code></pre> <p>Key Points:</p> <ul> <li><code>BASE_DIR</code> points to the project root (parent of config directory)</li> <li><code>INSTALLED_APPS</code> lists apps that load in all environments</li> <li><code>PLUGINS</code> is a dictionary for middleware and hook extensions</li> </ul>"},{"location":"examples/basic/#configspoctoml","title":"config/spoc.toml","text":"<p>Define environment-specific configuration:</p> <pre><code># Application Configuration\n[spoc]\nmode = \"development\"  # Options: development, staging, production\ndebug = true\n\n# Apps by Environment Mode\n# These apps load based on the active mode\n[spoc.apps]\nproduction = []    # Apps loaded only in production\nstaging = []       # Apps loaded in staging + production\ndevelopment = []   # Apps loaded in development + staging + production\n\n# Additional Plugins\n[spoc.plugins]\nmiddleware = []\nhooks = []\n</code></pre> <p>How Modes Work:</p> <ul> <li><code>development</code> mode loads: development + staging + production apps</li> <li><code>staging</code> mode loads: staging + production apps</li> <li><code>production</code> mode loads: production apps only</li> <li><code>INSTALLED_APPS</code> from settings.py always loads regardless of mode</li> </ul>"},{"location":"examples/basic/#step-2-create-your-app","title":"Step 2: Create Your App","text":""},{"location":"examples/basic/#appshelloinitpy","title":"apps/hello/init.py","text":"<p>Create an empty <code>__init__.py</code> to make <code>hello</code> a Python package:</p> <pre><code>\"\"\"Hello app - A simple greeting application.\"\"\"\n</code></pre>"},{"location":"examples/basic/#appshellogreetingspy","title":"apps/hello/greetings.py","text":"<p>Define your app's components with decorators:</p> <pre><code>\"\"\"Greetings module - Components for greeting functionality.\"\"\"\n\nfrom spoc import Components\n\n# Create a component registry for this module\ncomponents = Components()\n\n# Register component type\ncomponents.add_type(\"service\")\n\n\n@components.register(\"service\", config={\"default_language\": \"en\"})\nclass GreetingService:\n    \"\"\"Service for generating greetings in different languages.\"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize the greeting service.\"\"\"\n        self.greetings = {\n            \"en\": \"Hello\",\n            \"es\": \"Hola\",\n            \"fr\": \"Bonjour\",\n            \"de\": \"Hallo\",\n        }\n\n    def greet(self, name: str, language: str = \"en\") -&gt; str:\n        \"\"\"\n        Generate a greeting message.\n\n        Args:\n            name: Name to greet\n            language: Language code (en, es, fr, de)\n\n        Returns:\n            Formatted greeting message\n        \"\"\"\n        greeting = self.greetings.get(language, self.greetings[\"en\"])\n        return f\"{greeting}, {name}!\"\n\n    def list_languages(self) -&gt; list[str]:\n        \"\"\"\n        Get list of supported languages.\n\n        Returns:\n            List of language codes\n        \"\"\"\n        return list(self.greetings.keys())\n\n\n@components.register(\"service\", config={\"max_length\": 100})\ndef farewell_message(name: str) -&gt; str:\n    \"\"\"\n    Generate a farewell message.\n\n    This demonstrates registering a function as a component.\n\n    Args:\n        name: Name to say goodbye to\n\n    Returns:\n        Farewell message\n    \"\"\"\n    return f\"Goodbye, {name}! See you soon!\"\n</code></pre> <p>Component Registration:</p> <ul> <li><code>Components()</code> creates a registry for component types</li> <li><code>add_type(\"service\")</code> registers the \"service\" component type</li> <li><code>@components.register(\"service\")</code> marks classes/functions as components</li> <li><code>config</code> parameter attaches metadata to components</li> </ul>"},{"location":"examples/basic/#step-3-main-application","title":"Step 3: Main Application","text":""},{"location":"examples/basic/#mainpy","title":"main.py","text":"<p>Create the framework and run your application:</p> <pre><code>\"\"\"Main application entry point.\"\"\"\n\nfrom pathlib import Path\nfrom spoc import Framework, Schema, Hook\n\n# Import settings\nfrom config import settings\n\n\ndef init_greetings(module):\n    \"\"\"\n    Hook called when greetings module loads.\n\n    Args:\n        module: The loaded module instance\n    \"\"\"\n    print(f\"\u2713 Initialized: {module.__name__}\")\n\n\ndef cleanup_greetings(module):\n    \"\"\"\n    Hook called when greetings module unloads.\n\n    Args:\n        module: The module being unloaded\n    \"\"\"\n    print(f\"\u2717 Cleaning up: {module.__name__}\")\n\n\n# Define the application schema\nschema = Schema(\n    # Modules to load from each app\n    modules=[\"greetings\"],\n\n    # Module dependencies (greetings has no dependencies)\n    dependencies={},\n\n    # Lifecycle hooks for each module\n    hooks={\n        \"greetings\": Hook(\n            startup=init_greetings,\n            shutdown=cleanup_greetings,\n        ),\n    },\n)\n\n# Create the framework instance\n# The framework automatically calls startup() during initialization\nframework = Framework(\n    base_dir=settings.BASE_DIR,\n    schema=schema,\n    echo=False,  # Set to True to see detailed loading information\n    mode=\"strict\",  # \"strict\" requires all modules in all apps, \"loose\" allows missing modules\n)\n\n\ndef main():\n    \"\"\"Run the application.\"\"\"\n    print(\"\\n\" + \"=\" * 60)\n    print(\"SPOC Application - Basic Example\")\n    print(\"=\" * 60 + \"\\n\")\n\n    # Display installed apps\n    print(f\"Installed Apps: {framework.installed_apps}\")\n    print()\n\n    # Access the component registry\n    print(\"Registered Components:\")\n    print(\"-\" * 60)\n\n    # Get all service components\n    if hasattr(framework.components, \"service\"):\n        for name, component in framework.components.service.items():\n            print(f\"  \u2022 {name}: {component}\")\n    print()\n\n    # Use a specific component - Get the GreetingService class\n    print(\"Using Components:\")\n    print(\"-\" * 60)\n\n    greeting_service_cls = framework.get_component(\"service\", \"hello.GreetingService\")\n    if greeting_service_cls:\n        # Instantiate the service\n        service = greeting_service_cls()\n\n        # Use the service\n        print(f\"  {service.greet('World')}\")\n        print(f\"  {service.greet('Mundo', 'es')}\")\n        print(f\"  {service.greet('Monde', 'fr')}\")\n        print(f\"  Supported languages: {service.list_languages()}\")\n        print()\n\n    # Use the farewell function component\n    farewell_fn = framework.get_component(\"service\", \"hello.farewell_message\")\n    if farewell_fn:\n        print(f\"  {farewell_fn('World')}\")\n        print()\n\n    # Access component metadata\n    print(\"Component Metadata:\")\n    print(\"-\" * 60)\n\n    if greeting_service_cls and hasattr(greeting_service_cls, \"__spoc__\"):\n        metadata = greeting_service_cls.__spoc__\n        print(f\"  Config: {metadata.config}\")\n        print(f\"  Metadata: {metadata.metadata}\")\n        print()\n\n    # Application is running...\n    print(\"=\" * 60)\n    print(\"Application Running - Press Ctrl+C to stop\")\n    print(\"=\" * 60 + \"\\n\")\n\n    # Clean shutdown (framework handles this automatically on exit)\n    # But you can manually call it when needed\n    framework.shutdown()\n\n    print(\"\\n\" + \"=\" * 60)\n    print(\"Application Stopped\")\n    print(\"=\" * 60 + \"\\n\")\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"examples/basic/#step-4-run-the-application","title":"Step 4: Run the Application","text":"<p>Execute your application from the project root:</p> <pre><code>cd my_project\npython main.py\n</code></pre>"},{"location":"examples/basic/#expected-output","title":"Expected Output","text":"<pre><code>apps_path C:\\path\\to\\my_project\\apps\n\u2713 Initialized: hello.greetings\n\n============================================================\nSPOC Application - Basic Example\n============================================================\n\nInstalled Apps: ['hello']\n\nRegistered Components:\n------------------------------------------------------------\n  \u2022 hello.GreetingService: &lt;class 'hello.greetings.GreetingService'&gt;\n  \u2022 hello.farewell_message: &lt;function farewell_message at 0x...&gt;\n\nUsing Components:\n------------------------------------------------------------\n  Hello, World!\n  Hola, Mundo!\n  Bonjour, Monde!\n  Supported languages: ['en', 'es', 'fr', 'de']\n\n  Goodbye, World! See you soon!\n\nComponent Metadata:\n------------------------------------------------------------\n  Config: {'default_language': 'en'}\n  Metadata: {'type': 'service'}\n\n============================================================\nApplication Running - Press Ctrl+C to stop\n============================================================\n\n\u2717 Cleaning up: hello.greetings\n\n============================================================\nApplication Stopped\n============================================================\n</code></pre>"},{"location":"examples/basic/#understanding-the-code","title":"Understanding the Code","text":""},{"location":"examples/basic/#component-registration","title":"Component Registration","text":"<p>Components are the building blocks of your application:</p> <pre><code>from spoc import Components\n\ncomponents = Components()\ncomponents.add_type(\"service\")\n\n@components.register(\"service\", config={\"key\": \"value\"})\nclass MyService:\n    pass\n</code></pre> <p>Process:</p> <ol> <li>Create a <code>Components</code> registry</li> <li>Add component types with <code>add_type()</code></li> <li>Use <code>@components.register()</code> decorator to mark classes/functions</li> <li>Optionally attach configuration metadata</li> </ol>"},{"location":"examples/basic/#framework-schema","title":"Framework Schema","text":"<p>The schema defines your application structure:</p> <pre><code>schema = Schema(\n    modules=[\"greetings\"],      # Modules to load from each app\n    dependencies={},             # Module dependencies\n    hooks={                      # Lifecycle hooks\n        \"greetings\": Hook(\n            startup=init_fn,\n            shutdown=cleanup_fn,\n        ),\n    },\n)\n</code></pre> <p>Key Elements:</p> <ul> <li>modules: List of Python module names to load from each app</li> <li>dependencies: Dict mapping modules to their required dependencies</li> <li>hooks: Dict mapping modules to startup/shutdown functions</li> </ul>"},{"location":"examples/basic/#framework-initialization","title":"Framework Initialization","text":"<p>The framework orchestrates your application:</p> <pre><code>framework = Framework(\n    base_dir=settings.BASE_DIR,  # Project root directory\n    schema=schema,                # Application schema\n    echo=False,                   # Debug output flag\n    mode=\"strict\",                # Module validation mode\n)\n</code></pre> <p>Important:</p> <ul> <li>Framework automatically calls <code>startup()</code> during initialization</li> <li><code>mode=\"strict\"</code> requires all modules exist in all apps</li> <li><code>mode=\"loose\"</code> allows apps to have missing modules</li> <li>Framework handles cleanup automatically, but you can call <code>shutdown()</code> manually</li> </ul>"},{"location":"examples/basic/#accessing-components","title":"Accessing Components","text":"<p>Retrieve components from the framework:</p> <pre><code># Get a specific component by type and name\ncomponent = framework.get_component(\"service\", \"hello.GreetingService\")\n\n# Get all components of a type\nall_services = framework.components.service.values()\n\n# Check if type exists\nif hasattr(framework.components, \"service\"):\n    # Access the service registry\n    services = framework.components.service\n</code></pre>"},{"location":"examples/basic/#lifecycle-flow","title":"Lifecycle Flow","text":"<p>The framework follows this lifecycle:</p> <pre><code>sequenceDiagram\n    participant User\n    participant Framework\n    participant Importer\n    participant Module\n\n    User-&gt;&gt;Framework: Framework(base_dir, schema)\n    Framework-&gt;&gt;Framework: Load configuration\n    Framework-&gt;&gt;Framework: Register apps &amp; modules\n    Framework-&gt;&gt;Framework: startup() (automatic)\n\n    Framework-&gt;&gt;Importer: Load modules by dependency order\n    Importer-&gt;&gt;Module: Import hello.greetings\n    Importer-&gt;&gt;Module: Execute startup hook\n    Module--&gt;&gt;Framework: Module loaded\n\n    Note over User,Framework: Application runs...\n\n    User-&gt;&gt;Framework: shutdown()\n    Framework-&gt;&gt;Importer: Unload modules (reverse order)\n    Importer-&gt;&gt;Module: Execute shutdown hook\n    Module--&gt;&gt;Framework: Module unloaded</code></pre>"},{"location":"examples/basic/#key-takeaways","title":"Key Takeaways","text":""},{"location":"examples/basic/#1-apps-directory","title":"1. Apps Directory","text":"<p>SPOC automatically looks for apps in the <code>apps/</code> directory under <code>BASE_DIR</code>:</p> <pre><code>my_project/\n\u251c\u2500\u2500 apps/           # Framework scans this directory\n\u2502   \u2514\u2500\u2500 hello/      # Each subdirectory is an app\n</code></pre>"},{"location":"examples/basic/#2-module-loading","title":"2. Module Loading","text":"<p>Modules are loaded based on the schema:</p> <ul> <li>Framework loads modules from each installed app</li> <li>Modules load in dependency order</li> <li>Startup hooks execute after module import</li> <li>Shutdown hooks execute in reverse order</li> </ul>"},{"location":"examples/basic/#3-component-discovery","title":"3. Component Discovery","text":"<p>Components are automatically discovered and registered:</p> <ul> <li>Each module can have its own <code>Components</code> registry</li> <li>Framework collects all registered components</li> <li>Access components via <code>framework.components.&lt;type&gt;</code></li> <li>Components retain their metadata and configuration</li> </ul>"},{"location":"examples/basic/#4-environment-management","title":"4. Environment Management","text":"<p>Control app loading by environment:</p> <pre><code>[spoc]\nmode = \"production\"\n\n[spoc.apps]\nproduction = [\"core\", \"api\"]\ndevelopment = [\"core\", \"api\", \"debug\"]\n</code></pre>"},{"location":"examples/basic/#common-patterns","title":"Common Patterns","text":""},{"location":"examples/basic/#pattern-1-multiple-component-types","title":"Pattern 1: Multiple Component Types","text":"<p>Register different types of components:</p> <pre><code>from spoc import Components\n\ncomponents = Components()\ncomponents.add_type(\"model\")\ncomponents.add_type(\"service\")\ncomponents.add_type(\"view\")\n\n@components.register(\"model\")\nclass User:\n    pass\n\n@components.register(\"service\")\nclass UserService:\n    pass\n\n@components.register(\"view\")\ndef user_list_view():\n    pass\n</code></pre>"},{"location":"examples/basic/#pattern-2-shared-component-registry","title":"Pattern 2: Shared Component Registry","text":"<p>Create a shared registry in a common module:</p> <pre><code># framework/components.py\nfrom spoc import Components\n\ncomponents = Components(\"model\", \"service\", \"view\")\n\n# Export decorators for convenience\nmodel = lambda obj: components.register(\"model\", obj)\nservice = lambda obj: components.register(\"service\", obj)\nview = lambda obj: components.register(\"view\", obj)\n</code></pre> <p>Use in your apps:</p> <pre><code># apps/hello/models.py\nfrom framework.components import model\n\n@model\nclass Greeting:\n    pass\n</code></pre>"},{"location":"examples/basic/#pattern-3-component-configuration","title":"Pattern 3: Component Configuration","text":"<p>Attach metadata to components:</p> <pre><code>@components.register(\n    \"service\",\n    config={\n        \"timeout\": 30,\n        \"retry\": 3,\n        \"cache\": True,\n    }\n)\nclass APIService:\n    def __init__(self):\n        # Access config from __spoc__ attribute\n        config = self.__spoc__.config\n        self.timeout = config.get(\"timeout\", 10)\n</code></pre>"},{"location":"examples/basic/#next-steps","title":"Next Steps","text":"<p>Now that you understand the basics:</p> <ol> <li>Add More Apps: Create additional apps in the <code>apps/</code> directory</li> <li>Define Dependencies: Explore module dependencies in Quick Start</li> <li>Use Lifecycle Hooks: Learn advanced hook patterns in Framework API</li> <li>Explore Plugins: Extend functionality in the Advanced Guide</li> <li>Review Examples: Check the <code>examples/</code> directory in the repository</li> </ol>"},{"location":"examples/basic/#troubleshooting","title":"Troubleshooting","text":""},{"location":"examples/basic/#app-not-loading","title":"App Not Loading","text":"<p>Problem: Your app doesn't appear in <code>framework.installed_apps</code>.</p> <p>Solution:</p> <ul> <li>Verify the app directory exists in <code>apps/</code></li> <li>Check the app has an <code>__init__.py</code> file</li> <li>Ensure the app is listed in <code>INSTALLED_APPS</code> or <code>[spoc.apps.&lt;mode&gt;]</code></li> <li>Verify <code>mode</code> matches your environment setting</li> </ul>"},{"location":"examples/basic/#module-import-error","title":"Module Import Error","text":"<p>Problem: <code>ModuleNotFoundError</code> when loading modules.</p> <p>Solution:</p> <ul> <li>Check module filename matches schema (e.g., <code>greetings.py</code> for \"greetings\")</li> <li>Ensure module is listed in <code>schema.modules</code></li> <li>Verify no syntax errors in the module</li> <li>Check dependencies are declared correctly</li> </ul>"},{"location":"examples/basic/#component-not-found","title":"Component Not Found","text":"<p>Problem: <code>framework.get_component()</code> returns <code>None</code>.</p> <p>Solution:</p> <ul> <li>Verify component is decorated with <code>@components.register()</code></li> <li>Check component type matches (e.g., \"service\" not \"services\")</li> <li>Ensure component name uses correct format: <code>\"app.ComponentName\"</code></li> <li>Confirm module loaded successfully (check startup output)</li> </ul>"},{"location":"examples/basic/#strict-mode-errors","title":"Strict Mode Errors","text":"<p>Problem: Framework raises errors about missing modules.</p> <p>Solution:</p> <ul> <li>Set <code>mode=\"loose\"</code> to allow missing modules</li> <li>Or create all required modules in all apps</li> <li>Or remove apps that don't match the schema</li> </ul>"},{"location":"examples/basic/#summary","title":"Summary","text":"<p>You've learned how to:</p> <ul> <li>Structure a minimal SPOC project</li> <li>Configure settings and environment modes</li> <li>Create apps with components</li> <li>Define schemas with modules and hooks</li> <li>Initialize and manage the framework lifecycle</li> <li>Access and use registered components</li> </ul> <p>This basic example provides a foundation for building more complex SPOC applications. Continue to the Quick Start Guide for multi-app examples and advanced patterns.</p>"},{"location":"getting-started/configuration/","title":"Configuration","text":"<p>SPOC provides a flexible and powerful configuration system that combines TOML files, Python modules, and environment-specific settings. This guide covers how to configure your SPOC application effectively.</p>"},{"location":"getting-started/configuration/#overview","title":"Overview","text":"<p>The SPOC configuration system consists of three main components:</p> <ol> <li>spoc.toml - TOML-based project configuration</li> <li>Settings Module - Python-based settings (settings.py, config.py, or configuration.py)</li> <li>Environment Files - Mode-specific environment variables (.env/*.toml)</li> </ol> <p>These components are loaded and merged into a <code>Config</code> object that's available throughout your application.</p>"},{"location":"getting-started/configuration/#configuration-loading","title":"Configuration Loading","text":""},{"location":"getting-started/configuration/#the-config-object","title":"The Config Object","text":"<p>The <code>Config</code> dataclass is a frozen (immutable) container that holds all configuration data:</p> <pre><code>from dataclasses import dataclass\nfrom typing import Any, Dict\n\n@dataclass(frozen=True)\nclass Config:\n    \"\"\"Configuration container for the framework.\"\"\"\n\n    project: Dict[str, Any]      # From spoc.toml\n    settings: Any                # From settings.py\n    environment: Any             # From .env/*.toml\n</code></pre>"},{"location":"getting-started/configuration/#loading-functions","title":"Loading Functions","text":"<p>SPOC provides three core functions for loading configuration:</p>"},{"location":"getting-started/configuration/#load_spoc_tomlbase_dir","title":"load_spoc_toml(base_dir)","text":"<p>Loads and validates the SPOC TOML configuration file.</p> <pre><code>from pathlib import Path\nfrom spoc.core.config_loader import load_spoc_toml\n\nconfig = load_spoc_toml(Path(\"./my_project\"))\n# Returns: dict with validated SPOC configuration\n</code></pre> <p>Search Locations:</p> <ol> <li><code>{base_dir}/config/spoc.toml</code></li> <li><code>{base_dir}/spoc.toml</code></li> </ol> <p>If no file is found, returns a default minimal configuration with a warning.</p>"},{"location":"getting-started/configuration/#load_configurationbase_dir","title":"load_configuration(base_dir)","text":"<p>Discovers and imports the Python settings module.</p> <pre><code>from pathlib import Path\nfrom spoc.core.config_loader import load_configuration\n\nsettings = load_configuration(Path(\"./my_project\"))\n# Returns: ModuleType with settings attributes\n</code></pre> <p>Search Locations:</p> <p>The function searches for these module names in order:</p> <ul> <li><code>settings</code></li> <li><code>config</code></li> <li><code>configuration</code></li> </ul> <p>In these directories:</p> <ol> <li><code>{base_dir}/config/</code></li> <li><code>{base_dir}/conf/</code></li> <li><code>{base_dir}/</code> (project root)</li> </ol> <p>Supports both:</p> <ul> <li>Python files: <code>settings.py</code>, <code>config.py</code>, <code>configuration.py</code></li> <li>Python packages: <code>settings/__init__.py</code>, <code>config/__init__.py</code></li> </ul>"},{"location":"getting-started/configuration/#load_environmentbase_dir-mode","title":"load_environment(base_dir, mode)","text":"<p>Loads environment-specific configuration from TOML files.</p> <pre><code>from pathlib import Path\nfrom spoc.core.config_loader import load_environment\n\nenv = load_environment(Path(\"./my_project\"), \"development\")\n# Returns: dict with environment variables\n</code></pre> <p>Search Locations:</p> <ol> <li><code>{base_dir}/config/.env/{mode}.toml</code></li> <li><code>{base_dir}/.env/{mode}.toml</code></li> </ol> <p>Falls back to <code>default.toml</code> if mode-specific file is not found.</p>"},{"location":"getting-started/configuration/#project-structure","title":"Project Structure","text":"<p>A typical SPOC project configuration looks like this:</p> <pre><code>my_project/\n\u251c\u2500\u2500 config/\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 settings.py          # Python settings module\n\u2502   \u251c\u2500\u2500 spoc.toml            # SPOC configuration\n\u2502   \u2514\u2500\u2500 .env/                # Environment variables\n\u2502       \u251c\u2500\u2500 development.toml\n\u2502       \u251c\u2500\u2500 staging.toml\n\u2502       \u251c\u2500\u2500 production.toml\n\u2502       \u2514\u2500\u2500 default.toml\n\u251c\u2500\u2500 apps/\n\u2502   \u251c\u2500\u2500 auth/\n\u2502   \u251c\u2500\u2500 core/\n\u2502   \u2514\u2500\u2500 api/\n\u2514\u2500\u2500 main.py\n</code></pre>"},{"location":"getting-started/configuration/#spoctoml-configuration","title":"spoc.toml Configuration","text":"<p>The <code>spoc.toml</code> file defines your project's core configuration using TOML format.</p>"},{"location":"getting-started/configuration/#basic-structure","title":"Basic Structure","text":"<pre><code># Application Configuration\n[spoc]\nmode = \"development\"  # Options: development, staging, production\ndebug = true\n\n# Installed Apps by Mode\n[spoc.apps]\nproduction = [\"auth\", \"core\"]\nstaging = [\"auth\", \"core\", \"admin\"]\ndevelopment = [\"auth\", \"core\", \"admin\", \"demo\"]\n\n# Additional Components (Plugins and Hooks)\n[spoc.plugins]\nmiddleware = [\"demo.extras.middleware\"]\nhooks = [\"demo.extras.hook\"]\ndatabase = [\"db.backends.sqlite3\", \"db.backends.postgres\"]\n</code></pre>"},{"location":"getting-started/configuration/#configuration-schema","title":"Configuration Schema","text":"<p>The SPOC configuration must follow this schema:</p> <pre><code>{\n    \"spoc\": {\n        \"mode\": str,        # Application mode\n        \"debug\": bool,      # Debug flag\n        \"apps\": dict,       # Apps by mode\n        \"plugins\": dict     # Plugin groups\n    }\n}\n</code></pre>"},{"location":"getting-started/configuration/#application-modes","title":"Application Modes","text":"<p>SPOC supports three application modes with cascading app loading:</p> <ul> <li>production: Loads only production apps</li> <li>staging: Loads staging + production apps</li> <li>development: Loads development + staging + production apps</li> </ul> <p>Example:</p> <pre><code>[spoc]\nmode = \"development\"\n\n[spoc.apps]\nproduction = [\"auth\", \"core\"]\nstaging = [\"admin\"]\ndevelopment = [\"demo\", \"debug_toolbar\"]\n</code></pre> <p>In development mode, SPOC will load: <code>demo</code>, <code>debug_toolbar</code>, <code>admin</code>, <code>auth</code>, <code>core</code></p>"},{"location":"getting-started/configuration/#plugins-configuration","title":"Plugins Configuration","text":"<p>Plugins are organized into groups. Each group can contain multiple plugin URIs:</p> <pre><code>[spoc.plugins]\nmiddleware = [\n    \"myapp.middleware.auth\",\n    \"myapp.middleware.logging\",\n    \"myapp.middleware.cors\"\n]\n\nhooks = [\n    \"myapp.hooks.startup\",\n    \"myapp.hooks.shutdown\"\n]\n\ndatabase = [\n    \"db.backends.sqlite3\",\n    \"db.backends.postgres\"\n]\n</code></pre> <p>Plugins are loaded using URI format and can be combined with settings-based plugins.</p>"},{"location":"getting-started/configuration/#settings-module","title":"Settings Module","text":"<p>The settings module is a Python file or package containing your application configuration.</p>"},{"location":"getting-started/configuration/#basic-settings-file","title":"Basic Settings File","text":"<p>Create a <code>config/settings.py</code> file:</p> <pre><code>\"\"\"Application Settings\"\"\"\n\nfrom pathlib import Path\n\n# Base Directory\nBASE_DIR: Path = Path(__file__).resolve().parent.parent\n\n# Installed Apps\nINSTALLED_APPS: list = [\n    \"core\",\n    \"auth\",\n    \"api\",\n]\n\n# Plugins\nPLUGINS: dict = {\n    \"middleware\": [\"demo.extras.middleware\"],\n    \"hooks\": [\"demo.extras.hook\"],\n}\n\n# Database Configuration\nDATABASE = {\n    \"driver\": \"sqlite3\",\n    \"name\": BASE_DIR / \"db.sqlite3\",\n    \"options\": {\n        \"timeout\": 30,\n        \"check_same_thread\": False,\n    }\n}\n\n# Security Settings\nSECRET_KEY = \"your-secret-key-here\"\nALLOWED_HOSTS = [\"localhost\", \"127.0.0.1\"]\n\n# Application Settings\nDEBUG = True\nLOG_LEVEL = \"INFO\"\n</code></pre>"},{"location":"getting-started/configuration/#settings-discovery","title":"Settings Discovery","text":"<p>SPOC automatically discovers your settings module in these locations:</p> <p>As a Python file:</p> <pre><code>config/settings.py\nconfig/config.py\nconfig/configuration.py\nconf/settings.py\nsettings.py  # project root\n</code></pre> <p>As a Python package:</p> <pre><code>config/settings/__init__.py\nconfig/config/__init__.py\n</code></pre>"},{"location":"getting-started/configuration/#accessing-settings","title":"Accessing Settings","text":"<p>Once the framework is initialized, access settings through the config object:</p> <pre><code>from spoc.framework import Framework, Schema\n\nframework = Framework(base_dir=Path(\"./\"), schema=schema)\n\n# Access settings\ndatabase = framework.config.settings.DATABASE\ndebug_mode = framework.config.settings.DEBUG\napps = framework.config.settings.INSTALLED_APPS\n</code></pre>"},{"location":"getting-started/configuration/#environment-variables","title":"Environment Variables","text":"<p>Environment-specific configuration is stored in TOML files within the <code>.env</code> directory.</p>"},{"location":"getting-started/configuration/#environment-file-structure","title":"Environment File Structure","text":"<pre><code>config/.env/\n\u251c\u2500\u2500 development.toml   # Development environment\n\u251c\u2500\u2500 staging.toml       # Staging environment\n\u251c\u2500\u2500 production.toml    # Production environment\n\u2514\u2500\u2500 default.toml       # Default fallback\n</code></pre> <p>Or alternatively:</p> <pre><code>.env/\n\u251c\u2500\u2500 development.toml\n\u251c\u2500\u2500 staging.toml\n\u251c\u2500\u2500 production.toml\n\u2514\u2500\u2500 default.toml\n</code></pre>"},{"location":"getting-started/configuration/#environment-file-format","title":"Environment File Format","text":"<p>Each environment file uses TOML format with an <code>[env]</code> section:</p> <p>config/.env/development.toml:</p> <pre><code>[env]\nDATABASE_URL = \"postgresql://localhost/myapp_dev\"\nDEBUG = \"true\"\nAPI_KEY = \"dev-key-1234\"\nCACHE_BACKEND = \"redis://localhost:6379/0\"\nLOG_LEVEL = \"DEBUG\"\n</code></pre> <p>config/.env/production.toml:</p> <pre><code>[env]\nDATABASE_URL = \"postgresql://prod-server/myapp\"\nDEBUG = \"false\"\nAPI_KEY = \"prod-key-secure\"\nCACHE_BACKEND = \"redis://prod-cache:6379/0\"\nLOG_LEVEL = \"WARNING\"\nSENTRY_DSN = \"https://xxx@sentry.io/yyy\"\n</code></pre> <p>config/.env/default.toml:</p> <pre><code>[env]\nDATABASE_URL = \"sqlite:///default.db\"\nDEBUG = \"false\"\nLOG_LEVEL = \"INFO\"\n</code></pre>"},{"location":"getting-started/configuration/#accessing-environment-variables","title":"Accessing Environment Variables","text":"<p>Access environment variables through the config object:</p> <pre><code>from spoc.framework import Framework, Schema\n\nframework = Framework(base_dir=Path(\"./\"), schema=schema)\n\n# Access environment variables\ndb_url = framework.config.environment.get(\"DATABASE_URL\")\ndebug = framework.config.environment.get(\"DEBUG\") == \"true\"\napi_key = framework.config.environment.get(\"API_KEY\")\n</code></pre>"},{"location":"getting-started/configuration/#complete-configuration-example","title":"Complete Configuration Example","text":"<p>Here's a complete example showing all configuration components working together:</p>"},{"location":"getting-started/configuration/#project-structure_1","title":"Project Structure","text":"<pre><code>my_project/\n\u251c\u2500\u2500 config/\n\u2502   \u251c\u2500\u2500 settings.py\n\u2502   \u251c\u2500\u2500 spoc.toml\n\u2502   \u2514\u2500\u2500 .env/\n\u2502       \u251c\u2500\u2500 development.toml\n\u2502       \u251c\u2500\u2500 production.toml\n\u2502       \u2514\u2500\u2500 default.toml\n\u251c\u2500\u2500 apps/\n\u2502   \u251c\u2500\u2500 core/\n\u2502   \u251c\u2500\u2500 auth/\n\u2502   \u2514\u2500\u2500 api/\n\u2514\u2500\u2500 main.py\n</code></pre>"},{"location":"getting-started/configuration/#configspoctoml","title":"config/spoc.toml","text":"<pre><code>[spoc]\nmode = \"development\"\ndebug = true\n\n[spoc.apps]\nproduction = [\"core\", \"auth\"]\nstaging = [\"api\"]\ndevelopment = [\"demo\"]\n\n[spoc.plugins]\nmiddleware = [\"core.middleware.auth\", \"core.middleware.logging\"]\n</code></pre>"},{"location":"getting-started/configuration/#configsettingspy","title":"config/settings.py","text":"<pre><code>\"\"\"Application Settings\"\"\"\n\nfrom pathlib import Path\n\nBASE_DIR: Path = Path(__file__).resolve().parent.parent\n\n# Apps installed via Python settings\nINSTALLED_APPS: list = [\n    \"core\",\n    \"auth\",\n]\n\n# Plugins defined in Python\nPLUGINS: dict = {\n    \"database\": [\"db.backends.sqlite3\"],\n    \"cache\": [\"cache.backends.memory\"],\n}\n\n# Database Configuration\nDATABASE = {\n    \"driver\": \"sqlite3\",\n    \"name\": BASE_DIR / \"db.sqlite3\",\n}\n\n# Security\nSECRET_KEY = \"dev-secret-key-change-in-production\"\nALLOWED_HOSTS = [\"*\"]\n\n# Application\nDEBUG = True\nLOG_LEVEL = \"DEBUG\"\n</code></pre>"},{"location":"getting-started/configuration/#configenvdevelopmenttoml","title":"config/.env/development.toml","text":"<pre><code>[env]\nDATABASE_URL = \"sqlite:///dev.db\"\nDEBUG = \"true\"\nAPI_KEY = \"dev-api-key\"\nREDIS_URL = \"redis://localhost:6379/0\"\n</code></pre>"},{"location":"getting-started/configuration/#configenvproductiontoml","title":"config/.env/production.toml","text":"<pre><code>[env]\nDATABASE_URL = \"postgresql://prod-db/myapp\"\nDEBUG = \"false\"\nAPI_KEY = \"prod-api-key-secure\"\nREDIS_URL = \"redis://prod-redis:6379/0\"\nSENTRY_DSN = \"https://xxx@sentry.io/yyy\"\n</code></pre>"},{"location":"getting-started/configuration/#mainpy","title":"main.py","text":"<pre><code>\"\"\"Main Application Entry Point\"\"\"\n\nfrom pathlib import Path\nfrom spoc.framework import Framework, Schema\n\n# Define application schema\nschema = Schema(\n    modules=[\"models\", \"views\", \"services\"],\n    dependencies={\n        \"views\": [\"models\"],\n        \"services\": [\"models\"],\n    },\n    hooks={\n        \"models\": {\n            \"startup\": lambda m: print(f\"Models loaded: {m.__name__}\"),\n        }\n    }\n)\n\n# Initialize framework\nframework = Framework(\n    base_dir=Path(__file__).parent,\n    schema=schema,\n    echo=True\n)\n\n# Access configuration\nprint(f\"Mode: {framework.config.project['mode']}\")\nprint(f\"Debug: {framework.config.settings.DEBUG}\")\nprint(f\"Database: {framework.config.environment.get('DATABASE_URL')}\")\nprint(f\"Installed Apps: {framework.installed_apps}\")\n\n# Use the framework\n# ... your application logic ...\n\n# Shutdown\nframework.shutdown()\n</code></pre>"},{"location":"getting-started/configuration/#configuration-best-practices","title":"Configuration Best Practices","text":""},{"location":"getting-started/configuration/#1-separate-concerns","title":"1. Separate Concerns","text":"<ul> <li>spoc.toml: Project structure, apps, plugins</li> <li>settings.py: Application constants, defaults</li> <li>.env/*.toml: Environment-specific secrets and URLs</li> </ul>"},{"location":"getting-started/configuration/#2-use-modes-effectively","title":"2. Use Modes Effectively","text":"<p>Organize apps by deployment stage:</p> <pre><code>[spoc.apps]\nproduction = [\"core\", \"auth\", \"api\"]           # Essential apps\nstaging = [\"admin\", \"monitoring\"]              # Testing/admin\ndevelopment = [\"debug_toolbar\", \"demo\", \"dev\"] # Development tools\n</code></pre>"},{"location":"getting-started/configuration/#3-keep-secrets-in-environment-files","title":"3. Keep Secrets in Environment Files","text":"<p>Never commit sensitive data to spoc.toml or settings.py:</p> <pre><code># Good: In .env/production.toml (add to .gitignore)\n[env]\nSECRET_KEY = \"real-secret-key\"\nAPI_KEY = \"sensitive-api-key\"\n</code></pre> <pre><code># Bad: In settings.py (committed to git)\nSECRET_KEY = \"my-secret-key\"  # Don't do this!\n</code></pre>"},{"location":"getting-started/configuration/#4-use-type-hints-in-settings","title":"4. Use Type Hints in Settings","text":"<p>Make your settings.py type-safe:</p> <pre><code>from pathlib import Path\nfrom typing import Dict, List\n\nBASE_DIR: Path = Path(__file__).resolve().parent.parent\nINSTALLED_APPS: List[str] = [\"core\", \"auth\"]\nDATABASE: Dict[str, Any] = {\"driver\": \"sqlite3\"}\nDEBUG: bool = True\n</code></pre>"},{"location":"getting-started/configuration/#5-provide-defaults","title":"5. Provide Defaults","text":"<p>Always provide sensible defaults:</p> <pre><code># Settings with defaults\nLOG_LEVEL = \"INFO\"\nCACHE_TIMEOUT = 300\nMAX_UPLOAD_SIZE = 5 * 1024 * 1024  # 5MB\n</code></pre>"},{"location":"getting-started/configuration/#6-document-configuration","title":"6. Document Configuration","text":"<p>Add comments to explain non-obvious settings:</p> <pre><code># Number of worker threads for background tasks\n# Increase for high-load environments\nWORKER_THREADS = 4\n\n# Session timeout in seconds\n# Default: 30 minutes\nSESSION_TIMEOUT = 1800\n</code></pre>"},{"location":"getting-started/configuration/#troubleshooting","title":"Troubleshooting","text":""},{"location":"getting-started/configuration/#configuration-not-found","title":"Configuration Not Found","text":"<p>If you see:</p> <pre><code>ConfigurationError: Could not find configuration module\n</code></pre> <p>Solution: Ensure you have one of these files:</p> <ul> <li><code>config/settings.py</code></li> <li><code>config/config.py</code></li> <li><code>settings.py</code> (in project root)</li> </ul>"},{"location":"getting-started/configuration/#invalid-toml","title":"Invalid TOML","text":"<p>If you see:</p> <pre><code>ConfigurationError: Invalid TOML format in spoc.toml\n</code></pre> <p>Solution: Validate your TOML syntax. Common issues:</p> <ul> <li>Missing quotes around strings</li> <li>Incorrect bracket syntax</li> <li>Missing commas in arrays</li> </ul>"},{"location":"getting-started/configuration/#missing-required-keys","title":"Missing Required Keys","text":"<p>If you see:</p> <pre><code>ConfigurationError: Missing required key: spoc.mode\n</code></pre> <p>Solution: Ensure spoc.toml has all required fields:</p> <pre><code>[spoc]\nmode = \"development\"\ndebug = true\n\n[spoc.apps]\n# At least an empty dict\n\n[spoc.plugins]\n# At least an empty dict\n</code></pre>"},{"location":"getting-started/configuration/#environment-file-not-loading","title":"Environment File Not Loading","text":"<p>If environment variables aren't loading:</p> <ol> <li>Check the mode in spoc.toml matches your .env file name</li> <li>Verify the .env directory structure</li> <li>Ensure the file has <code>[env]</code> section</li> </ol>"},{"location":"getting-started/configuration/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about Quick Start to build your first SPOC app</li> <li>Explore Framework to understand how configuration is used</li> <li>Check out Components for registering application components</li> </ul>"},{"location":"getting-started/configuration/#related-documentation","title":"Related Documentation","text":"<ul> <li>Installation - Setting up SPOC</li> <li>Framework API - Framework configuration usage</li> <li>Components API - Component registration</li> </ul>"},{"location":"getting-started/installation/","title":"Installation","text":"<p>This guide will walk you through installing SPOC on your system.</p>"},{"location":"getting-started/installation/#prerequisites","title":"Prerequisites","text":"<p>SPOC requires Python 3.13 or higher. Before installing, ensure you have a compatible Python version:</p> python --versionPython 3.13.0 <p>Python Version</p> <p>SPOC is built to leverage the latest Python features and requires Python &gt;= 3.13. If you need to upgrade Python, visit python.org.</p>"},{"location":"getting-started/installation/#installation-methods","title":"Installation Methods","text":""},{"location":"getting-started/installation/#using-pip","title":"Using pip","text":"<p>The simplest way to install SPOC is using pip:</p> pip install spocSuccessfully installed spoc"},{"location":"getting-started/installation/#using-uv","title":"Using uv","text":"<p>uv is a fast Python package installer and resolver. To install SPOC with uv:</p> uv add spocResolved 1 package in 50msDownloaded 1 package in 100msInstalled 1 package in 5ms + spoc==0.1.0 <p>Why uv?</p> <p>uv is significantly faster than pip and provides better dependency resolution. It's especially useful for large projects with many dependencies.</p>"},{"location":"getting-started/installation/#development-installation","title":"Development Installation","text":"<p>If you want to contribute to SPOC or modify it for your needs, you can install it from source:</p> <ol> <li> <p>Clone the repository:</p> <p>git clone https://github.com/hlop3z/spoc.gitCloning into 'spoc'...remote: Enumerating objects: 100, done.remote: Counting objects: 100% (100/100), done.remote: Compressing objects: 100% (75/75), done.Receiving objects: 100% (100/100), done.</p> </li> <li> <p>Navigate to the project directory:</p> <p>cd spoc</p> </li> <li> <p>Install in editable mode:</p> <p>pip install -e .Obtaining file:///path/to/spocInstalling collected packages: spoc  Running setup.py develop for spocSuccessfully installed spoc</p> <p>Or with development dependencies:</p> <p>pip install -e \".[dev]\"Obtaining file:///path/to/spocInstalling collected packages: spoc, pytest, ruffSuccessfully installed spoc pytest-9.0.2 ruff-0.14.13</p> </li> </ol> <p>Editable Mode</p> <p>The <code>-e</code> flag installs the package in editable mode, meaning changes to the source code are immediately reflected without reinstalling.</p>"},{"location":"getting-started/installation/#verifying-installation","title":"Verifying Installation","text":"<p>After installation, verify that SPOC is correctly installed by importing it in Python:</p> pythonPython 3.13.0 (main, Oct  7 2024, 10:00:00)&gt;&gt;&gt; import spoc&gt;&gt;&gt; print(spoc.__version__)0.1.0&gt;&gt;&gt; print(spoc.__about__.__title__)spoc <p>You can also verify the installation by checking the available modules:</p> <pre><code>&gt;&gt;&gt; from spoc import Framework, Schema\n&gt;&gt;&gt; from spoc.components import component\n&gt;&gt;&gt; print(\"SPOC is ready to use!\")\nSPOC is ready to use!\n</code></pre> <p>If the import succeeds without errors, SPOC is successfully installed and ready to use!</p>"},{"location":"getting-started/installation/#next-steps","title":"Next Steps","text":"<p>Now that you have SPOC installed, you can:</p> <ul> <li>Follow the Quick Start guide to build your first SPOC application</li> <li>Learn about Configuration to set up your project</li> <li>Explore the Framework documentation to understand core concepts</li> </ul>"},{"location":"getting-started/installation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"getting-started/installation/#python-version-issues","title":"Python Version Issues","text":"<p>If you encounter a version error:</p> <pre><code>ERROR: Package 'spoc' requires a different Python: 3.12.0 not in '&gt;=3.13'\n</code></pre> <p>You need to upgrade to Python 3.13 or higher. Check your Python version with <code>python --version</code> and install the required version.</p>"},{"location":"getting-started/installation/#import-errors","title":"Import Errors","text":"<p>If you get an import error after installation:</p> <pre><code>&gt;&gt;&gt; import spoc\nModuleNotFoundError: No module named 'spoc'\n</code></pre> <p>Ensure you're using the same Python environment where you installed SPOC. If you're using virtual environments, make sure it's activated.</p>"},{"location":"getting-started/installation/#permission-errors","title":"Permission Errors","text":"<p>If you encounter permission errors during installation on Linux/macOS:</p> pip install --user spocSuccessfully installed spoc <p>The <code>--user</code> flag installs the package in your user directory instead of system-wide.</p>"},{"location":"getting-started/installation/#virtual-environments","title":"Virtual Environments","text":"<p>We strongly recommend using a virtual environment to isolate your project dependencies:</p>"},{"location":"getting-started/installation/#using-venv","title":"Using venv","text":"python -m venv .venvsource .venv/bin/activate  # On Windows: .venv\\Scripts\\activate(.venv) $ pip install spocSuccessfully installed spoc"},{"location":"getting-started/installation/#using-uv_1","title":"Using uv","text":"uv venvUsing Python 3.13.0Creating virtual environment at: .venvActivate with: source .venv/bin/activatesource .venv/bin/activate  # On Windows: .venv\\Scripts\\activate(.venv) $ uv pip install spocResolved 1 package in 50msInstalled 1 package in 5ms + spoc==0.1.0 <p>Installation Complete</p> <p>You're all set! SPOC is installed and ready to help you build modular monolith applications.</p>"},{"location":"getting-started/quick-start/","title":"Quick Start Guide","text":"<p>Get up and running with SPOC in minutes. This guide walks you through building your first SPOC application from scratch.</p>"},{"location":"getting-started/quick-start/#what-youll-build","title":"What You'll Build","text":"<p>By the end of this guide, you'll have a working SPOC application that:</p> <ul> <li>Organizes code into modular apps</li> <li>Manages dependencies between modules</li> <li>Registers and discovers components</li> <li>Handles lifecycle events (startup/shutdown)</li> </ul>"},{"location":"getting-started/quick-start/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.13 or higher</li> <li>Basic understanding of Python modules and classes</li> </ul>"},{"location":"getting-started/quick-start/#installation","title":"Installation","text":"<p>Install SPOC using pip:</p> <pre><code>pip install spoc\n</code></pre>"},{"location":"getting-started/quick-start/#project-structure","title":"Project Structure","text":"<p>SPOC applications follow a Django-like structure with an <code>apps</code> directory containing your modular applications.</p> <pre><code>graph TD\n    A{my_project/} --&gt; B{apps/}\n    A --&gt; C{config/}\n    A --&gt; D[main.py]\n\n    B --&gt; E[blog/]\n    B --&gt; F[users/]\n\n    E --&gt; E1[models.py]\n    E --&gt; E2[views.py]\n\n    F --&gt; F1[models.py]\n    F --&gt; F2[views.py]\n\n    C --&gt; C1[settings.py]\n    C --&gt; C2[spoc.toml]\n    C --&gt; C3[__init__.py]\n</code></pre> <p>Create your project structure:</p> <pre><code>my_project/\n\u251c\u2500\u2500 apps/\n\u2502   \u251c\u2500\u2500 blog/\n\u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502   \u251c\u2500\u2500 models.py\n\u2502   \u2502   \u2514\u2500\u2500 views.py\n\u2502   \u2514\u2500\u2500 users/\n\u2502       \u251c\u2500\u2500 __init__.py\n\u2502       \u251c\u2500\u2500 models.py\n\u2502       \u2514\u2500\u2500 views.py\n\u251c\u2500\u2500 config/\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 settings.py\n\u2502   \u2514\u2500\u2500 spoc.toml\n\u2514\u2500\u2500 main.py\n</code></pre>"},{"location":"getting-started/quick-start/#step-1-configure-your-project","title":"Step 1: Configure Your Project","text":""},{"location":"getting-started/quick-start/#create-settings","title":"Create Settings","text":"<p>Create <code>config/settings.py</code>:</p> <pre><code>\"\"\"Project settings configuration.\"\"\"\n\nfrom pathlib import Path\n\n# Base directory of the project\nBASE_DIR: Path = Path(__file__).resolve().parent.parent\n\n# Apps to load (always installed, regardless of mode)\nINSTALLED_APPS: list = [\n    \"blog\",\n]\n\n# Plugins for extending functionality\nPLUGINS: dict = {\n    \"middleware\": [],\n    \"hooks\": [],\n}\n</code></pre>"},{"location":"getting-started/quick-start/#create-spoc-configuration","title":"Create SPOC Configuration","text":"<p>Create <code>config/spoc.toml</code>:</p> <pre><code># Application Configuration\n[spoc]\nmode = \"development\"  # Options: development, staging, production\ndebug = true\n\n# Apps by Environment Mode\n[spoc.apps]\nproduction = [\"users\"]\nstaging = []\ndevelopment = []\n\n# Additional Plugins\n[spoc.plugins]\nmiddleware = []\nhooks = []\n</code></pre> <p>How it works:</p> <ul> <li>Apps in <code>INSTALLED_APPS</code> are always loaded</li> <li>Apps in <code>[spoc.apps.development]</code> load only in development mode</li> <li>Apps in <code>[spoc.apps.production]</code> load in production mode</li> <li>The mode determines which apps are active</li> </ul>"},{"location":"getting-started/quick-start/#step-2-define-components","title":"Step 2: Define Components","text":"<p>Components are reusable units of functionality that SPOC can discover and manage.</p>"},{"location":"getting-started/quick-start/#create-models","title":"Create Models","text":"<p>Create <code>apps/blog/models.py</code>:</p> <pre><code>\"\"\"Blog models.\"\"\"\n\nimport dataclasses as dc\nfrom spoc import Components\n\n# Create a component registry\ncomponents = Components()\ncomponents.add_type(\"model\")\n\n@dc.dataclass\n@components.register(\"model\")\nclass Post:\n    \"\"\"Blog post model.\"\"\"\n    id: int\n    title: str\n    content: str\n    author_id: int\n\n@dc.dataclass\n@components.register(\"model\")\nclass Comment:\n    \"\"\"Comment model.\"\"\"\n    id: int\n    post_id: int\n    text: str\n    author_id: int\n</code></pre> <p>Create <code>apps/users/models.py</code>:</p> <pre><code>\"\"\"User models.\"\"\"\n\nimport dataclasses as dc\nfrom spoc import Components\n\ncomponents = Components()\ncomponents.add_type(\"model\")\n\n@dc.dataclass\n@components.register(\"model\")\nclass User:\n    \"\"\"User model.\"\"\"\n    id: int\n    username: str\n    email: str\n</code></pre>"},{"location":"getting-started/quick-start/#create-views","title":"Create Views","text":"<p>Create <code>apps/blog/views.py</code>:</p> <pre><code>\"\"\"Blog views.\"\"\"\n\nfrom spoc import Components\n\ncomponents = Components()\ncomponents.add_type(\"view\")\n\n@components.register(\"view\")\ndef list_posts():\n    \"\"\"List all blog posts.\"\"\"\n    return {\"action\": \"list_posts\", \"status\": \"success\"}\n\n@components.register(\"view\")\ndef create_post():\n    \"\"\"Create a new blog post.\"\"\"\n    return {\"action\": \"create_post\", \"status\": \"success\"}\n</code></pre>"},{"location":"getting-started/quick-start/#step-3-define-your-schema","title":"Step 3: Define Your Schema","text":"<p>The Schema defines which modules to load, their dependencies, and lifecycle hooks.</p> <p>Create <code>main.py</code>:</p> <pre><code>\"\"\"Main application entry point.\"\"\"\n\nfrom pathlib import Path\nfrom spoc import Framework, Schema, Hook\nfrom config import settings\n\n# Define the application schema\nschema = Schema(\n    # Modules to load from each app\n    modules=[\"models\", \"views\"],\n\n    # Module dependencies (views depend on models)\n    dependencies={\n        \"views\": [\"models\"],\n    },\n\n    # Lifecycle hooks\n    hooks={\n        \"models\": Hook(\n            startup=lambda m: print(f\"\u2713 Loaded models: {m.__name__}\"),\n            shutdown=lambda m: print(f\"\u2717 Unloading models: {m.__name__}\"),\n        ),\n        \"views\": Hook(\n            startup=lambda m: print(f\"\u2713 Loaded views: {m.__name__}\"),\n            shutdown=lambda m: print(f\"\u2717 Unloading views: {m.__name__}\"),\n        ),\n    },\n)\n\n# Create the framework instance\nframework = Framework(\n    base_dir=settings.BASE_DIR,\n    schema=schema,\n    echo=False,  # Set to True for debug output\n    mode=\"strict\",  # \"strict\" enforces all modules exist, \"loose\" allows missing\n)\n\ndef main():\n    \"\"\"Run the application.\"\"\"\n    print(\"\\n=== SPOC Application Started ===\\n\")\n\n    # Access installed apps\n    print(f\"Installed apps: {framework.installed_apps}\")\n\n    # Get all models\n    print(\"\\n--- Registered Models ---\")\n    if hasattr(framework.components, 'models'):\n        for name, model in framework.components.models.items():\n            print(f\"  \u2022 {name}: {model}\")\n\n    # Get all views\n    print(\"\\n--- Registered Views ---\")\n    if hasattr(framework.components, 'views'):\n        for name, view in framework.components.views.items():\n            print(f\"  \u2022 {name}: {view}\")\n\n    # Get a specific component\n    print(\"\\n--- Using Components ---\")\n    list_posts = framework.get_component(\"views\", \"blog.list_posts\")\n    if list_posts:\n        result = list_posts()\n        print(f\"list_posts() returned: {result}\")\n\n    print(\"\\n=== Application Running ===\\n\")\n\n    # When done, shutdown gracefully\n    framework.shutdown()\n    print(\"\\n=== Application Stopped ===\\n\")\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"getting-started/quick-start/#step-4-run-your-application","title":"Step 4: Run Your Application","text":"<p>Execute your application:</p> <pre><code>python main.py\n</code></pre> <p>Expected output:</p> <pre><code>apps_path C:\\path\\to\\my_project\\apps\n\u2713 Loaded models: blog.models\n\u2713 Loaded models: users.models\n\u2713 Loaded views: blog.views\n\n=== SPOC Application Started ===\n\nInstalled apps: ['blog', 'users']\n\n--- Registered Models ---\n  \u2022 blog.Post: &lt;class 'blog.models.Post'&gt;\n  \u2022 blog.Comment: &lt;class 'blog.models.Comment'&gt;\n  \u2022 users.User: &lt;class 'users.models.User'&gt;\n\n--- Registered Views ---\n  \u2022 blog.list_posts: &lt;function list_posts at 0x...&gt;\n  \u2022 blog.create_post: &lt;function create_post at 0x...&gt;\n\n--- Using Components ---\nlist_posts() returned: {'action': 'list_posts', 'status': 'success'}\n\n=== Application Running ===\n\n\u2717 Unloading views: blog.views\n\u2717 Unloading models: users.models\n\u2717 Unloading models: blog.models\n\n=== Application Stopped ===\n</code></pre>"},{"location":"getting-started/quick-start/#understanding-key-concepts","title":"Understanding Key Concepts","text":""},{"location":"getting-started/quick-start/#1-schema","title":"1. Schema","text":"<p>The <code>Schema</code> defines your application's structure:</p> <pre><code>schema = Schema(\n    modules=[\"models\", \"views\", \"services\"],\n    dependencies={\n        \"views\": [\"models\"],\n        \"services\": [\"models\"],\n    },\n    hooks={\n        \"models\": Hook(startup=init_db, shutdown=close_db),\n    },\n)\n</code></pre> <ul> <li>modules: List of module names to load from each app</li> <li>dependencies: Dictionary mapping modules to their required dependencies</li> <li>hooks: Lifecycle callbacks for module startup/shutdown</li> </ul>"},{"location":"getting-started/quick-start/#2-framework","title":"2. Framework","text":"<p>The <code>Framework</code> orchestrates your application:</p> <pre><code>framework = Framework(\n    base_dir=Path(\"./my_project\"),\n    schema=schema,\n    echo=False,\n    mode=\"strict\",\n)\n</code></pre> <ul> <li>base_dir: Root directory of your project</li> <li>schema: Schema defining modules and dependencies</li> <li>echo: Enable debug output (default: False)</li> <li>mode:</li> <li><code>\"strict\"</code> - All modules must exist in all apps</li> <li><code>\"loose\"</code> - Apps can have missing modules</li> </ul>"},{"location":"getting-started/quick-start/#3-components","title":"3. Components","text":"<p>Components are discoverable units with metadata:</p> <pre><code>from spoc import Components\n\ncomponents = Components()\ncomponents.add_type(\"service\")\n\n@components.register(\"service\", config={\"timeout\": 30})\nclass EmailService:\n    pass\n</code></pre> <p>Access components via the framework:</p> <pre><code># Get a specific component\nservice = framework.get_component(\"service\", \"notifications.EmailService\")\n\n# Get all components of a type\nall_services = framework.components.service.values()\n</code></pre>"},{"location":"getting-started/quick-start/#4-lifecycle-hooks","title":"4. Lifecycle Hooks","text":"<p>Hooks execute during module loading/unloading:</p> <pre><code>def init_database(module):\n    \"\"\"Called when module loads.\"\"\"\n    print(f\"Initializing database for {module.__name__}\")\n    # Setup database connections, create tables, etc.\n\ndef close_database(module):\n    \"\"\"Called when module unloads.\"\"\"\n    print(f\"Closing database for {module.__name__}\")\n    # Close connections, cleanup resources\n\nhooks = {\n    \"models\": Hook(\n        startup=init_database,\n        shutdown=close_database,\n    ),\n}\n</code></pre>"},{"location":"getting-started/quick-start/#application-lifecycle","title":"Application Lifecycle","text":"<p>The framework follows this lifecycle:</p> <pre><code>sequenceDiagram\n    participant User\n    participant Framework\n    participant Apps\n    participant Modules\n\n    User-&gt;&gt;Framework: Create Framework(base_dir, schema)\n    Framework-&gt;&gt;Framework: Load configuration\n    Framework-&gt;&gt;Framework: Register apps\n    Framework-&gt;&gt;Apps: Discover installed apps\n\n    User-&gt;&gt;Framework: startup()\n    Framework-&gt;&gt;Modules: Load modules by dependency order\n    Framework-&gt;&gt;Modules: Execute startup hooks\n    Framework-&gt;&gt;Framework: Register components\n\n    Note over User,Framework: Application runs...\n\n    User-&gt;&gt;Framework: shutdown()\n    Framework-&gt;&gt;Modules: Execute shutdown hooks (reverse order)\n    Framework-&gt;&gt;Modules: Unload modules</code></pre> <p>Automatic Startup: The Framework calls <code>startup()</code> automatically during initialization.</p>"},{"location":"getting-started/quick-start/#common-patterns","title":"Common Patterns","text":""},{"location":"getting-started/quick-start/#pattern-1-shared-component-registry","title":"Pattern 1: Shared Component Registry","text":"<p>Create a shared registry for consistent component types across your app:</p> <pre><code># framework/components.py\nfrom spoc import Components\n\ncomponents = Components()\ncomponents.add_type(\"model\")\ncomponents.add_type(\"view\")\ncomponents.add_type(\"service\")\n\n# Export decorators\ndef model(obj):\n    return components.register(\"model\", obj)\n\ndef view(obj):\n    return components.register(\"view\", obj)\n\ndef service(obj):\n    return components.register(\"service\", obj)\n</code></pre> <p>Use in your apps:</p> <pre><code># apps/blog/models.py\nfrom framework.components import model\n\n@model\nclass Post:\n    pass\n</code></pre>"},{"location":"getting-started/quick-start/#pattern-2-dependency-injection","title":"Pattern 2: Dependency Injection","text":"<p>Access framework components from anywhere:</p> <pre><code>class PostService:\n    def __init__(self, framework):\n        self.framework = framework\n\n    def create_post(self, title, content):\n        # Get the Post model\n        Post = self.framework.get_component(\"model\", \"blog.Post\")\n        return Post(id=1, title=title, content=content)\n</code></pre>"},{"location":"getting-started/quick-start/#pattern-3-environment-based-apps","title":"Pattern 3: Environment-Based Apps","text":"<p>Control which apps load based on environment:</p> <pre><code># spoc.toml\n[spoc]\nmode = \"production\"\n\n[spoc.apps]\nproduction = [\"core\", \"api\"]\ndevelopment = [\"core\", \"api\", \"debug\", \"docs\"]\n</code></pre>"},{"location":"getting-started/quick-start/#next-steps","title":"Next Steps","text":"<p>Now that you have a working SPOC application:</p> <ol> <li>Learn about Configuration: See Configuration Guide for advanced settings</li> <li>Explore Components: Read Components API for metadata and validation</li> <li>Study the Framework: Check Framework API for advanced features</li> <li>Review Examples: Browse the <code>examples/</code> directory in the repository</li> </ol>"},{"location":"getting-started/quick-start/#troubleshooting","title":"Troubleshooting","text":""},{"location":"getting-started/quick-start/#apps-not-loading","title":"Apps Not Loading","text":"<p>Problem: Apps aren't being discovered.</p> <p>Solution: Ensure: - Apps are in the <code>apps/</code> directory - Each app has an <code>__init__.py</code> file - Apps are listed in <code>INSTALLED_APPS</code> or <code>[spoc.apps.&lt;mode&gt;]</code></p>"},{"location":"getting-started/quick-start/#module-not-found","title":"Module Not Found","text":"<p>Problem: <code>ModuleNotFoundError</code> when loading modules.</p> <p>Solution: Check: - Module name matches the file name (e.g., <code>models.py</code> for \"models\") - Module is listed in <code>schema.modules</code> - Dependencies are declared correctly</p>"},{"location":"getting-started/quick-start/#circular-dependencies","title":"Circular Dependencies","text":"<p>Problem: <code>CircularDependencyError</code> during startup.</p> <p>Solution: - Review <code>schema.dependencies</code> for circular references - Restructure dependencies to remove cycles - Consider splitting modules differently</p>"},{"location":"getting-started/quick-start/#strict-mode-errors","title":"Strict Mode Errors","text":"<p>Problem: Framework errors about missing modules.</p> <p>Solution: - Set <code>mode=\"loose\"</code> to allow missing modules - Or ensure all apps have all required modules - Or remove apps that don't match the schema</p>"},{"location":"getting-started/quick-start/#summary","title":"Summary","text":"<p>You've learned how to:</p> <ul> <li>Structure a SPOC project with apps</li> <li>Define schemas with modules, dependencies, and hooks</li> <li>Register and discover components</li> <li>Manage application lifecycle</li> <li>Access components from the framework</li> </ul> <p>SPOC provides a solid foundation for building modular, maintainable Python applications. Continue exploring the documentation to unlock its full potential.</p>"}]}